{"./":{"url":"./","title":"简介","keywords":"","body":"MaixPy 文档简介 --> MaixPy 官方文档官网: maixpy.sipeed.com MaixPy 官方文档中文镜像站: cn.maixpy.sipeed.com MaixPy 例程仓库: Github: maixpy_script 开发板资料下载: dl.sipeed.com Sipeed WIKI wiki.sipeed.com 关于 MaixPy MaixPy 是将 Micropython 移植到 K210（一款 64 位双核带硬件 FPU、卷积加速器、FFT、Sha256 的 RISC-V CPU ） 的一个项目， 支持 MCU 常规操作， 更集成了机器视觉和麦克风阵列， 以快速开发具有极低成本和体积实用的 AIOT 领域智能应用。 MicroPython 是基于 Python3 的语法做的一款解析器，包含了 Python3 的大多数基础语法， 主要运行在性能和内存有限的嵌入式芯片上。（注意 Micropython 不包含 Python3 的所有语法） K210 在硬件上集成了机器视觉和机器听觉能力， 是一款定位 AI 和 AIOT 市场的 SoC，同时也是一颗性能强劲的同时却有着极低的价格的 MCU 。 MaixPy 让我们在 K210 上编程更加简单快捷， 我们也将源代码开源在 Github/MaixPy 上 比如我们需要扫描 I2C 总线上的设备，只需要使用如下代码即可实现： from machine import I2C i2c = I2C(I2C.I2C0, freq=100000, scl=28, sda=29) devices = i2c.scan() print(devices) 同样，我们需要实现一个呼吸灯，只需要如下代码： from machine import Timer,PWM import time tim = Timer(Timer.TIMER0, Timer.CHANNEL0, mode=Timer.MODE_PWM) ch = PWM(tim, freq=500000, duty=50, pin=board_info.LED_G) duty=0 dir = True while True: if dir: duty += 10 else: duty -= 10 if duty>100: duty = 100 dir = False elif duty 实时拍照： import sensor import image import lcd lcd.init() sensor.reset() sensor.set_pixformat(sensor.RGB565) sensor.set_framesize(sensor.QVGA) sensor.run(1) while True: img=sensor.snapshot() lcd.display(img) 这篇文档的内容 所有关于 MaixPy 的内容， 包括： 如何选择并得到一款合适自己的模块或者开发板 如何开始上手使用 库和接口（API）文档查询 可以运行MaixPy的开发板 首先我们选择一款适合自己的开发板， 目前有如下几款高性价比的开发板（核心板）： MaixPy 系列开发板 描述 实物图 说明 Maix Amigo 点击购买 Maix Amigo Maix Cube 点击购买 Maix Cube Maix Dock(M1W) 点击购买 Maix Dock(M1W) 全引脚引出 Maix Dock(M1) 点击购买 Maix Dock(M1) 全引脚引出 Maix Bit 点击购买 Maix Bit 全引脚引出 Maix Duino 点击购买 Maix Duino 兼容 Arduino Maix GO 点击购买 Maix GO Maix Nano 点击购买 Maix Nano 核心开发板 要获得这些板子，可以访问Sipeed（矽速）官网www.sipeed.com，或者官方淘宝店 更多硬件的资料请看 Wiki 开发板介绍 然后请仔细查看左边目录，然后开始使用吧～～ MaixPy 源码 MaixPy 源码是指 运行在 K210 上的 Micropython 的解析器， 使用 C语言 编写，如果只是想使用 MaixPy，不需要了解源码； 如果想参与开发 MaixPy 的内置功能，可以下载进行开发，欢迎大家提交 PR MaixPy 源码托管在 github 分支 自动构建状态 master 本项目主要由 ©Sipeed Co.,Ltd. 维护， 并接受来自开源社区的贡献， 具体贡献这见贡献者列表 MaixPy 文档源码 修改代码后，文档也会随之更新， 文档源码托管在 github，如果文档有错别字或者改进可以提交PR， 注意： 在编辑文档前必须看文档编写规范 分支 文档自动构建状态 master dev 反馈 关于本文档或者功能或者源码方面的问题，也欢迎提交issue: 反馈 powered by GitbookFile Modify: 2020-09-11 12:05:50 "},"others/what_maix_do.html":{"url":"others/what_maix_do.html","title":"What can MaixPy do?","keywords":"","body":"Powerful Maix Board(k210) Can Do Most of them integrated to MaixPy, or some of them include in Maixduino or from other developers Face recognition draw picture Turorial Openmv and Record video MobileNet Face detection NES gamer emulator MNIST Play video Feature map display GBA game emulator Game Quake I source code Game Doom source code MMD 3D rendering your browser does not support the video tag source code Gimbal face track Mic array LittlevGL FFT spectrum powered by GitbookFile Modify: 2020-09-11 12:05:50 "},"get_started/how_to_read.html":{"url":"get_started/how_to_read.html","title":"Before read","keywords":"","body":"How to use (/read) this article correctly Note: Currently the only official document website: maixpy.sipeed.com On start, you can read carefully from the top to the next page according to the directory on the left sidebar. Then you can learn how to update the firmware, how to coding, and you must learn how to use serial terminal Every module's doc contains examples at the end of page, or you can find examples here, you can try them out ~ Finally, the interface and parameters of the module are consulted according to their own needs during use. There is a search box in the upper left corner, which can be used well. You can also use the browser's page search function, ie press Ctrl+F, then enter the content to search and press the enter key If you can't find you want, don't worry, you can go to github's issue (issue) Is there any mention of the page (/search)? If you don't have one, you can create a new issue or contact technical support. If pages load slowly, refresh or just wait, or change your network Doc pages generated by gitbook, there may be some error occur when click too fast but network speed not enough, just take care of the url( path ), for example: Wrong url: http://localhost:4000/zh/zh/get_started/how_to_read.html Correct url: http://localhost:4000/zh/get_started/how_to_read.html so just change the wrong url, or just back to (maixpy.sipeed.com) refresh page In addition, you need to note when asking questions on github or forums: Ask questions to provide complete steps to reproduce the problem, so that developers can test the problem and solve it! For common problems, please see Common Problems powered by GitbookFile Modify: 2020-09-11 12:05:50 "},"get_started/get_hardware.html":{"url":"get_started/get_hardware.html","title":"Get Hardware","keywords":"","body":"Getting a development board Get your favorite hardware from Sipeed's official Taobao store or from Seeed Studio Required hardware A development board See boards in Wiki And get your favorite hardware from Sipeed's official Taobao store or from Seeed Studio USB Type C cable Type-C is chosen because it's reversible and it's very friendly for development. If you're buying from the official Taobao store, you can ask them to include it with your order. Type-C cables are also very common with Android phones. Screen By default, the LCD (24-pin interface) of the st7789 driver chip is used with a resolution of 320x240. If you're buying from the official Taobao store, you can ask them to include it with your order. Camera MaixPy devices support the ov2640 camera by default(or gc0328 or ov7740), and are often bundled with Maix devices. The ov2640 cameras bundled with Maix device are typically offered with two different lens options; a larger focusable fisheye lens, or a smaller fixed-focus lens. If you're buying from the official Taobao store, you can order a specific camera with your order. Micro SD Card (TF Card) (optional) Some Flash memory within the the device is reserved for a file system, but this internal memory is very slow! For quicker operation and additional storage, you can insert a Micro SD card or a TF card into the card slot available on most Maix devices. When purchasing a memory card, try to choose a new fast Micro SD card, such as a SD 2 generation protocol, Class10 memory card. Of course, the quality of SD cards on the market is uneven, and the SPI mode may not be compatible. Try to buy a regular card. Or maybe you should customize the driver code ~~ As shown below, the two cards on the left are not supported by the MaixPy driver. Both the middle and the right cards are supported, but the class10 card in the middle is the fastest(and tested maximum capacity is 128GB). ST-Link (used to update the firmware of the STM32 on the development board Maix Go) (optional) If you purchase a Maix Go, it has an embedded STM32 chip to simulate the USB-to-Serial converter, as well as JTAG. If you want to upgrade its firmware later on, it is recommended to buy an ST-Link programmer. JTAG Debugger (optional) The K210 chip supports JTAG debugging. If you need to debug, you will need to use the JTAG debugger. Please check the Sipeed Taobao store or SeeedStudio.com to buy one. If you are using a Maix Go development board, you won't need to purchase the JTAG debugger separately as it has an integrated STM32 chip that can emulate JTAG (STM32 uses CMSIS-DAP or open-ec firmware). open-ec firmware is currently not supported, although support will be added later. Please refer to the open-ec GitHub project page for more information. powered by GitbookFile Modify: 2020-09-11 12:05:50 "},"get_started/prepare_knowledge.html":{"url":"get_started/prepare_knowledge.html","title":"Prepare knowledge","keywords":"","body":"Basic knowledge To get started with MaixPy，we recommend at least the following basics: With patience, calm down and study the technology, read the documentation and then write the code. Have Python or Micropython knowledge, we will use Python basic grammar. If you don't know anything about Python but you have programmed before, please search for Python basics first. If you've never programmed before, this documentation will be hard to understand. Make sure to learn, at least, basic Python before reading it. Can understand the basic circuit diagram Learn Micropython here： MicroPython Language Introduction General differences between MicroPython and Python can be found here：MicroPython vs CPython（Python3 查看 If you don't follow the previous points, then be prepared to struggle while developing, it will be extremely difficult! powered by GitbookFile Modify: 2020-09-11 12:05:50 "},"get_started/install_driver.html":{"url":"get_started/install_driver.html","title":"Install driver","keywords":"","body":"Install driver We need to install the serial port driver as the board is connected to the computer through the USB to serial converter. Install the driver according to the board's USB to serial port chip model. In you are using Linux or Mac and you don't want to use sudo every time, add yourself to the dialout users group with the following command: sudo usermod -a -G dialout $(whoami) For Dan Dock or Maix Bit The CH340 chip is being used, Linux does not need to install the driver as the system already comes with it. Execute ls /dev/ttyUSB* to check if the device is found. If using Windows, search and download the drivers on the Internet, then open Device manager and look if the serial port is listed. For Maix Go An STM32 is being used to implement the serial port and the JTAG functionality. By default, this STM32 chip is running a build of the open-ec firmware. If everything is right, one or two serial ports will appear. In linux the following two serial ports will appear: /dev/ttyUSB0 and /dev/ttyUSB1. Please use /dev/ttyUSB1 when downloading and accessing the serial port. Windows is similar. If you need to re-burn this firmware, you can download it from GitHub or open-ec firmware, then use the STM32's SW pins (GND, SWDIO, SWCLK) from the ST-LINK connection board for programming. (The STM32 on the current version of the Go board does not support serial port burning. It can only be burned using ST-LINK. Please purchase it if you need it, or use a board with IO simulation such as the Raspberry Pi)) Currently, open-ec cannot simulate JTAG to debug the board. Use CMSIS-DAP to do so. You can download it from the official website and then burn it using an ST-LINK. Afterwards, /dev/ttyACM0 will appear under linux. ST-LINK has a very complete description of the burning method of STM32, please search for yourself. Please note that updating the firmware of STM32 is not the same as updating the MaixPy firmware. Generally, you do not need to update the firmware of STM32. The default is enough. STM32 is just a USB to serial port tool! Do not be confused. For the new Maixduino and Maix Bit versions that come with a microphone (using a CH552 chip) For the boards with a CH552 chip, to get the USB serial port, FT2232 drivers need to be installed. Search yourself for FT2232 drivers. In those boards, the JTAG function is not available. powered by GitbookFile Modify: 2020-09-11 12:05:50 "},"get_started/upgrade_firmware.html":{"url":"get_started/upgrade_firmware.html","title":"Upgrade firmware","keywords":"","body":"Upgrade MaixPy firmware Connecting the board Connect the Type C cable, one end to the development board, one end to the computer. Install driver Install driver as described above Get the upgrade tool Download kflash_gui and you will get a zip file. kflash_gui is cross-platform, it can work on multiple systems (including Windows, Linux, MacOS or even Raspberry Pi) Extract the downloaded file to a folder, then double-click kflash_gui.exe to run the app. Or use terminal toolpip3 install kflash kflash --help kflash -p /dev/ttyUSB0 -b 1500000 -B goE maixpy.bin Get firmware The release version of the firmware is downloaded from the GitHub page The automated builds can be downloaded from here Firmware files have the .bin or .kfpkg extension You can pack kfpkg file with kflash_gui, or manually according to this kfpkg doc Firmware naming instructions: maixpy_v*.bin： Full version of MaixPy firmware (MicroPython + OpenMV API etc.) maixpy_v*_with_lvgl.bin： MaixPy firmware, with LVGL version. (LVGL is an embedded GUI framework, you need to use when writing the interface) maixpy_v0.3.1_minimum.bin： MaixPy firmware minimum set, not supported ´by MaixPy IDE, does not contain OpenMVrelated algorithms face_model_at_0x300000.kfpkg： Face model, placed in address 0x300000, can be downloaded multiple times without conflict elf.7z： elf file, ordinary users do not care, used for crash debugging Upload firmwre to the development board Open kflash_gui Select the firmware, set the options and then click to download. For more features, or instructions on how to use the tool, check the kflash_gui project page For the early Maix Go， if the download fails, try holding the three-phase dial to the down location during the download procedure. powered by GitbookFile Modify: 2020-09-11 12:05:50 "},"get_started/serial_tools.html":{"url":"get_started/serial_tools.html","title":"terminal tools","keywords":"","body":"Serial terminal tools Connecting hardware Connect development board to computer with Type C cable Check if the device has been properly identified: Under Linux can ls /dev/ttyUSB* or ls /dev/ttyACM* to see, if not you can ls /dev come look for the specific device name with the relevant serial chip and drive， and you can use sudo dmesg to find device mount message If Windows, just open Device Manager to view If the device is not found, you need to confirm if the driver is installed and if the connection is good. Using the serial port tool Linux Use minicom(recommend) or screen etc. minicom sudo apt update sudo apt install minicom sudo minicom -s # Then set the serial port number according to the prompt and the baud rate is 115200. Do not know how to search using the search tool. # Set Backspace to DEL function # Set linewrap to Yes sudo minicom Note that minicom's default configuration file save requires sudo permission, so use sudo minicom -s Press A to select device Press E to set the baud rate, the baud rate needs to be set 115200 Here press A and R to set the settings the same as screenshot did, the first setting is for pye, second for display long line After setting save and exit, next time do not need to set up is required, just execute sudo minicom, if you do not want to use sudo every time, execute sudo usermod -a -G dialout $(whoami) to add user to the dialout user groups, then log off or reboot should be execute in order to take effect, note that if change the configuration by sudo minicom -s, the sudo is still needed After entering minicom, click the Enter button or the reset button of dev board to see the interactive interface of MaixPy. Input help(), you can view help To exit minicom, press Ctrl+A X, press Enter confirm to exit Furthermore, you can sepecify device by -D parameter, e.g. minicom -D /dev/ttyUSB1 -b 115200 Windows Use tools like putty or xshell Then select the serial port mode, then set the serial port and baud rate to open the serial port. Then click the Enter button to see the interactive interface of MaixPy. >>> Input help(), you can view help picture from laurentopia's tutorial powered by GitbookFile Modify: 2020-09-11 12:05:50 "},"get_started/maixpyide.html":{"url":"get_started/maixpyide.html","title":"Install MaixPyIDE(optional)","keywords":"","body":"MaixPy IDE MaixPy uses the Micropython syntax, and unlike other languages like C, it doesn't need to be compiled. In fact, you don't even need the IDE to use it, you can use the serial terminal. Using the IDE will facilitate real-time editing of the script on the computer, as well as being able to view the camera images in real time, and save files to the development board. Of course, using the IDE will take some resources from the board (for the transmission and debugging), MaixPy firmware To use the MaixPy IDE , the firmware must be at least v0.3.1, otherwise it won't connect. Check the firmware and IDE version before using it, to ensure normal operation. Download the installation package dl.sipeed.com Check the latest version by reading the readme.txt file. Use CDN link if download too slowly. Installation Using the installer (Recommended, simple and convenient) For Windows run the installer directly by double-clicking the file. For Linux you will need to give the file permission and execute it using the command line: chmod +x maixpy-ide-linux-x86_64-0.2.2.run ./maixpy-ide-linux-x86_64-0.2.2.run Using a compressed package (7z) Extract the file to a folder If your system does not support 7z， you will need to download 7z and install it. If on Linux, you can use the terminal to decompress the file: sudo apt install p7zip-full 7z x maixpy-ide-linux-x86_64-0.2.2-installer-archive.7z -r -omaixpy-ide # `-o` is immediately followed by the decompressed path, there is no space in between. After decompression, execute: On Windows： Double-click maixpyide to execute. You might want to right-click and pin it to the taskbar or start menu. On Linux： Use the following commands:chmod +x setup.sh ./setup.sh ./bin/maipyide.sh Test run Open the IDE and select the model number of the development board in the upper toolbar. Tool-> Select Board Click on connect to make a connection with the MaixPy IDE After the connection is successful, the button will turn from green to red. Below the connection button is the Run button, which will execute the current py file opened in the editor. Click the Run button again to stop the execution. Uploading files You will find ways to upload files in the Tool dropdown menu. Note Only open one serial port connection at a time, make sure to close the previous connection before opening a new one. And try to upgrade firmware or IDE if connect fail. Find the cause according to the error message When the program runs error, a message box will prompt the error, but the error information may not be complete, please find more detailed error information in the terminal output If necessary, disconnect the IDE and run the program using the serial terminal(maybe you need save as file then run this file) only to view the print for troubleshooting If you submit an issue (bbs, group, github issue, etc.), in order to resolve the issue quickly, be sure to bring the complete information described above powered by GitbookFile Modify: 2020-09-11 12:05:50 "},"get_started/power_on.html":{"url":"get_started/power_on.html","title":"Power on","keywords":"","body":"Power Connect hardware Connect development board to computer with Type C cable Check if the device has been properly identified: Under Linux can ls /dev/ttyUSB* or ls /dev/ttyACM* to see, if not you can ls /dev come look for the specific device name with the relevant serial chip and drive， and you can use sudo dmesg to find device mount message If Windows, just open Device Manager to view If the device is not found, you need to confirm if the driver is installed and if the connection is good. Check firmware version Open serial terminal tool, push reset button of board, compare togithub or master branch to check firmware version e.g. [MaixPy] init end __ __ _____ __ __ _____ __ __ | \\/ | /\\ |_ _| \\ \\ / / | __ \\ \\ \\ / / | \\ / | / \\ | | \\ V / | |__) | \\ \\_/ / | |\\/| | / /\\ \\ | | > Version is v0.5.0-12-g284ce83, or you can get version by code: import sys sys.implementation.version Exevute script(code) Open terminal, after push down the reset button, we can see: >>> this means we can input code now, if no this symbol, type in Ctrl+C to cacel running script Then input hello world program >>> print(\"hello world\") hello world >>> Paste multiple lines of code If we need paste code like import os f = os.listdir() print(f) Copy code Type in Ctrl+E Paste code Type in Ctrl+D to execute code >>> paste mode; Ctrl-C to cancel, Ctrl-D to finish === import os === f = os.listdir() === print(f) ['boot.py','main.py', 'freq.conf'] >>> If code is too large, the serial port may lose data, which will cause a syntax error prompt. You can try more times powered by GitbookFile Modify: 2020-09-11 12:05:50 "},"get_started/led_blink.html":{"url":"get_started/led_blink.html","title":"LED blink","keywords":"","body":"Lighting the LED The lighting program is the first program to learn all the development boards. Just like learning all programming languages, learning the hello world is a sacred meaning. Circuit diagram It is well known that lighting an LED requires a power supply, a resistor, and an LED bulb. On the Dan Dock development board, there are three LEDs, the lines are as follows: For example, we want to red light, i.e., LED_R connected to the LED, the LED can be seen in FIG positive 3.3V power supply has been connected, so long as we can LED_R LED lighting is low. Note that LED_R is an alias for this pin, which is actually a pin connected to the chip, such as Pin13(13) Config FPIOA(Field Programmable Input and Output Array) Before writing the program, we need to know that the corresponding pins of the on-chip peripherals (such as GPIO, I2C, etc.) of the hardware K210 used by MaixPy can be arbitrarily set. The STM32 on-chip peripherals and pin correspondences have been fixed. Some of the pins can be multiplexed, compared to the K210 with greater degrees of freedom. For example, I2C can use Pin11 and Pin12, or can be changed to any other pin. Code We control the LEDs and need to use GPIO The procedure is as follows: from Maix import GPIO fm.register(board_info.LED_R, fm.fpioa.GPIO0) led_r=GPIO(GPIO.GPIO0,GPIO.OUT) led_r.value(0) We only need to click the lines of the code one by one to the keyboard inside the terminal and press OK to execute. Among them, we start with the package Maix introduced GPIO this class; Front pin can be set K210, so we use .fm(fpioa manager) correspondence between peripherals and pin registration chip built-in object to this, here　fm.fpioa.GPIO0 is a GPIO Peripheral K210's ( Note the difference between GPIO (peripheral) and pin (real hardware pin)), so the fm.fpioa.GPIO0 registration to pin board_info.LED_R; Here board_info is a board type information can be entered in serial terminal board_info. then press TAB the button to see all the members, or just use pin number like 13. Then define a GPIO subject, specific parameters to see GPIO the module's documentation, look in the left sidebar. Use led_r.value(0) or led_r.value(1) to set high to low It is already possible to light up here. If you know the Python syntax, you can try to write a for loop to achieve LED flashing~ powered by GitbookFile Modify: 2020-09-11 12:05:50 "},"get_started/edit_file.html":{"url":"get_started/edit_file.html","title":"Edit and execute files","keywords":"","body":"Editing, saving and executing files This section teaches you how to edit, save and execute files. REPL interface To keep things simple in the previous example, we entered code directly in the terminal at the Maix prompt which was executed immediately upon pressing the Enter key. Such interactive command line interfaces are often referred to as REPL（Read Eval Print Loop). MaixPy's REPL interface operates similar to most other command line interfaces except that the supported syntax is MicroPython While MaixPy's REPL interface is simple and convenient for small tasks, it soon becomes annoying to re-enter your code each time you want to run it. The solution is to save your code to a file, and then execute the file. The remainder of this page describes that process. MaixPy file system MaixPy devices have an internal file system which can access both internal and external memories. During boot, the device will mount any external memory cards formatted with either SPIFFS or FAT file systems, and add them to the internal file system as the /flash or /sd directories respectively. NOTES: SPIFFS cards are by default assigned to 3MB SPIFFS (starting at flash address 0xD00000). When detected at boot, SPIFFS devices automatically appear as the /flash directory within the device's internal file system. Currently the SPIFFS implementation in MaixPy does not support the creation of directories. FAT formatted SD (TF) cards are supported, but FAT32 or exFAT formatted cards are not currently supported. When detected at boot, FAT formatted cards will be automatically mounted and appear as the /sd directory in the device's internal file system. It should be noted that the root directory is only used to mount the SD card or SPIFFS flash card. All other file operations happen in the /flash or /sd directories, as determined by the format of the memory card discovered at boot time. Navigating the file system In MaixPy's REPL interface and in code the following os commands can be used to navigate directories and manage files. Command Description Example os.chdir() changes the current directory os.chdir(\"/flash\") os.listdir() list the files in the current directory os.listdir() os.listdir(path) list the files in another directory os.listdir(\"/sd\") os.getcwd() return the current working directory os.getcwd() os.rename(old_path, new_path) rename a file os.rename(\"./blue.py\", \"./aaah.py\") os.remove(path) remove a file os.remove(\"./herring.py\") For a complete list of os commands refer to the MicroPython documentation Editing and saving files There are a number of ways you can edit and save files described below as Methods A through C Method A: Edit and save files using the pye editor built into MaixPy MaixPy includes a built-in open source editor Micropython Editor(pye) At the REPL interface enter pye(\"hello.py\") to create a file and enter the edit mode. Keyboard shortcuts and other instructions can be found here Enter the following code: print(\"hello maixpy\") When you have finished editing, press Ctrl+S and then press Enter to save, and then press Ctrl+Q to exit the editor. Note : The pye editor has certain requirements of the connected terminal. For intuitive operation the BackSpace key should be configured to send Ctrl+?, otherwise the BackSpace key will function as Ctrl+H (ie: character replacement). Linux users are recommended to use minicom. Use sudo minicom -s to set the reference to the previous tutorial Windows users can use PuTTY which supports Backspace key configuration. Note Typing Shift-Backspace will cause PuTTY to send whichever code isn't configured as the default. Alternatively, Xshell users can use: File → Properties → Terminal → Keyboard, Change the delete and backspace sequences to ASCII 127. Method B: Read files to PC by uPyLoader, then download to board after editing This method uses the uPyLoader utility Download the executable: release Select the serial port and click the Connect button to connect the board The first time you run the software, you need to initialize it. Click File->Init transfer files to complete the initialization. This will create two files in the board, __upload.py and __download.py. Then double click file name to read and edit, then click the save button to download the file to board Method C: Read files to PC by rshell, edit, and then save back to board Install rshell first according to the doc of rshell sudo apt-get install python3-pip sudo pip3 install rshell rshell -p /dev/ttyUSB1 # select board serial Edit file ls /flash edit /flash/boot.py # the editor uses vim commands Execution of documents Once MicroPython files exist on the file system they may be executed using the following methods Method A: Execute using import At MaixPy's REPL interface simply enter: import hello then press Enter The hello.py file will run and should output hello maixpy But be careful, the import command can only be used once. If you want to execute the code more than once, please use Method B below. Method B: Execute using exec() Use exec() in a simple program to execute your file with open(\"hello.py\") as f: exec(f.read()) Method C: Execute using uPyLoader Just select the file, then click the execute button Method D: Execute files locally on PC using ampy ampy run script by command ampy run file_in_PC.py to execute files on PC (file won't transmit to board) powered by GitbookFile Modify: 2020-09-11 12:05:50 "},"get_started/upload_script.html":{"url":"get_started/upload_script.html","title":"Upload script","keywords":"","body":"Upload script to development board Earlier we came across the pye(\"filename.py\") command to open an editor that directly edits files in the file system. But slowly we will find that this method is only suitable for changing a small amount of code. When the amount of code is huge or we need to highlight support, it does not apply. We need to write the code on the computer and upload it to the board. There are currently several methods: Uploading scripts using the MaixPy IDE Open the MaixPy IDE and connect to the development board. Edit the file, then in the top Tools menu click Save opened file as boot.py to save the code to the development board's boot.py file. The next time the board is powered on, it will be automatically executed. You can also use the Send file option in the Tools menu to send the file. It will be saved to the development board with the same name. This script can also upload other small files. Uploading and running scripts using the graphical tool uPyLoader uPyLoader is an open source software that allows you to easily connect to MaixPy and upload, download, and execute files, monitor output, and more. Download the executable: release Select the serial port and click the Connect button to connect the board The first time you run the software you will need to initialize it. Click File -> Init transfer files to complete the initialization. This will create two files in the board, __upload.py and __download.py. On the left side select the file you want to upload and click Transfer to upload it to the board's file system. On the right side are the files inside the board, click List files to refresh the file list. To execute the script, simply select the file name and click on Execute. Click on View -> Terminal above to open the terminal to view the runtime output or send a command Using rshell tool Just as widh the linux, use the cp on rshell to copy the file to the development board. First, install rshell: sudo apt-get install python3-pip sudo pip3 install rshell rshell -p /dev/ttyUSB1 # choose the device according to your serial port Then copy file~ ls /flash cp ./test.py /flash/ # copies the file \"text.py\" from the computer to the root directory of the development board You can learn about other features of rshell in its project page. Using the command line tool ampy ampy is an open source, easy-to-use command line tool for uploading, downloading, and executing files. Note that this tool is running on the computer, not on the board. Use ampy --help to view help and information. The ampy run file_in_PC.py command also allows you to run the script directly on the board without uploading it previously. TF card copy After copying it to the TF card, execute import filename in the terminal to run the script. powered by GitbookFile Modify: 2020-09-11 12:05:50 "},"get_started/boot.html":{"url":"get_started/boot.html","title":"Auto start","keywords":"","body":"Boot script If a memory card formatted with either a SPIFFS or FAT file system is detected at boot, MaixPy will look for a boot.py file in the root directory of that memory card. If boot.py is found, the system will immediately execute it. And then find main.py and execute it. If the main.py file is not found, the device will automatically create one on the memory card that offers a basic REPL command line interface. Edit the contents of the main.py file on the memory card to determine what the device does when it is reset or rebooted. Notes: Memory cards must be formatted with a SPIFFS or FAT filesystem, not FAT32. FAT memory cards will have a mount point of /sd, while SPIFFS cards will appear as /flash. powered by GitbookFile Modify: 2020-09-11 12:05:50 "},"libs/standard/":{"url":"libs/standard/","title":"Standard library","keywords":"","body":"standard libs cmath gc math sys ubinascii ucollections uctypes uerrno uheapq ujson uos ure uselect ustruct utime uzlib powered by GitbookFile Modify: 2020-09-11 12:05:50 "},"libs/standard/cmath.html":{"url":"libs/standard/cmath.html","title":"cmath","keywords":"","body":"cmath – mathematical functions for complex numbers This module implements a subset of the corresponding CPython module, as described below. For more information, refer to the original CPython documentation: cmath. The cmath module provides some basic mathematical functions for working with complex numbers. Availability: not available on WiPy and ESP8266. Floating point support required for this module. Functions cos cmath.cos(z) Return the cosine of z. exp cmath.exp(z) Return the exponential of z. log cmath.log(z) Return the natural logarithm of z. The branch cut is along the negative real axis. log10 cmath.log10(z) Return the base-10 logarithm of z. The branch cut is along the negative real axis. phase cmath.phase(z) Returns the phase of the number z, in the range (-pi, +pi]. polar cmath.polar(z) Returns, as a tuple, the polar form of z. rect cmath.rect(r, phi) Returns the complex number with modulus r and phase phi. sin cmath.sin(z) Return the sine of z. sqrt cmath.sqrt(z) Return the square-root of z. Constants cmath.e base of the natural logarithm cmath.pi the ratio of a circle’s circumference to its diameter powered by GitbookFile Modify: 2020-09-11 12:05:50 "},"libs/standard/gc.html":{"url":"libs/standard/gc.html","title":"gc","keywords":"","body":"gc – control the garbage collector This module implements a subset of the corresponding CPython module, as described below. For more information, refer to the original CPython documentation: gc. Functions gc.enable() Enable automatic garbage collection. gc.disable() Disable automatic garbage collection. Heap memory can still be allocated, and garbage collection can still be initiated manually using gc.collect(). gc.collect() Run a garbage collection. gc.mem_alloc() Return the number of bytes of heap RAM that are allocated. Difference to CPython This function is MicroPython extension. gc.mem_free() Return the number of bytes of available heap RAM, or -1 if this amount is not known. Difference to CPython This function is MicroPython extension. gc.threshold([amount]) Set or query the additional GC allocation threshold. Normally, a collection is triggered only when a new allocation cannot be satisfied, i.e. on an out-of-memory (OOM) condition. If this function is called, in addition to OOM, a collection will be triggered each time after amount bytes have been allocated (in total, since the previous time such an amount of bytes have been allocated). amount is usually specified as less than the full heap size, with the intention to trigger a collection earlier than when the heap becomes exhausted, and in the hope that an early collection will prevent excessive memory fragmentation. This is a heuristic measure, the effect of which will vary from application to application, as well as the optimal value of the amount parameter. Calling the function without argument will return the current value of the threshold. A value of -1 means a disabled allocation threshold. Difference to CPython This function is a MicroPython extension. CPython has a similar function - set_threshold(), but due to different GC implementations, its signature and semantics are different. powered by GitbookFile Modify: 2020-09-11 12:05:50 "},"libs/standard/math.html":{"url":"libs/standard/math.html","title":"math","keywords":"","body":"math – mathematical functions This module implements a subset of the corresponding CPython module, as described below. For more information, refer to the original CPython documentation: math. The math module provides some basic mathematical functions for working with floating-point numbers. Note: On the pyboard, floating-point numbers have 32-bit precision. Availability: not available on WiPy. Floating point support required for this module. Functions math.acos(x) Return the inverse cosine of x. math.acosh(x) Return the inverse hyperbolic cosine of x. math.asin(x) Return the inverse sine of x. math.asinh(x) Return the inverse hyperbolic sine of x. math.atan(x) Return the inverse tangent of x. math.atan2(y, x) Return the principal value of the inverse tangent of y/x. math.atanh(x) Return the inverse hyperbolic tangent of x. math.ceil(x) Return an integer, being x rounded towards positive infinity. math.copysign(x, y) Return x with the sign of y. math.cos(x) Return the cosine of x. math.cosh(x) Return the hyperbolic cosine of x. math.degrees(x) Return radians x converted to degrees. math.erf(x) Return the error function of x. math.erfc(x) Return the complementary error function of x. math.exp(x) Return the exponential of x. math.expm1(x) Return exp(x) - 1. math.fabs(x) Return the absolute value of x. math.floor(x) Return an integer, being x rounded towards negative infinity. math.fmod(x, y) Return the remainder of x/y. math.frexp(x) Decomposes a floating-point number into its mantissa and exponent. The returned value is the tuple (m, e) such that x == m * 2**e exactly. If x == 0 then the function returns (0.0, 0), otherwise the relation 0.5 holds. math.gamma(x) Return the gamma function of x. math.isfinite(x) Return True if x is finite. math.isinf(x) Return True if x is infinite. math.isnan(x) Return True if x is not-a-number math.ldexp(x, exp) Return x * (2**exp). math.lgamma(x) Return the natural logarithm of the gamma function of x. math.log(x) Return the natural logarithm of x. math.log10(x) Return the base-10 logarithm of x. math.log2(x) Return the base-2 logarithm of x. math.modf(x) Return a tuple of two floats, being the fractional and integral parts of x. Both return values have the same sign as x. math.pow(x, y) Returns x to the power of y. math.radians(x) Return degrees x converted to radians. math.sin(x) Return the sine of x. math.sinh(x) Return the hyperbolic sine of x. math.sqrt(x) Return the square root of x. math.tan(x) Return the tangent of x. math.tanh(x) Return the hyperbolic tangent of x. math.trunc(x) Return an integer, being x rounded towards 0. Constants math.e base of the natural logarithm math.pi the ratio of a circle’s circumference to its diameter powered by GitbookFile Modify: 2020-09-11 12:05:50 "},"libs/standard/sys.html":{"url":"libs/standard/sys.html","title":"sys","keywords":"","body":"sys – system specific functions This module implements a subset of the corresponding CPython module, as described below. For more information, refer to the original CPython documentation: sys. Functions sys.exit(retval=0) Terminate current program with a given exit code. Underlyingly, this function raise as SystemExit exception. If an argument is given, its value given as an argument to SystemExit. sys.print_exception(exc, file=sys.stdout) Print exception with a traceback to a file-like object file (or sys.stdout by default). Difference to CPython This is simplified version of a function which appears in the traceback module in CPython. Unlike traceback.print_exception(), this function takes just exception value instead of exception type, exception value, and traceback object; file argument should be positional; further arguments are not supported. CPython-compatible traceback module can be found in micropython-lib. Constants sys.argv A mutable list of arguments the current program was started with. sys.byteorder The byte order of the system (\"little\" or \"big\"). sys.implementation Object with information about the current Python implementation. For MicroPython, it has following attributes: name - string “micropython” version - tuple (major, minor, micro), e.g. (1, 7, 0) This object is the recommended way to distinguish MicroPython from other Python implementations (note that it still may not exist in the very minimal ports). Difference to CPython CPython mandates more attributes for this object, but the actual useful bare minimum is implemented in MicroPython. sys.maxsize Maximum value which a native integer type can hold on the current platform, or maximum value representable by MicroPython integer type, if it’s smaller than platform max value (that is the case for MicroPython ports without long int support). This attribute is useful for detecting “bitness” of a platform (32-bit vs 64-bit, etc.). It’s recommended to not compare this attribute to some value directly, but instead count number of bits in it: bits = 0 v = sys.maxsize while v: bits += 1 v >>= 1 if bits > 32: # 64-bit (or more) platform ... else: # 32-bit (or less) platform # Note that on 32-bit platform, value of bits may be less than 32 # (e.g. 31) due to peculiarities described above, so use \"> 16\", # \"> 32\", \"> 64\" style of comparisons. sys.modules Dictionary of loaded modules. On some ports, it may not include builtin modules. sys.path A mutable list of directories to search for imported modules. sys.platform The platform that MicroPython is running on. For OS/RTOS ports, this is usually an identifier of the OS, e.g. \"linux\". For baremetal ports it is an identifier of a board, e.g. \"pyboard\" for the original MicroPython reference board. It thus can be used to distinguish one board from another. If you need to check whether your program runs on MicroPython (vs other Python implementation), use sys.implementation instead. sys.stderr Standard error stream. sys.stdin Standard input stream. sys.stdout Standard output stream. sys.version Python language version that this implementation conforms to, as a string. sys.version_info Python language version that this implementation conforms to, as a tuple of ints. powered by GitbookFile Modify: 2020-09-11 12:05:50 "},"libs/standard/ubinascii.html":{"url":"libs/standard/ubinascii.html","title":"ubinascii","keywords":"","body":"ubinascii – binary/ASCII conversions This module implements a subset of the corresponding CPython module, as described below. For more information, refer to the original CPython documentation: binascii. This module implements conversions between binary data and various encodings of it in ASCII form (in both directions). Functions ubinascii.hexlify(data[, sep]) Convert binary data to hexadecimal representation. Returns bytes string. Difference to CPython If additional argument, sep is supplied, it is used as a separator between hexadecimal values. ubinascii.unhexlify(data) Convert hexadecimal data to binary representation. Returns bytes string. (i.e. inverse of hexlify) ubinascii.a2b_base64(data) Decode base64-encoded data, ignoring invalid characters in the input. Conforms to RFC 2045 s.6.8. Returns a bytes object. ubinascii.b2a_base64(data) Encode binary data in base64 format, as in RFC 3548. Returns the encoded data followed by a newline character, as a bytes object. powered by GitbookFile Modify: 2020-09-11 12:05:50 "},"libs/standard/ucollections.html":{"url":"libs/standard/ucollections.html","title":"ucollections","keywords":"","body":"ucollections – collection and container types This module implements a subset of the corresponding CPython module, as described below. For more information, refer to the original CPython documentation: collections. This module implements advanced collection and container types to hold/accumulate various objects. Classes ucollections.deque(iterable, maxlen[, flags]) Deques (double-ended queues) are a list-like container that support O(1) appends and pops from either side of the deque. New deques are created using the following arguments: iterable must be the empty tuple, and the new deque is created empty. maxlen must be specified and the deque will be bounded to this maximum length. Once the deque is full, any new items added will discard items from the opposite end. The optional flags can be 1 to check for overflow when adding items. As well as supporting bool and len, deque objects have the following methods: deque.append(x) Add x to the right side of the deque. Raises IndexError if overflow checking is enabled and there is no more room left. deque.popleft() Remove and return an item from the left side of the deque. Raises IndexError if no items are present. ucollections.namedtuple(name, fields) This is factory function to create a new namedtuple type with a specific name and set of fields. A namedtuple is a subclass of tuple which allows to access its fields not just by numeric index, but also with an attribute access syntax using symbolic field names. Fields is a sequence of strings specifying field names. For compatibility with CPython it can also be a a string with space-separated field named (but this is less efficient). Example of use: from ucollections import namedtuple MyTuple = namedtuple(\"MyTuple\", (\"id\", \"name\")) t1 = MyTuple(1, \"foo\") t2 = MyTuple(2, \"bar\") print(t1.name) assert t2.name == t2[1] ucollections.OrderedDict(...) dict type subclass which remembers and preserves the order of keys added. When ordered dict is iterated over, keys/items are returned in the order they were added: from ucollections import OrderedDict # To make benefit of ordered keys, OrderedDict should be initialized # from sequence of (key, value) pairs. d = OrderedDict([(\"z\", 1), (\"a\", 2)]) # More items can be added as usual d[\"w\"] = 5 d[\"b\"] = 3 for k, v in d.items(): print(k, v) Output: z 1 a 2 w 5 b 3 powered by GitbookFile Modify: 2020-09-11 12:05:50 "},"libs/standard/uctypes.html":{"url":"libs/standard/uctypes.html","title":"uctypes","keywords":"","body":"uctypes – access binary data in a structured way This module implements “foreign data interface” for MicroPython. The idea behind it is similar to CPython’s ctypes modules, but the actual API is different, streamlined and optimized for small size. The basic idea of the module is to define data structure layout with about the same power as the C language allows, and then access it using familiar dot-syntax to reference sub-fields. Warning uctypes module allows access to arbitrary memory addresses of the machine (including I/O and control registers). Uncareful usage of it may lead to crashes, data loss, and even hardware malfunction. See also Module ustruct Standard Python way to access binary data structures (doesn’t scale well to large and complex structures). Usage examples: import uctypes # Example 1: Subset of ELF file header # https://wikipedia.org/wiki/Executable_and_Linkable_Format#File_header ELF_HEADER = { \"EI_MAG\": (0x0 | uctypes.ARRAY, 4 | uctypes.UINT8), \"EI_DATA\": 0x5 | uctypes.UINT8, \"e_machine\": 0x12 | uctypes.UINT16, } # \"f\" is an ELF file opened in binary mode buf = f.read(uctypes.sizeof(ELF_HEADER, uctypes.LITTLE_ENDIAN)) header = uctypes.struct(uctypes.addressof(buf), ELF_HEADER, uctypes.LITTLE_ENDIAN) assert header.EI_MAG == b\"\\x7fELF\" assert header.EI_DATA == 1, \"Oops, wrong endianness. Could retry with uctypes.BIG_ENDIAN.\" print(\"machine:\", hex(header.e_machine)) # Example 2: In-memory data structure, with pointers COORD = { \"x\": 0 | uctypes.FLOAT32, \"y\": 4 | uctypes.FLOAT32, } STRUCT1 = { \"data1\": 0 | uctypes.UINT8, \"data2\": 4 | uctypes.UINT32, \"ptr\": (8 | uctypes.PTR, COORD), } # Suppose you have address of a structure of type STRUCT1 in \"addr\" # uctypes.NATIVE is optional (used by default) struct1 = uctypes.struct(addr, STRUCT1, uctypes.NATIVE) print(\"x:\", struct1.ptr[0].x) # Example 3: Access to CPU registers. Subset of STM32F4xx WWDG block WWDG_LAYOUT = { \"WWDG_CR\": (0, { # BFUINT32 here means size of the WWDG_CR register \"WDGA\": 7 Defining structure layout Structure layout is defined by a “descriptor” - a Python dictionary which encodes field names as keys and other properties required to access them as associated values: { \"field1\": , \"field2\": , ... } Currently, uctypes requires explicit specification of offsets for each field. Offset are given in bytes from the structure start. Following are encoding examples for various field types: Scalar types: \"field_name\": offset | uctypes.UINT32 in other words, the value is a scalar type identifier ORed with a field offset (in bytes) from the start of the structure. Recursive structures: \"sub\": (offset, { \"b0\": 0 | uctypes.UINT8, \"b1\": 1 | uctypes.UINT8, }) i.e. value is a 2-tuple, first element of which is an offset, and second is a structure descriptor dictionary (note: offsets in recursive descriptors are relative to the structure it defines). Of course, recursive structures can be specified not just by a literal dictionary, but by referring to a structure descriptor dictionary (defined earlier) by name. Arrays of primitive types: \"arr\": (offset | uctypes.ARRAY, size | uctypes.UINT8), i.e. value is a 2-tuple, first element of which is ARRAY flag ORed with offset, and second is scalar element type ORed number of elements in the array. Arrays of aggregate types: \"arr2\": (offset | uctypes.ARRAY, size, {\"b\": 0 | uctypes.UINT8}), i.e. value is a 3-tuple, first element of which is ARRAY flag ORed with offset, second is a number of elements in the array, and third is a descriptor of element type. Pointer to a primitive type: \"ptr\": (offset | uctypes.PTR, uctypes.UINT8), i.e. value is a 2-tuple, first element of which is PTR flag ORed with offset, and second is a scalar element type. Pointer to an aggregate type: \"ptr2\": (offset | uctypes.PTR, {\"b\": 0 | uctypes.UINT8}), i.e. value is a 2-tuple, first element of which is PTR flag ORed with offset, second is a descriptor of type pointed to. Bitfields: \"bitf0\": offset | uctypes.BFUINT16 | lsbit i.e. value is a type of scalar value containing given bitfield (typenames are similar to scalar types, but prefixes with BF), ORed with offset for scalar value containing the bitfield, and further ORed with values for bit position and bit length of the bitfield within the scalar value, shifted by BF_POS and BF_LEN bits, respectively. A bitfield position is counted from the least significant bit of the scalar (having position of 0), and is the number of right-most bit of a field (in other words, it’s a number of bits a scalar needs to be shifted right to extract the bitfield). In the example above, first a UINT16 value will be extracted at offset 0 (this detail may be important when accessing hardware registers, where particular access size and alignment are required), and then bitfield whose rightmost bit is lsbit bit of this UINT16, and length is bitsize bits, will be extracted. For example, if lsbit is 0 and bitsize is 8, then effectively it will access least-significant byte of UINT16. Note that bitfield operations are independent of target byte endianness, in particular, example above will access least-significant byte of UINT16 in both little- and big-endian structures. But it depends on the least significant bit being numbered 0. Some targets may use different numbering in their native ABI, but uctypes always uses the normalized numbering described above. Module contents class uctypes.struct(addr, descriptor, layout_type=NATIVE) Instantiate a “foreign data structure” object based on structure address in memory, descriptor (encoded as a dictionary), and layout type (see below). uctypes.LITTLE_ENDIAN Layout type for a little-endian packed structure. (Packed means that every field occupies exactly as many bytes as defined in the descriptor, i.e. the alignment is 1). uctypes.BIG_ENDIAN Layout type for a big-endian packed structure. uctypes.NATIVE Layout type for a native structure - with data endianness and alignment conforming to the ABI of the system on which MicroPython runs. uctypes.sizeof(struct, layout_type=NATIVE) Return size of data structure in bytes. The struct argument can be either a structure class or a specific instantiated structure object (or its aggregate field). uctypes.addressof(obj) Return address of an object. Argument should be bytes, bytearray or other object supporting buffer protocol (and address of this buffer is what actually returned). uctypes.bytes_at(addr, size) Capture memory at the given address and size as bytes object. As bytes object is immutable, memory is actually duplicated and copied into bytes object, so if memory contents change later, created object retains original value. uctypes.bytearray_at(addr, size) Capture memory at the given address and size as bytearray object. Unlike bytes_at() function above, memory is captured by reference, so it can be both written too, and you will access current value at the given memory address. uctypes.UINT8 uctypes.INT8 uctypes.UINT16 uctypes.INT16 uctypes.UINT32 uctypes.INT32 uctypes.UINT64 uctypes.INT64 Integer types for structure descriptors. Constants for 8, 16, 32, and 64 bit types are provided, both signed and unsigned. uctypes.FLOAT32 uctypes.FLOAT64 Floating-point types for structure descriptors. uctypes.VOID VOID is an alias for UINT8, and is provided to conviniently define C’s void pointers: (uctypes.PTR, uctypes.VOID). uctypes.PTR uctypes.ARRAY Type constants for pointers and arrays. Note that there is no explicit constant for structures, it’s implicit: an aggregate type without PTR or ARRAY flags is a structure. Structure descriptors and instantiating structure objects Given a structure descriptor dictionary and its layout type, you can instantiate a specific structure instance at a given memory address using uctypes.struct() constructor. Memory address usually comes from following sources: Predefined address, when accessing hardware registers on a baremetal system. Lookup these addresses in datasheet for a particular MCU/SoC. As a return value from a call to some FFI (Foreign Function Interface) function. From uctypes.addressof(), when you want to pass arguments to an FFI function, or alternatively, to access some data for I/O (for example, data read from a file or network socket). Structure objects Structure objects allow accessing individual fields using standard dot notation: my_struct.substruct1.field1. If a field is of scalar type, getting it will produce a primitive value (Python integer or float) corresponding to the value contained in a field. A scalar field can also be assigned to. If a field is an array, its individual elements can be accessed with the standard subscript operator [] - both read and assigned to. If a field is a pointer, it can be dereferenced using [0] syntax (corresponding to C * operator, though [0] works in C too). Subscripting a pointer with other integer values but 0 are also supported, with the same semantics as in C. Summing up, accessing structure fields generally follows the C syntax, except for pointer dereference, when you need to use [0] operator instead of *. Limitations Accessing non-scalar fields leads to allocation of intermediate objects to represent them. This means that special care should be taken to layout a structure which needs to be accessed when memory allocation is disabled (e.g. from an interrupt). The recommendations are: Avoid accessing nested structures. For example, instead of mcu_registers.peripheral_a.register1, define separate layout descriptors for each peripheral, to be accessed as peripheral_a.register1. Or just cache a particular peripheral: peripheral_a = mcu_registers.peripheral_a. If a register consists of multiple bitfields, you would need to cache references to a particular register: reg_a = mcu_registers.peripheral_a.reg_a. Avoid other non-scalar data, like arrays. For example, instead of peripheral_a.register[0] use peripheral_a.register0. Again, an alternative is to cache intermediate values, e.g. register0 = peripheral_a.register[0]. Range of offsets supported by the uctypes module is limited. The exact range supported is considered an implementation detail, and the general suggestion is to split structure definitions to cover from a few kilobytes to a few dozen of kilobytes maximum. In most cases, this is a natural situation anyway, e.g. it doesn’t make sense to define all registers of an MCU (spread over 32-bit address space) in one structure, but rather a peripheral block by peripheral block. In some extreme cases, you may need to split a structure in several parts artificially (e.g. if accessing native data structure with multi-megabyte array in the middle, though that would be a very synthetic case).) powered by GitbookFile Modify: 2020-09-11 12:05:50 "},"libs/standard/uerrno.html":{"url":"libs/standard/uerrno.html","title":"uerrno","keywords":"","body":"uerrno — system error codes This module implements a subset of the corresponding CPython module, as described below. For more information, refer to the original CPython documentation: errno. This module provides access to symbolic error codes for OSError exception. A particular inventory of codes depends on MicroPython port， Will explain the specific function that will cause an error. Constants EEXIST, EAGAIN, etc. Error codes, based on ANSI C/POSIX standard. All error codes start with “E”. As mentioned above, inventory of the codes depends on MicroPython port. Errors are usually accessible as exc.args[0] where exc is an instance of OSError. Usage example: try: uos.mkdir(\"my_dir\") except OSError as exc: if exc.args[0] == uerrno.EEXIST: print(\"Directory already exists\") uerrno.errorcode Dictionary mapping numeric error codes to strings with symbolic error code (see above): >>> print(uerrno.errorcode[uerrno.EEXIST]) EEXIST powered by GitbookFile Modify: 2020-09-11 12:05:50 "},"libs/standard/uhashlib.html":{"url":"libs/standard/uhashlib.html","title":"uhashlib","keywords":"","body":"uhashlib – hashing algorithms This module implements a subset of the corresponding CPython module, as described below. For more information, refer to the original CPython documentation: hashlib. This module implements binary data hashing algorithms. The exact inventory of available algorithms depends on a board. Among the algorithms which may be implemented: SHA256 - The current generation, modern hashing algorithm (of SHA2 series). It is suitable for cryptographically-secure purposes. Included in the MicroPython core and any board is recommended to provide this, unless it has particular code size constraints. Hardware accelerate is enabled on K210. Constructors class uhashlib.sha256([data]) Create an SHA256 hasher object and optionally feed data into it. Methods hash.update(data) Feed more binary data into hash. hash.digest() Return hash for all data passed through hash, as a bytes object. After this method is called, more data cannot be fed into the hash any longer. hash.hexdigest() This method is NOT implemented. Use ubinascii.hexlify(hash.digest()) to achieve a similar effect. powered by GitbookFile Modify: 2020-09-11 12:05:50 "},"libs/standard/uheapq.html":{"url":"libs/standard/uheapq.html","title":"uheapq","keywords":"","body":"uheapq – heap queue algorithm This module implements a subset of the corresponding CPython module, as described below. For more information, refer to the original CPython documentation: heapq. This module implements the heap queue algorithm. A heap queue is simply a list that has its elements stored in a certain way. Functions heappush uheapq.heappush(heap, item) Push the item onto the heap. heappop uheapq.heappop(heap) Pop the first item from the heap, and return it. Raises IndexError if heap is empty. heapify uheapq.heapify(x) Convert the list x into a heap. This is an in-place operation. powered by GitbookFile Modify: 2020-09-11 12:05:50 "},"libs/standard/ujson.html":{"url":"libs/standard/ujson.html","title":"ujson","keywords":"","body":"ujson – JSON encoding and decoding This module implements a subset of the corresponding CPython module, as described below. For more information, refer to the original CPython documentation: json. This modules allows to convert between Python objects and the JSON data format. Functions dump ujson.dump(obj, stream) Serialise obj to a JSON string, writing it to the given stream. dumps ujson.dumps(obj) Return obj represented as a JSON string. load ujson.load(stream) Parse the given stream, interpreting it as a JSON string and deserialising the data to a Python object. The resulting object is returned. Parsing continues until end-of-file is encountered. A ValueError is raised if the data in stream is not correctly formed. loads ujson.loads(str) Parse the JSON str and return an object. Raises ValueError if the string is not correctly formed. powered by GitbookFile Modify: 2020-09-11 12:05:50 "},"libs/standard/uos.html":{"url":"libs/standard/uos.html","title":"uos","keywords":"","body":"uos – basic “operating system” services This module implements a subset of the corresponding CPython module, as described below. For more information, refer to the original CPython documentation: os. The uos module contains functions for filesystem access and mounting, terminal redirection and duplication, and the uname and urandom functions. General functions uos.uname() Return a tuple (possibly a named tuple) containing information about the underlying machine and/or its operating system. The tuple has five fields in the following order, each of them being a string: sysname – the name of the underlying system nodename – the network name (can be the same as sysname) release – the version of the underlying system version – the MicroPython version and build date machine – an identifier for the underlying hardware (eg board, CPU) uos.urandom(n) Return a bytes object with n random bytes. Whenever possible, it is generated by the hardware random number generator. Filesystem access uos.chdir(path) Change current directory. uos.getcwd() Get the current directory. uos.ilistdir([dir]) This function returns an iterator which then yields tuples corresponding to the entries in the directory that it is listing. With no argument it lists the current directory, otherwise it lists the directory given by dir. The tuples have the form (name, type, inode[, size]): name is a string (or bytes if dir is a bytes object) and is the name of the entry; type is an integer that specifies the type of the entry, with 0x4000 for directories and 0x8000 for regular files; inode is an integer corresponding to the inode of the file, and may be 0 for filesystems that don’t have such a notion. Some platforms may return a 4-tuple that includes the entry’s size. For file entries, size is an integer representing the size of the file or -1 if unknown. Its meaning is currently undefined for directory entries. uos.listdir([dir]) With no argument, list the current directory. Otherwise list the given directory. uos.mkdir(path) Create a new directory. uos.remove(path) Remove a file. uos.rmdir(path) Remove a directory. uos.rename(old_path, new_path) Rename a file. uos.stat(path) Get the status of a file or directory. uos.statvfs(path) Get the status of a fileystem. Returns a tuple with the filesystem information in the following order: f_bsize – file system block size f_frsize – fragment size f_blocks – size of fs in f_frsize units f_bfree – number of free blocks f_bavail – number of free blocks for unpriviliged users f_files – number of inodes f_ffree – number of free inodes f_favail – number of free inodes for unpriviliged users f_flag – mount flags f_namemax – maximum filename length Parameters related to inodes: f_files, f_ffree, f_avail and the f_flags parameter may return 0 as they can be unavailable in a port-specific implementation. uos.sync() Sync all filesystems. Terminal redirection and duplication uos.dupterm(stream_object, index=0) Duplicate or switch the MicroPython terminal (the REPL) on the given stream-like object. The stream_object argument must implement the readinto() and write() methods. The stream should be in non-blocking mode and readinto() should return None if there is no data available for reading. After calling this function all terminal output is repeated on this stream, and any input that is available on the stream is passed on to the terminal input. The index parameter should be a non-negative integer and specifies which duplication slot is set. A given port may implement more than one slot (slot 0 will always be available) and in that case terminal input and output is duplicated on all the slots that are set. If None is passed as the stream_object then duplication is cancelled on the slot given by index. The function returns the previous stream-like object in the given slot. Filesystem mounting Some ports provide a Virtual Filesystem (VFS) and the ability to mount multiple “real” filesystems within this VFS. Filesystem objects can be mounted at either the root of the VFS, or at a subdirectory that lives in the root. This allows dynamic and flexible configuration of the filesystem that is seen by Python programs. Ports that have this functionality provide the mount() and umount() functions, and possibly various filesystem implementations represented by VFS classes. uos.mount(fsobj, mount_point, *, readonly) Mount the filesystem object fsobj at the location in the VFS given by the mount_point string. fsobj can be a a VFS object that has a mount() method, or a block device. If it’s a block device then the filesystem type is automatically detected (an exception is raised if no filesystem was recognised). mount_point may be '/' to mount fsobj at the root, or '/' to mount it at a subdirectory under the root. If readonly is True then the filesystem is mounted read-only. During the mount process the method mount() is called on the filesystem object. Will raise OSError(EPERM) if mount_point is already mounted. uos.umount(mount_point) Unmount a filesystem. mount_point can be a string naming the mount location, or a previously-mounted filesystem object. During the unmount process the method umount() is called on the filesystem object. Will raise OSError(EINVAL) if mount_point is not found. class uos.VfsFat(block_dev) Create a filesystem object that uses the FAT filesystem format. Storage of the FAT filesystem is provided by block_dev. Objects created by this constructor can be mounted using mount(). static mkfs(block_dev) Build a FAT filesystem on block_dev. Block devices A block device is an object which implements the block protocol, which is a set of methods described below by the AbstractBlockDev class. A concrete implementation of this class will usually allow access to the memory-like functionality a piece of hardware (like flash memory). A block device can be used by a particular filesystem driver to store the data for its filesystem. class uos.AbstractBlockDev(...) Construct a block device object. The parameters to the constructor are dependent on the specific block device. readblocks(block_num, buf) Starting at the block given by the index block_num, read blocks from the device into buf (an array of bytes). The number of blocks to read is given by the length of buf, which will be a multiple of the block size. writeblocks(block_num, buf) Starting at the block given by the index block_num, write blocks from buf (an array of bytes) to the device. The number of blocks to write is given by the length of buf, which will be a multiple of the block size. ioctl(op, arg) Control the block device and query its parameters. The operation to perform is given by op which is one of the following integers: 1 – initialise the device (arg is unused) 2 – shutdown the device (arg is unused) 3 – sync the device (arg is unused) 4 – get a count of the number of blocks, should return an integer (arg is unused) 5 – get the number of bytes in a block, should return an integer, or None in which case the default value of 512 is used (arg is unused) By way of example, the following class will implement a block device that stores its data in RAM using a bytearray: class RAMBlockDev: def __init__(self, block_size, num_blocks): self.block_size = block_size self.data = bytearray(block_size * num_blocks) def readblocks(self, block_num, buf): for i in range(len(buf)): buf[i] = self.data[block_num * self.block_size + i] def writeblocks(self, block_num, buf): for i in range(len(buf)): self.data[block_num * self.block_size + i] = buf[i] def ioctl(self, op, arg): if op == 4: # get number of blocks return len(self.data) // self.block_size if op == 5: # get block size return self.block_size It can be used as follows: import uos bdev = RAMBlockDev(512, 50) uos.VfsFat.mkfs(bdev) vfs = uos.VfsFat(bdev) uos.mount(vfs, '/ramdisk') powered by GitbookFile Modify: 2020-09-11 12:05:50 "},"libs/standard/ure.html":{"url":"libs/standard/ure.html","title":"ure","keywords":"","body":"ure – simple regular expressions This module implements a subset of the corresponding CPython module, as described below. For more information, refer to the original CPython documentation: re. This module implements regular expression operations. Regular expression syntax supported is a subset of CPython re module (and actually is a subset of POSIX extended regular expressions). Supported operators and special sequences . : Match any character. [...] : Match set of characters. Individual characters and ranges are supported, including negated sets (e.g. [^a-c]). ^ : Match the start of the string. $ : Match the end of the string. ? : Match zero or one of the previous sub-pattern. * : Match zero or more of the previous sub-pattern. + : Match one or more of the previous sub-pattern. ?? : Non-greedy version of ?, match zero or one, with the preference for zero. *? : Non-greedy version of *, match zero or more, with the preference for the shortest match. +? : Non-greedy version of +, match one or more, with the preference for the shortest match. | : Match either the left-hand side or the right-hand side sub-patterns of this operator. (...) : Grouping. Each group is capturing (a substring it captures can be accessed with match.group() method). \\d : Matches digit. Equivalent to [0-9]. \\D : Matches non-digit. Equivalent to [^0-9]. \\s : Matches whitespace. Equivalent to [ \\t-\\r]. \\S : Matches non-whitespace. Equivalent to [^ \\t-\\r]. \\w : Matches “word characters” (ASCII only). Equivalent to [A-Za-z0-9_]. \\W : Matches non “word characters” (ASCII only). Equivalent to [^A-Za-z0-9_]. \\ : Escape character. Any other character following the backslash, except for those listed above, is taken literally. For example, \\* is equivalent to literal * (not treated as the * operator). Note that \\r, \\n, etc. are not handled specially, and will be equivalent to literal letters r, n, etc. Due to this, it’s not recommended to use raw Python strings (r\"\") for regular expressions. For example, r\"\\r\\n\" when used as the regular expression is equivalent to \"rn\". To match CR character followed by LF, use \"\\r\\n\". NOT SUPPORTED: counted repetitions ({m,n}) named groups ((?P...)) non-capturing groups ((?:...)) more advanced assertions (\\b, \\B) special character escapes like \\r, \\n - use Python’s own escaping instead etc. Example: import ure # As ure doesn't support escapes itself, use of r\"\" strings is not # recommended. regex = ure.compile(\"[\\r\\n]\") regex.split(\"line1\\rline2\\nline3\\r\\n\") # Result: # ['line1', 'line2', 'line3', '', ''] Functions ure.compile(regex_str[, flags]) Compile regular expression, return regex object. ure.match(regex_str, string) Compile regex_str and match against string. Match always happens from starting position in a string. ure.search(regex_str, string) Compile regex_str and search it in a string. Unlike match, this will search string for first position which matches regex (which still may be 0 if regex is anchored). ure.sub(regex_str, replace, string, count=0, flags=0) Compile regex_str and search for it in string, replacing all matches with replace, and returning the new string. replace can be a string or a function. If it is a string then escape sequences of the form \\ and \\g can be used to expand to the corresponding group (or an empty string for unmatched groups). If replace is a function then it must take a single argument (the match) and should return a replacement string. If count is specified and non-zero then substitution will stop after this many substitutions are made. The flags argument is ignored. Note: availability of this function depends on MicroPython port. ure.DEBUG Flag value, display debug information about compiled expression. (Availability depends on MicroPython port.) Regex objects Compiled regular expression. Instances of this class are created using ure.compile(). regex.match(string) regex.search(string) regex.sub(replace, string, count=0, flags=0) Similar to the module-level functions match(), search() and sub(). Using methods is (much) more efficient if the same regex is applied to multiple strings. regex.split(string, max_split=-1) Split a string using regex. If max_split is given, it specifies maximum number of splits to perform. Returns list of strings (there may be up to max_split+1 elements if it’s specified). Match objects Match objects as returned by match() and search() methods, and passed to the replacement function in sub(). match.group(index) Return matching (sub)string. index is 0 for entire match, 1 and above for each capturing group. Only numeric groups are supported. match.groups() Return a tuple containing all the substrings of the groups of the match. Note: availability of this method depends on MicroPython port. match.start([index]) match.end([index]) Return the index in the original string of the start or end of the substring group that was matched. index defaults to the entire group, otherwise it will select a group. Note: availability of these methods depends on MicroPython port. match.span([index]) Returns the 2-tuple (match.start(index), match.end(index)). Note: availability of this method depends on MicroPython port. powered by GitbookFile Modify: 2020-09-11 12:05:50 "},"libs/standard/uselect.html":{"url":"libs/standard/uselect.html","title":"uselect","keywords":"","body":"powered by GitbookFile Modify: 2020-09-11 12:05:50 "},"libs/standard/usocket.html":{"url":"libs/standard/usocket.html","title":"usocket","keywords":"","body":"usocket – socket module This module implements a subset of the corresponding CPython module, as described below. For more information, refer to the original CPython documentation: socket. This module provides access to the BSD socket interface. Difference to CPython For efficiency and consistency, socket objects in MicroPython implement a stream (file-like) interface directly. In CPython, you need to convert a socket to a file-like object using makefile() method. This method is still supported by MicroPython (but is a no-op), so where compatibility with CPython matters, be sure to use it. Socket address format(s) The native socket address format of the usocket module is an opaque data type returned by getaddrinfo function, which must be used to resolve textual address (including numeric addresses): sockaddr = usocket.getaddrinfo('www.micropython.org', 80)[0][-1] # You must use getaddrinfo() even for numeric addresses sockaddr = usocket.getaddrinfo('127.0.0.1', 80)[0][-1] # Now you can use that address sock.connect(addr) Using getaddrinfo is the most efficient (both in terms of memory and processing power) and portable way to work with addresses. However, socket module (note the difference with native MicroPython usocket module described here) provides CPython-compatible way to specify addresses using tuples, as described below. Note that depending on a MicroPython port, socket module can be builtin or need to be installed from micropython-lib (as in the case of MicroPython Unix port), and some ports still accept only numeric addresses in the tuple format, and require to use getaddrinfo function to resolve domain names. Summing up: Always use getaddrinfo when writing portable applications. Tuple addresses described below can be used as a shortcut for quick hacks and interactive use, if your port supports them. Tuple address format for socket module: IPv4: (ipv4_address, port), where ipv4_address is a string with dot-notation numeric IPv4 address, e.g. \"8.8.8.8\", and port is and integer port number in the range 1-65535. Note the domain names are not accepted as ipv4_address, they should be resolved first using usocket.getaddrinfo(). IPv6: (ipv6_address, port, flowinfo, scopeid), where ipv6_address is a string with colon-notation numeric IPv6 address, e.g. \"2001:db8::1\", and port is an integer port number in the range 1-65535. flowinfo must be 0. scopeid is the interface scope identifier for link-local addresses. Note the domain names are not accepted as ipv6_address, they should be resolved first using usocket.getaddrinfo(). Availability of IPv6 support depends on a MicroPython port. Functions usocket.socket(af=AF_INET, type=SOCK_STREAM, proto=IPPROTO_TCP) Create a new socket using the given address family, socket type and protocol number. Note that specifying proto in most cases is not required (and not recommended, as some MicroPython ports may omit IPPROTO_* constants). Instead, type argument will select needed protocol automatically: # Create STREAM TCP socket socket(AF_INET, SOCK_STREAM) # Create DGRAM UDP socket socket(AF_INET, SOCK_DGRAM) usocket.getaddrinfo(host, port, af=0, type=0, proto=0, flags=0) Translate the host/port argument into a sequence of 5-tuples that contain all the necessary arguments for creating a socket connected to that service. Arguments af, type, and proto (which have the same meaning as for the socket() function) can be used to filter which kind of addresses are returned. If a parameter is not specified or zero, all combinations of addresses can be returned (requiring filtering on the user side). The resulting list of 5-tuples has the following structure: (family, type, proto, canonname, sockaddr) The following example shows how to connect to a given url: s = usocket.socket() # This assumes that if \"type\" is not specified, an address for # SOCK_STREAM will be returned, which may be not true s.connect(usocket.getaddrinfo('www.micropython.org', 80)[0][-1]) Recommended use of filtering params: s = usocket.socket() # Guaranteed to return an address which can be connect'ed to for # stream operation. s.connect(usocket.getaddrinfo('www.micropython.org', 80, 0, SOCK_STREAM)[0][-1]) Difference to CPython CPython raises a socket.gaierror exception (OSError subclass) in case of error in this function. MicroPython doesn’t have socket.gaierror and raises OSError directly. Note that error numbers of getaddrinfo() form a separate namespace and may not match error numbers from the uerrno module. To distinguish getaddrinfo() errors, they are represented by negative numbers, whereas standard system errors are positive numbers (error numbers are accessible using e.args[0] property from an exception object). The use of negative values is a provisional detail which may change in the future. usocket.inet_ntop(af, bin_addr) Convert a binary network address bin_addr of the given address family af to a textual representation: >>> usocket.inet_ntop(usocket.AF_INET, b\"\\x7f\\0\\0\\1\") '127.0.0.1' usocket.inet_pton(af, txt_addr) Convert a textual network address txt_addr of the given address family af to a binary representation: >>> usocket.inet_pton(usocket.AF_INET, \"1.2.3.4\") b'\\x01\\x02\\x03\\x04' Constants usocket.AF_INET usocket.AF_INET6 Address family types. Availability depends on a particular MicroPython port. usocket.SOCK_STREAM usocket.SOCK_DGRAM Socket types. usocket.IPPROTO_UDP usocket.IPPROTO_TCP IP protocol numbers. Availability depends on a particular MicroPython port. Note that you don’t need to specify these in a call to usocket.socket(), because SOCK_STREAM socket type automatically selects IPPROTO_TCP, and SOCK_DGRAM - IPPROTO_UDP. Thus, the only real use of these constants is as an argument to setsockopt(). usocket.SOL_* Socket option levels (an argument to setsockopt()). The exact inventory depends on a MicroPython port. usocket.SO_* Socket options (an argument to setsockopt()). The exact inventory depends on a MicroPython port. Constants specific to WiPy: usocket.IPPROTO_SEC Special protocol value to create SSL-compatible socket. class socket Methods socket.close() Mark the socket closed and release all resources. Once that happens, all future operations on the socket object will fail. The remote end will receive EOF indication if supported by protocol. Sockets are automatically closed when they are garbage-collected, but it is recommended to close() them explicitly as soon you finished working with them. socket.bind(address) Bind the socket to address. The socket must not already be bound. socket.listen([backlog]) Enable a server to accept connections. If backlog is specified, it must be at least 0 (if it’s lower, it will be set to 0); and specifies the number of unaccepted connections that the system will allow before refusing new connections. If not specified, a default reasonable value is chosen. socket.accept() Accept a connection. The socket must be bound to an address and listening for connections. The return value is a pair (conn, address) where conn is a new socket object usable to send and receive data on the connection, and address is the address bound to the socket on the other end of the connection. socket.connect(address) Connect to a remote socket at address. socket.send(bytes) Send data to the socket. The socket must be connected to a remote socket. Returns number of bytes sent, which may be smaller than the length of data (“short write”). socket.sendall(bytes) Send all data to the socket. The socket must be connected to a remote socket. Unlike send(), this method will try to send all of data, by sending data chunk by chunk consecutively. The behavior of this method on non-blocking sockets is undefined. Due to this, on MicroPython, it’s recommended to use write() method instead, which has the same “no short writes” policy for blocking sockets, and will return number of bytes sent on non-blocking sockets. socket.recv(bufsize) Receive data from the socket. The return value is a bytes object representing the data received. The maximum amount of data to be received at once is specified by bufsize. socket.sendto(bytes, address) Send data to the socket. The socket should not be connected to a remote socket, since the destination socket is specified by address. socket.recvfrom(bufsize) Receive data from the socket. The return value is a pair (bytes, address) where bytes is a bytes object representing the data received and address is the address of the socket sending the data. socket.setsockopt(level, optname, value) Set the value of the given socket option. The needed symbolic constants are defined in the socket module (SO_* etc.). The value can be an integer or a bytes-like object representing a buffer. socket.settimeout(value) Note: Not every port supports this method, see below. Set a timeout on blocking socket operations. The value argument can be a nonnegative floating point number expressing seconds, or None. If a non-zero value is given, subsequent socket operations will raise an OSError exception if the timeout period value has elapsed before the operation has completed. If zero is given, the socket is put in non-blocking mode. If None is given, the socket is put in blocking mode. Not every MicroPython port supports this method. A more portable and generic solution is to use uselect.poll object. This allows to wait on multiple objects at the same time (and not just on sockets, but on generic stream objects which support polling). Example: # Instead of: s.settimeout(1.0) # time in seconds s.read(10) # may timeout # Use: poller = uselect.poll() poller.register(s, uselect.POLLIN) res = poller.poll(1000) # time in milliseconds if not res: # s is still not ready for input, i.e. operation timed out Difference to CPython CPython raises a socket.timeout exception in case of timeout, which is an OSError subclass. MicroPython raises an OSError directly instead. If you use except OSError: to catch the exception, your code will work both in MicroPython and CPython. socket.setblocking(flag) Set blocking or non-blocking mode of the socket: if flag is false, the socket is set to non-blocking, else to blocking mode. This method is a shorthand for certain settimeout() calls: sock.setblocking(True) is equivalent to sock.settimeout(None) sock.setblocking(False) is equivalent to sock.settimeout(0) socket.makefile(mode='rb', buffering=0) Return a file object associated with the socket. The exact returned type depends on the arguments given to makefile(). The support is limited to binary modes only (‘rb’, ‘wb’, and ‘rwb’). CPython’s arguments: encoding, errors and newline are not supported. Difference to CPython As MicroPython doesn’t support buffered streams, values of buffering parameter is ignored and treated as if it was 0 (unbuffered). Difference to CPython Closing the file object returned by makefile() WILL close the original socket as well. socket.read([size]) Read up to size bytes from the socket. Return a bytes object. If size is not given, it reads all data available from the socket until EOF; as such the method will not return until the socket is closed. This function tries to read as much data as requested (no “short reads”). This may be not possible with non-blocking socket though, and then less data will be returned. socket.readinto(buf[, nbytes]) Read bytes into the buf. If nbytes is specified then read at most that many bytes. Otherwise, read at most len(buf) bytes. Just as read(), this method follows “no short reads” policy. Return value: number of bytes read and stored into buf. socket.readline() Read a line, ending in a newline character. Return value: the line read. socket.write(buf) Write the buffer of bytes to the socket. This function will try to write all data to a socket (no “short writes”). This may be not possible with a non-blocking socket though, and returned value will be less than the length of buf. Return value: number of bytes written. exception usocket.error MicroPython does NOT have this exception. Difference to CPython CPython used to have a socket.error exception which is now deprecated, and is an alias of OSError. In MicroPython, use OSError directly. Demo Demo 1: Download picture and display on LCD attention set WiFi SSID and password first in code import socket import network import gc import os import lcd, image fm.register(board_info.WIFI_RX,fm.fpioa.UART2_TX) fm.register(board_info.WIFI_TX,fm.fpioa.UART2_RX) uart = machine.UART(machine.UART.UART2,115200,timeout=1000, read_buf_len=4096) nic=network.ESP8285(uart) nic.connect(\"Sipeed_2.4G\",\"------\") sock = socket.socket() addr = socket.getaddrinfo(\"dl.sipeed.com\", 80)[0][-1] sock.connect(addr) sock.send('''GET /MAIX/MaixPy/assets/Alice.bmp HTTP/1.1 Host: dl.sipeed.com cache-control: no-cache ''') img = b\"\" sock.settimeout(5) while True: data = sock.recv(4096) if len(data) == 0: break print(\"rcv:\", len(data)) img = img + data print(len(img)) img = img[img.find(b\"\\r\\n\\r\\n\")+4:] print(len(img)) print(\"save to /sd/Alice.bmp\") f = open(\"/sd/Alice.bmp\",\"wb\") f.write(img) f.close() print(\"save ok\") print(\"display\") img = image.Image(\"/sd/Alice.bmp\") lcd.init() lcd.display(img) Demo 2: Send picture import os import socket import network import gc fm.register(board_info.WIFI_RX,fm.fpioa.UART2_TX) fm.register(board_info.WIFI_TX,fm.fpioa.UART2_RX) uart = machine.UART(machine.UART.UART2,115200,timeout=1000, read_buf_len=4096) nic=network.ESP8285(uart) nic.connect(\"Sipeed_2.4G\",\"-------\") addr = (\"192.168.0.183\", 3456) sock = socket.socket() sock.connect(addr) sock.settimeout(5) f = open(\"/sd/Alice.bmp\",\"rb\") while True: img = f.read(2048) if not img or (len(img) == 0): break sock.send(img) f.close() sock.close() powered by GitbookFile Modify: 2020-09-11 12:05:50 "},"libs/standard/ustruct.html":{"url":"libs/standard/ustruct.html","title":"ustruct","keywords":"","body":"ustruct – pack and unpack primitive data types This module implements a subset of the corresponding CPython module, as described below. For more information, refer to the original CPython documentation: struct. Supported size/byte order prefixes: @, , >, !. Supported format codes: b, B, h, H, i, I, l, L, q, Q, s, P, f, d (the latter 2 depending on the floating-point support). Functions calcsize ustruct.calcsize(fmt) Return the number of bytes needed to store the given fmt. pack ustruct.pack(fmt, v1, v2, ...) Pack the values v1, v2, … according to the format string fmt. The return value is a bytes object encoding the values. pack_into ustruct.pack_into(fmt, buffer, offset, v1, v2, ...) Pack the values v1, v2, … according to the format string fmt into a buffer starting at offset. offset may be negative to count from the end of buffer. unpack ustruct.unpack(fmt, data) Unpack from the data according to the format string fmt. The return value is a tuple of the unpacked values. unpack_from ustruct.unpack_from(fmt, data, offset=0) Unpack from the data starting at offset according to the format string fmt. offset may be negative to count from the end of buffer. The return value is a tuple of the unpacked values. powered by GitbookFile Modify: 2020-09-11 12:05:50 "},"libs/standard/utime.html":{"url":"libs/standard/utime.html","title":"utime","keywords":"","body":"utime – time related functions This module implements a subset of the corresponding CPython module, as described below. For more information, refer to the original CPython documentation: time. The utime module provides functions for getting the current time and date, measuring time intervals, and for delays. Time Epoch: Unix port uses standard for POSIX systems epoch of 1970-01-01 00:00:00 UTC. However, embedded ports use epoch of 2000-01-01 00:00:00 UTC. Maintaining actual calendar date/time: This requires a Real Time Clock (RTC). On systems with underlying OS (including some RTOS), an RTC may be implicit. Setting and maintaining actual calendar time is responsibility of OS/RTOS and is done outside of MicroPython, it just uses OS API to query date/time. On baremetal ports however system time depends on machine.RTC() object. The current calendar time may be set using machine.RTC().datetime(tuple) function, and maintained by following means: By a backup battery (which may be an additional, optional component for a particular board). Using networked time protocol (requires setup by a port/user). Set manually by a user on each power-up (many boards then maintain RTC time across hard resets, though some may require setting it again in such case). If actual calendar time is not maintained with a system/MicroPython RTC, functions below which require reference to current absolute time may behave not as expected. Functions utime.localtime([secs]) Convert a time expressed in seconds since the Epoch (see above) into an 8-tuple which contains: (year, month, mday, hour, minute, second, weekday, yearday) If secs is not provided or None, then the current time from the RTC is used. year includes the century (for example 2014). month is 1-12 mday is 1-31 hour is 0-23 minute is 0-59 second is 0-59 weekday is 0-6 for Mon-Sun yearday is 1-366 utime.mktime() This is inverse function of localtime. It’s argument is a full 8-tuple which expresses a time as per localtime. It returns an integer which is the number of seconds since Jan 1, 2000. utime.sleep(seconds) Sleep for the given number of seconds. Some boards may accept seconds as a floating-point number to sleep for a fractional number of seconds. Note that other boards may not accept a floating-point argument, for compatibility with them use sleep_ms() and sleep_us() functions. utime.sleep_ms(ms) Delay for given number of milliseconds, should be positive or 0. utime.sleep_us(us) Delay for given number of microseconds, should be positive or 0. utime.ticks_ms() Returns an increasing millisecond counter with an arbitrary reference point, that wraps around after some value. The wrap-around value is not explicitly exposed, but we will refer to it as TICKS_MAX to simplify discussion. Period of the values is TICKS_PERIOD = TICKS_MAX + 1. TICKS_PERIOD is guaranteed to be a power of two, but otherwise may differ from port to port. The same period value is used for all of ticks_ms(), ticks_us(), ticks_cpu() functions (for simplicity). Thus, these functions will return a value in range [0 .. TICKS_MAX], inclusive, total TICKS_PERIOD values. Note that only non-negative values are used. For the most part, you should treat values returned by these functions as opaque. The only operations available for them are ticks_diff() and ticks_add() functions described below. Note: Performing standard mathematical operations (+, -) or relational operators (, >=) directly on these value will lead to invalid result. Performing mathematical operations and then passing their results as arguments to ticks_diff() or ticks_add() will also lead to invalid results from the latter functions. utime.ticks_us() Just like ticks_ms() above, but in microseconds. utime.ticks_cpu() Similar to ticks_ms() and ticks_us(), but with the highest possible resolution in the system. This is usually CPU clocks, and that’s why the function is named that way. But it doesn’t have to be a CPU clock, some other timing source available in a system (e.g. high-resolution timer) can be used instead. The exact timing unit (resolution) of this function is not specified on utime module level, but documentation for a specific port may provide more specific information. This function is intended for very fine benchmarking or very tight real-time loops. Avoid using it in portable code. Availability: Not every port implements this function. utime.ticks_add(ticks, delta) Offset ticks value by a given number, which can be either positive or negative. Given a ticks value, this function allows to calculate ticks value delta ticks before or after it, following modular-arithmetic definition of tick values (see ticks_ms() above). ticks parameter must be a direct result of call to ticks_ms(), ticks_us(), or ticks_cpu() functions (or from previous call to ticks_add()). However, delta can be an arbitrary integer number or numeric expression. ticks_add() is useful for calculating deadlines for events/tasks. (Note: you must use ticks_diff() function to work with deadlines.) Examples: # Find out what ticks value there was 100ms ago print(ticks_add(time.ticks_ms(), -100)) # Calculate deadline for operation and test for it deadline = ticks_add(time.ticks_ms(), 200) while ticks_diff(deadline, time.ticks_ms()) > 0: do_a_little_of_something() # Find out TICKS_MAX used by this port print(ticks_add(0, -1)) utime.ticks_diff(ticks1, ticks2) Measure ticks difference between values returned from ticks_ms(), ticks_us(), or ticks_cpu() functions, as a signed value which may wrap around. The argument order is the same as for subtraction operator, ticks_diff(ticks1, ticks2) has the same meaning as ticks1 - ticks2. However, values returned by ticks_ms(), etc. functions may wrap around, so directly using subtraction on them will produce incorrect result. That is why ticks_diff() is needed, it implements modular (or more specifically, ring) arithmetics to produce correct result even for wrap-around values (as long as they not too distant inbetween, see below). The function returns signed value in the range [-TICKS_PERIOD/2 .. TICKS_PERIOD/2-1] (that’s a typical range definition for two’s-complement signed binary integers). If the result is negative, it means that ticks1 occurred earlier in time than ticks2. Otherwise, it means that ticks1 occurred after ticks2. This holds only if ticks1 and ticks2 are apart from each other for no more than TICKS_PERIOD/2-1 ticks. If that does not hold, incorrect result will be returned. Specifically, if two tick values are apart for TICKS_PERIOD/2-1 ticks, that value will be returned by the function. However, if TICKS_PERIOD/2 of real-time ticks has passed between them, the function will return -TICKS_PERIOD/2 instead, i.e. result value will wrap around to the negative range of possible values. Informal rationale of the constraints above: Suppose you are locked in a room with no means to monitor passing of time except a standard 12-notch clock. Then if you look at dial-plate now, and don’t look again for another 13 hours (e.g., if you fall for a long sleep), then once you finally look again, it may seem to you that only 1 hour has passed. To avoid this mistake, just look at the clock regularly. Your application should do the same. “Too long sleep” metaphor also maps directly to application behavior: don’t let your application run any single task for too long. Run tasks in steps, and do time-keeping inbetween. ticks_diff() is designed to accommodate various usage patterns, among them: Polling with timeout. In this case, the order of events is known, and you will deal only with positive results of ticks_diff(): # Wait for GPIO pin to be asserted, but at most 500us start = time.ticks_us() while pin.value() == 0: if time.ticks_diff(time.ticks_us(), start) > 500: raise TimeoutError Scheduling events. In this case, ticks_diff() result may be negative if an event is overdue: # This code snippet is not optimized now = time.ticks_ms() scheduled_time = task.scheduled_time() if ticks_diff(scheduled_time, now) > 0: print(\"Too early, let's nap\") sleep_ms(ticks_diff(scheduled_time, now)) task.run() elif ticks_diff(scheduled_time, now) == 0: print(\"Right at time!\") task.run() elif ticks_diff(scheduled_time, now) Note: Do not pass time() values to ticks_diff(), you should use normal mathematical operations on them. But note that time() may (and will) also overflow. This is known as https://en.wikipedia.org/wiki/Year_2038_problem . utime.time() Returns the number of seconds, as an integer, since the Epoch, assuming that underlying RTC is set and maintained as described above. If an RTC is not set, this function returns number of seconds since a port-specific reference point in time (for embedded boards without a battery-backed RTC, usually since power up or reset). If you want to develop portable MicroPython application, you should not rely on this function to provide higher than second precision. If you need higher precision, use ticks_ms() and ticks_us()functions, if you need calendar time, localtime() without an argument is a better choice. Difference to CPython In CPython, this function returns number of seconds since Unix epoch, 1970-01-01 00:00 UTC, as a floating-point, usually having microsecond precision. With MicroPython, only Unix port uses the same Epoch, and if floating-point precision allows, returns sub-second precision. Embedded hardware usually doesn’t have floating-point precision to represent both long time ranges and subsecond precision, so they use integer value with second precision. Some embedded hardware also lacks battery-powered RTC, so returns number of seconds since last power-up or from other relative, hardware-specific point (e.g. reset). powered by GitbookFile Modify: 2020-09-11 12:05:50 "},"libs/standard/uzlib.html":{"url":"libs/standard/uzlib.html","title":"uzlib","keywords":"","body":"zlib — zlib decompression This module implements a subset of the corresponding CPython module, as described below. For more information, refer to the original CPython documentation: zlib. This module allows to decompress binary data compressed with DEFLATE algorithm (commonly used in zlib library and gzip archiver). Compression is not yet implemented. Functions decompress uzlib.decompress(data, wbits=0, bufsize=0) Return decompressed data as bytes. wbits is DEFLATE dictionary window size used during compression (8-15, the dictionary size is power of 2 of that value). Additionally, if value is positive, data is assumed to be zlib stream (with zlib header). Otherwise, if it’s negative, it’s assumed to be raw DEFLATE stream. bufsize parameter is for compatibility with CPython and is ignored. DecompIO class uzlib.DecompIO(stream, wbits=0) Create a stream wrapper which allows transparent decompression of compressed data in another stream. This allows to process compressed streams with data larger than available heap size. In addition to values described in decompress(), wbits may take values 24..31 (16 + 8..15), meaning that input stream has gzip header. Difference to CPython This class is MicroPython extension. It’s included on provisional basis and may be changed considerably or removed in later versions. powered by GitbookFile Modify: 2020-09-11 12:05:50 "},"libs/machine/":{"url":"libs/machine/","title":"machine","keywords":"","body":"machine I2C SPI Timer PWM UART Function unique_id() Get unique ID Return value 32 bytes unique ID Function reset() reset (reboot) powered by GitbookFile Modify: 2020-09-11 12:05:50 "},"libs/machine/i2c.html":{"url":"libs/machine/i2c.html","title":"I2C","keywords":"","body":"machine.I2C I2C bus protocol, simply using two lines (SCL, SDA) can control multiple slaves (master mode). Supports master mode and slave mode 7-bit / 10-bit addressing mode Standard mode Fast mode Super fast mode High-speed mode 3.4Mb / s Constructor class machine.I2C (id, mode = I2C.MODE_MASTER, scl = None, sda = None, freq = 400000, timeout = 1000, addr = 0, addr_size = 7, on_recieve = None, on_transmit = None, on_event = None) Create a new I2C object with the specified parameters Parameters id: I2C ID, [0 ~ 2] \\ (I2C.I2C0 ~ I2C.I2C2 ) mode: mode, master (I2C.MODE_MASTER) and slave (I2C.MODE_SLAVE) mode scl: SCL pin, just pass the pin number directly, value range: [0,47]. Instead of setting it, use [fm] (../ builtin_py / fm.md) to manage the pin mapping uniformly. sda: SDA pin, just pass the pin number directly, value range: [0,47]. Instead of setting it, use [fm] (../ builtin_py / fm.md) to manage the pin mapping uniformly. freq: I2C communication frequency, support standard 100Kb / s, fast 400Kb / s, and higher speed (hardware supports super fast mode 1000Kb / s, and high-speed mode 3.4Mb / s) timeout: timeout time, currently this parameter is reserved, setting is invalid addr: slave address, if it is in master mode, it is not necessary to set, slave mode represents slave (local) address addr_size: address length, support 7-bit addressing and 10-bit addressing, value7 or 10 on_recieve: Receive callback function in slave mode on_transmit: Send callback function in slave mode on_event: Slave mode event function (start event and end event) Method init Constructor-like I2C.init (id, mode = Timer.MODE_MASTER, scl, sda, freq = 400000, timeout = 1000, addr = 0, addr_size = 7, on_recieve = None, on_transmit = None, on_event = None) parameters Same as constructor return value no scan Scanning slaves on the I2C bus I2C.scan () parameters no return value list object containing all scanned slave addresses readfrom Read data from the bus I2C.readfrom (addr, len, stop = True) parameters addr: slave address len: data length stop: Whether to generate a stop signal. Reserved. Currently, only the default value True can be used. return value Read data, type bytes readfrom_into Read the data and put it into the specified variable I2C.readfrom_into (addr, buf, stop = True) parameters addr: slave address buf:bytearray type, which defines the length, and the read data is stored here stop: Whether to generate a stop signal. Reserved. Currently, only the default value True can be used. return value no writeto Send data to the slave I2C.writeto (addr, buf, stop = True) parameters addr: slave address buf: data to be sent stop: Whether to generate a stop signal. Reserved. Currently, only the default value True can be used. return value Number of bytes successfully sent readfrom_mem Read slave register I2C.readfrom_mem (addr, memaddr, nbytes, mem_size = 8) parameters addr: slave address memaddr: slave register address nbytes: the length to read mem_size: register width, default is 8 bits return value Returns read data of type bytes readfrom_mem_into Read the slave register value into the specified variable I2C.readfrom_mem_into (addr, memaddr, buf, mem_size = 8) parameters addr: slave address memaddr: slave register address buf:bytearray type, which defines the length, and the read data is stored here mem_size: register width, default is 8 bits return value no writeto_mem Write data to slave register I2C.writeto_mem (addr, memaddr, buf, mem_size = 8) parameters addr: slave address memaddr: slave register address buf: data to be written mem_size: register width, default is 8 bits return value no deinit / \\ del \\ Log off the I2C hardware, release the occupied resources, and shut down the I2C clock I2C.deinit () parameters no return value no Examples i2c.deinit () or del i2c Constants I2C0: I2C 0 I2C1: I2C 1 I2C2: I2C 2 MODE_MASTER: as master mode MODE_SLAVE: as slave mode I2C_EV_START: event type, start signal I2C_EV_RESTART: event type, restart signal I2C_EV_STOP: event type, end signal Examples Routine 1: Scanning for Slave Devices from machine import I2C i2c = I2C (I2C.I2C0, freq = 100000, scl = 28, sda = 29) devices = i2c.scan () print (devices) Example 2: Read and write import time from machine import I2C i2c = I2C (I2C.I2C0, freq = 100000, scl = 28, sda = 29) i2c.writeto (0x24, b'123 ') i2c.readfrom (0x24,5) Example 3: Slave mode from machine import I2C count = 0 def on_receive (data): print (\"on_receive:\", data) def on_transmit (): count = count + 1 print (\"on_transmit, send:\", count) return count def on_event (event): print (\"on_event:\", event) i2c = I2C (I2C.I2C0, mode = I2C.MODE_SLAVE, scl = 28, sda = 29, addr = 0x24, addr_size = 7, on_receive = on_receive, on_transmit = on_transmit, on_event = on_event) Example 4: OLED (ssd1306 128x64) import time from machine import I2C SSD1306_CMD = 0 SSD1306_DATA = 1 SSD1306_ADDR = 0x3c def oled_init (i2c): i2c.writeto_mem (SSD1306_ADDR, 0x00, 0xAE, mem_size = 8) i2c.writeto_mem (SSD1306_ADDR, 0x00, 0x20, mem_size = 8) i2c.writeto_mem (SSD1306_ADDR, 0x00, 0x10, mem_size = 8) i2c.writeto_mem (SSD1306_ADDR, 0x00, 0xb0, mem_size = 8) i2c.writeto_mem (SSD1306_ADDR, 0x00, 0xc8, mem_size = 8) i2c.writeto_mem (SSD1306_ADDR, 0x00, 0x00, mem_size = 8) i2c.writeto_mem (SSD1306_ADDR, 0x00, 0x10, mem_size = 8) i2c.writeto_mem (SSD1306_ADDR, 0x00, 0x40, mem_size = 8) i2c.writeto_mem (SSD1306_ADDR, 0x00, 0x81, mem_size = 8) i2c.writeto_mem (SSD1306_ADDR, 0x00, 0xff, mem_size = 8) i2c.writeto_mem (SSD1306_ADDR, 0x00, 0xa1, mem_size = 8) i2c.writeto_mem (SSD1306_ADDR, 0x00, 0xa6, mem_size = 8) i2c.writeto_mem (SSD1306_ADDR, 0x00, 0xa8, mem_size = 8) i2c.writeto_mem (SSD1306_ADDR, 0x00, 0x3F, mem_size = 8) i2c.writeto_mem (SSD1306_ADDR, 0x00, 0xa4, mem_size = 8) i2c.writeto_mem (SSD1306_ADDR, 0x00, 0xd3, mem_size = 8) i2c.writeto_mem (SSD1306_ADDR, 0x00, 0x00, mem_size = 8) i2c.writeto_mem (SSD1306_ADDR, 0x00, 0xd5, mem_size = 8) i2c.writeto_mem (SSD1306_ADDR, 0x00, 0xf0, mem_size = 8) i2c.writeto_mem (SSD1306_ADDR, 0x00, 0xd9, mem_size = 8) i2c.writeto_mem (SSD1306_ADDR, 0x00, 0x22, mem_size = 8) i2c.writeto_mem (SSD1306_ADDR, 0x00, 0xda, mem_size = 8) i2c.writeto_mem (SSD1306_ADDR, 0x00, 0x12, mem_size = 8) i2c.writeto_mem (SSD1306_ADDR, 0x00, 0xdb, mem_size = 8) i2c.writeto_mem (SSD1306_ADDR, 0x00, 0x20, mem_size = 8) i2c.writeto_mem (SSD1306_ADDR, 0x00, 0x8d, mem_size = 8) i2c.writeto_mem (SSD1306_ADDR, 0x00, 0x14, mem_size = 8) i2c.writeto_mem (SSD1306_ADDR, 0x00, 0xaf, mem_size = 8) def oled_on (i2c): i2c.writeto_mem (SSD1306_ADDR, 0x00, 0X8D, mem_size = 8) i2c.writeto_mem (SSD1306_ADDR, 0x00, 0X14, mem_size = 8) i2c.writeto_mem (SSD1306_ADDR, 0x00, 0XAF, mem_size = 8) def oled_off (i2c): i2c.writeto_mem (SSD1306_ADDR, 0x00, 0X8D, mem_size = 8) i2c.writeto_mem (SSD1306_ADDR, 0x00, 0X10, mem_size = 8) i2c.writeto_mem (SSD1306_ADDR, 0x00, 0XAE, mem_size = 8) def oled_fill (i2c, data): for i in range (0,8): i2c.writeto_mem (SSD1306_ADDR, 0x00, 0xb0 + i, mem_size = 8) i2c.writeto_mem (SSD1306_ADDR, 0x00, 0x10, mem_size = 8) i2c.writeto_mem (SSD1306_ADDR, 0x00, 0x01, mem_size = 8) for j in range (0,128): i2c.writeto_mem (SSD1306_ADDR, 0x40, data, mem_size = 8) i2c = I2C (I2C.I2C0, mode = I2C.MODE_MASTER, freq = 400000, scl = 28, sda = 29, addr_size = 7) time.sleep (1) oled_init (i2c) oled_fill (i2c, 0xff) powered by GitbookFile Modify: 2020-09-11 12:05:50 "},"libs/machine/pwm.html":{"url":"libs/machine/pwm.html","title":"PWM","keywords":"","body":"machine.PWM PWM: Pulse width modulation module, hardware-supported PWM, can specify any pin (0 to 47 pins) Each PWM depends on a timer, that is, when the timer is bound to the PWM function, it cannot be used as an ordinary timer. Because there are 3 timers and each timer has 4 channels, that is, a maximum of 12 PWM waveforms can be generated at the same time. Constructor `python class machine.PWM (tim, freq, duty, pin, enable = True) ` Create a new PWM object with the specified parameters Parameters tim: Each PWM relies on a timer to generate a waveform, so a timer object needs to be passed here. The timer ID and channel number must be specified when the timer object is initialized. freq: PWM waveform frequency duty: PWM duty cycle, refers to the percentage of high level in the entire cycle, value: [0,100] [pin]: PWM output pin. Instead of setting it, use [fm] (../ builtin_py / fm.md) to manage the pin mapping uniformly. enable: Whether to start generating the waveform immediately, the default bitTrue, and to start generating the PWM waveform on the specified pin immediately after the object is generated Method init Constructor-like `python PWM.init (tim, freq, duty, pin, enable = True) ` parameters Same as constructor return value no freq Get or set the PWM frequency `python PWM.freq (freq) ` parameters freq: PWM frequency, optional parameter, if no parameter is passed, the step setting only returns the current frequency value return value Actual PWM frequency currently set duty Gets or sets the PWM duty cycle `python PWM.duty (duty) ` parameters duty: PWM duty cycle is optional. If no parameter is passed, the step setting only returns the current duty cycle value. return value PWM duty cycle value currently set enable Enable PWM output to generate waveform immediately on specified pin `python PWM.enable () ` parameters no return value no disable Disable PWM output, no longer generate waveforms at specified pins `python PWM.disable () ` parameters no return value no deinit / \\ del \\ Unregister the PWM hardware, release the occupied resources, and shut down the PWM clock `python PWM.deinit () ` parameters no return value no Examples `python pwm.deinit () or `` python del pwm ` Constants no Examples Routine 1 (breathing light) ` python from machine import Timer, PWM import time from fpioa_manager import board_info tim = Timer (Timer.TIMER0, Timer.CHANNEL0, mode = Timer.MODE_PWM) ch = PWM (tim, freq = 500000, duty = 50, pin = board_info.LED_G) duty = 0 dir = True while True: if dir: duty + = 10 else: duty-= 10 if duty> 100: duty = 100 dir = False elif duty ` Routine 2 ` python import time import machine from fpioa_manager import board_info tim = machine.Timer (machine.Timer.TIMER0, machine.Timer.CHANNEL0, mode = machine.Timer.MODE_PWM) ch0 = machine.PWM (tim, freq = 3000000, duty = 20, pin = board_info.LED_G, enable = False) ch0.enable () time.sleep (3) ch0.freq (2000000) print (\"freq:\", ch0.freq ()) ch0.duty (60) time.sleep (3) ch0.disable () ` powered by GitbookFile Modify: 2020-09-11 12:05:50 "},"libs/machine/spi.html":{"url":"libs/machine/spi.html","title":"SPI","keywords":"","body":"machine.SPI SPI (Serial Peripheral Interface) is a synchronous serial protocol consisting of a master and a slave. The standard 4-wire mode consists of 4 wires: SCK (SCLK), CS (chip select), MOSI, MISO. On the K210, SPI has the following characteristics: There are 4 SPI devices, of which SPI0, SPI1, and SPI3 can only work in master mode, and SPI2 can only work in slave mode. On MaixPy, SPI3 has been used to connect SPI Flash. It is temporarily reserved. It is necessary to consider the open interface and SPI Flash time-sharing multiplexing. Supports 1/2/4 / 8-wire full-duplex mode. In MaixPy, currently only supports standard (Motorola) 4-wire full-duplex mode (ie, SCK, MOSI, MISO, CS four pins) Maximum transmission rate of 45M Support DMA 4 configurable hardware chip select Constructor class machine.SPI (id, mode = SPI.MODE_MASTER, baudrate = 500000, polarity = 0, phase = 0, bits = 8, firstbit = SPI.MSB, sck, mosi, miso, cs0, cs1, cs2, cs3) Create a new SPI object with the specified parameters Parameters id: SPI ID, value range [0,3], currently only supports 0 and 1, and can only be master mode, 2 can only be used as slave, currently not implemented, 3 reserved mode: SPI mode,MODE_MASTER or MODE_MASTER_2 orMODE_MASTER_4 or MODE_MASTER_8 orMODE_SLAVE, currently only supports MODE_MASTER baudrate: SPI baud rate (frequency) polarity: Polarity, the value is 0 or 1, which indicates the polarity of the SPI at idle, 0 represents low level, 1 represents high level phase: phase, value bit 0 or 1, which means to collect data at the first or second edge of the clock, 0 means the first, 1 means the second bits: data width, default value is 8, value range [4,32] firstbit: Specify whether to transmit in MSB or LSB order. The default is SPI.MSB. sck: SCK (Clock) pin, which can directly transmit the pin value. The value range is [0,47]. Instead of setting it, use [fm] (../ builtin_py / fm.md) to manage the pin mapping uniformly. mosi: MOSI (host output) pin, which can directly pass the pin value, value range: [0,47]. Instead of setting it, use [fm] (../ builtin_py / fm.md) to manage the pin mapping uniformly. miso: MISO (host input) pin, which can directly pass the pin value, value range: [0,47]. Instead of setting it, use [fm] (../ builtin_py / fm.md) to manage the pin mapping uniformly. cs0: CS0 (chip select) pin, which can directly pass the pin value, value range: [0,47]. Instead of setting it, use [fm] (../ builtin_py / fm.md) to manage the pin mapping uniformly. cs1: CS1 (chip select) pin, which can directly pass the pin value, value range: [0,47]. Instead of setting it, use [fm] (../ builtin_py / fm.md) to manage the pin mapping uniformly. cs2: CS2 (chip select) pin, which can directly pass the pin value, value range: [0,47]. Instead of setting it, use [fm] (../ builtin_py / fm.md) to manage the pin mapping uniformly. cs3: CS3 (chip select) pin, which can directly pass the pin value, value range: [0,47]. Instead of setting it, use [fm] (../ builtin_py / fm.md) to manage the pin mapping uniformly. d0 ~ d7: Data pins, used in non-standard 4-wire mode, currently reserved. Instead of setting it, use [fm] (../ builtin_py / fm.md) to manage the pin mapping uniformly. Method init Constructor-like SPI.init (id, mode = SPI.MODE_MASTER, baudrate = 500000, polarity = 0, phase = 0, bits = 8, firstbit = SPI.MSB, sck, mosi, miso, cs0) parameters Same as constructor return value no read Read data SPI.read (nbytes, write = 0x00, cs = SPI.CS0) parameters nbytes: the length to read cs: Select chip select pins. Pins have been set forcs0 ~ cs3 during initialization. Here you only need to selectSPI.CS0 ~ SPI.CS3. The default isSPI. .CS0 write: Because it is full duplex, set the value of theMOSI pin when reading. The default is 0x00, which is always low. return value bytes data readinto Read the data and put it into the specified variable SPI.readinto (buf, write = 0x00, cs = SPI.CS0) parameters buf:bytearray type, which defines the length, and the data is saved here after reading cs: Select chip select pins. Pins have been set forcs0 ~ cs3 during initialization. Here you only need to selectSPI.CS0 ~ SPI.CS3. The default isSPI. .CS0 write: Because it is full duplex, set the value of theMOSI pin when reading. The default is 0x00, which is always low. return value no write send data SPI.write (buf, cs = SPI.CS0) parameters buf:bytearray type, which defines the data and length cs: Select chip select pins. Pins have been set forcs0 ~ cs3 during initialization. Here you only need to selectSPI.CS0 ~ SPI.CS3. The default isSPI. .CS0 return value no write_readinto Send data while reading data to a variable, that is, full duplex SPI.write (write_buf, read_buf, cs = SPI.CS0) parameters write_buf:bytearray type, which defines the data and length to be sent read_buf:bytearray type, which defines where the received data is stored cs: Select chip select pins. Pins have been set forcs0 ~ cs3 during initialization. Here you only need to selectSPI.CS0 ~ SPI.CS3. The default isSPI. .CS0 return value no deinit / \\ del \\ Log out of SPI, release hardware, shut down SPI clock SPI.deinit () parameters no return value no Examples spi.deinit () or del spi Constants SPI0: SPI 0 SPI1: SPI 1 SPI2: SPI 2 MODE_MASTER: as master mode MODE_MASTER_2: as master mode MODE_MASTER_4: as master mode MODE_MASTER_8: as master mode MODE_SLAVE: as slave mode MSB: MSB, that is, the high-order or high-order byte is sent first LSB: LSB, that is, send low-order or low-order byte first CS0: Chip Select 0 CS1: Chip Select 1 CS2: Chip Select 2 CS3: Chip Selection 3 Examples Example 1: Basic Read and Write from machine import SPI spi1 = SPI (SPI.SPI1, mode = SPI.MODE_MASTER, baudrate = 10000000, polarity = 0, phase = 0, bits = 8, firstbit = SPI.MSB, sck = 28, mosi = 29, miso = 30, cs0 = 27) w = b'1234 ' r = bytearray (4) spi1.write (w) spi1.write (w, cs = SPI.CS0) spi1.write_readinto (w, r) spi1.read (5, write = 0x00) spi1.readinto (r, write = 0x00) powered by GitbookFile Modify: 2020-09-11 12:05:50 "},"libs/machine/timer.html":{"url":"libs/machine/timer.html","title":"Timer","keywords":"","body":"machine.Timer Hardware timers deal with timing of periods and events. Timers are perhaps the most flexible and heterogeneous kind of hardware in MCUs and SoCs, differently greatly from a model to a model. MicroPython’s Timer class defines a baseline operation of executing a callback with a given period (or once after some delay), and allow specific boards to define more non-standard behavior (which thus won’t be portable to other boards). Constructors class machine.Timer(id, channel, mode=Timer.MODE_ONE_SHOT, period=1000, unit=Timer.UNIT_MS, callback=None, arg=None, start=True, priority=1, div=0) Construct a new timer object of the given id. Parameters id: Timer ID, [0~2] (Timer.TIMER0~TIMER2) channel: Timer channel, [Timer.CHANNEL0~Timer.CHANNEL3] mode: Timer mode, MODE_ONE_SHOT or MODE_PERIODICor MODE_PWM period: Timer period, after period the callback will be invoke, (0,~). unit: unit of timer, default ms, Timer.UNIT_S or Timer.UNIT_MS or Timer.UNIT_US orTimer.UNIT_NS callback: Timer callback, two parameters, first is Timer, second is user param, see param parameter below. callback execute in interrupt, so don't stay too long in callback arg: Argument dilivered to callback start: If start instantly timer after init, True:start, False:not start, need call start() function. priority: interrupt priority, [1,7]. div: Timer clock divider,[0,255],default to 0. clk_timer = clk_pll0/2^(div+1) clk_timer*period(unit:s) should =1 Methods init Same to constructor Timer.init(id, channel, mode=Timer.MODE_ONE_SHOT, period=1000, unit=Timer.UNIT_MS, callback=None, arg=None, start=True, priority=1, div=0) callback_arg callback arg of timer obj callback Get or set callback e.g. def on_timer(timer,param): print(\"time up:\",timer) print(\"param:\",timer.callback_arg()) tim.callback(on_timer) print(on_timer, tim.callback()) period Get or set period e.g. tim.period(2000) print( tim.period() ) start Start timer e.g. tim.start() stop Stop timer restart Restart timer deinit/del Deinitialises the timer. Stops the timer, and disables the timer peripheral. e.g. tim.deinit() or del tim Constants TIMER0: Timer0 id TIMER1: Timer1 id TIMER2: Timer2 id CHANNEL0: Timer channel 0 CHANNEL1: Timer channel 1 CHANNEL2: Timer channel 2 CHANNEL3: Timer channel 3 MODE_ONE_SHOT: Timer only run once MODE_PERIODIC: Timer always run MODE_PWM: Timer used by PWM UNIT_S: unit flag (s) UNIT_MS: unit flag (ms) UNIT_US: unit flag (us) UNIT_NS: unit flag (ns) Demo Demo 1 Print data after 3s just once from machine import Timer def on_timer(timer): print(\"time up:\",timer) print(\"param:\",timer.callback_arg()) tim = Timer(Timer.TIMER0, Timer.CHANNEL0, mode=Timer.MODE_ONE_SHOT, period=3000, callback=on_timer, arg=on_timer) print(\"period:\",tim.period()) Demo 2 Print every 1s, and stop 5s then restart 5s then shutdown import time from machine import Timer def on_timer(timer,param): print(\"time up:\",timer) print(\"param:\",param) tim = Timer(Timer.TIMER0, Timer.CHANNEL0, mode=Timer.MODE_PERIODIC, period=1, unit=Timer.UNIT_S, callback=on_timer, arg=on_timer, start=False, priority=1, div=0) print(\"period:\",tim.period()) tim.start() time.sleep(5) tim.stop() time.sleep(5) tim.restart() time.sleep(5) tim.stop() del tim powered by GitbookFile Modify: 2020-09-11 12:05:50 "},"libs/machine/uart.html":{"url":"libs/machine/uart.html","title":"UART","keywords":"","body":"machine.UART The uart module is mainly used to drive the asynchronous serial port on the development board, and uart can be freely configured. The k210 has a total of 3 uarts, and each uart can perform free pin mapping. Construction Pin mapping Before using uart, we need to use fm to map and manage the chip pins. As shown below, set PIN10 as the sending pin of uart2 and PIN11 as the receiving pin of uart2 fm.register (board_info.PIN10, fm.fpioa.UART2_TX) fm.register (board_info.PIN11, fm.fpioa.UART2_RX) Constructor uart = machine.UART (uart, baudrate, bits, parity, stop, timeout, read_buf_len) Create a new UART object with the specified parameters parameters uart UART number, use the specified UART, you can complete it by pressing the machine key withmachine.UART. baudrate: UART baud rate bits: UART data width, support5/6/7 / 8 (the default serial port used by REPL (UARTHS) only supports 8-bit mode), default 8 parity: parity bit, supportsNone, machine.UART.PARITY_ODD,machine.UART.PARITY_EVEN (the default serial port used by REPL (UARTHS) only supports None), default None stop: stop bit, supports1, 1.5,2, default 1 timeout: serial port receive timeout read_buf_len: Serial port receive buffer. The serial port receives data through interrupt. If the buffer is full, it will automatically stop receiving data. return value UART object Method init Used to initialize uart, usually already initialized when constructing the object, here is used to re-initialize uart uart.init (baudrate, bits, parity, stop, timeout, read_buf_len) parameters Same constructor but does not require the first UART number return value no read Used to read data from serial buffer uart.read (num) parameters num: the number of bytes read, generally fill the buffer size, if the number of data in the buffer is not as large asnum, then only the remaining data in the buffer will be returned return value bytes data readline Yihang for reading serial buffered data uart.readline (num) num: number of rows read return value bytes data write Used to send data using the serial port uart.write (buf) parameters buf: need to send data return value Amount of data written deinit Unregister UART hardware and free up resources UART.deinit () parameters no return value no repl_uart () Get serial object for REPL return value Serial object for REPL, default initialization bit 115200 8 N 1 Examples Routine 1 Before running mileage, please make sure PIN15 is connected toPIN10 and PIN17 is connected toPIN9 After running the program, you can see the print information of baudrate: 115200 bits: 8 parity: 0 stop: 0 --- check Successfully in the terminal from fpioa_manager import fm from machine import UART fm.register (board_info.PIN15, fm.fpioa.UART1_TX) fm.register (board_info.PIN17, fm.fpioa.UART1_RX) fm.register (board_info.PIN9, fm.fpioa.UART2_TX) fm.register (board_info.PIN10, fm.fpioa.UART2_RX) uart_A = UART (UART.UART1, 115200, 8, None, 1, timeout = 1000, read_buf_len = 4096) uart_B = UART (UART.UART2, 115200, 8, None, 1, timeout = 1000, read_buf_len = 4096) write_str = 'hello world' for i in range (20): uart_A.write (write_str) read_data = uart_B.read () read_str = read_data.decode ('utf-8') print (\"string =\", read_str) if read_str == write_str: print (\"baudrate: 115200 bits: 8 parity: None stop: 1 --- check Successfully\") uart_A.deinit () uart_B.deinit () del uart_A del uart_B Routine 2 AT module serial port fm.register (board_info.WIFI_RX, fm.fpioa.UART2_TX) fm.register (board_info.WIFI_TX, fm.fpioa.UART2_RX) uart = machine.UART (machine.UART.UART2, 115200, timeout = 1000, read_buf_len = 4096) Routine 3 Modify the baud rate of the REPL serial port from machine import UART repl = UART.repl_uart () repl.init (1500000, 8, None, 1, read_buf_len = 2048) Routine 3 Modify the REPL serial port from machine import UART fm.register (board_info.PIN15, fm.fpioa.UART1_TX) fm.register (board_info.PIN17, fm.fpioa.UART1_RX) uart = machine.UART (UART.UART1, 115200) UART.set_repl_uart (uart) powered by GitbookFile Modify: 2020-09-11 12:05:50 "},"libs/machine/network.html":{"url":"libs/machine/network.html","title":"network","keywords":"","body":"network This module is used to initialize various network card drivers. The network card has these function: connecting routes, disconnecting routes, viewing network card connection information, checking whether connections are made. Please make sure the antenna is connected before using WiFi. esp8285 Some development boards expose an AT network interface module, such as an esp8285 interface connected to the k210 processor via a serial port. Pin 8 is the enable pin. Instantiate a GPIO object set it high to enable, low to disable. To reset, set it low, wait a short while, then set it high. Sample code [wifi_ap_scan.py] (https://github.com/sipeed/MaixPy_scripts/blob/master/network/demo_wifi_ap_scan.py) esp32 There is currently a esp32 module in the MaixDuino development board connected to k210 via SPI. There is also a separate TF plug-in module. ESP8285_Module network.ESP8285(uart) Instantiate an ESP8285 NIC object, passing in an uart object. On the dock and GO currently supported by MaixPy, use the AT command module as WiFi. So the uart object is the object that communicates with the AT module, you can view the uart module routine. Calling this method will initialize ESP8285, throwing an exception if it fails. Parameters uart: UART object that communicates with the AT module Return Value ESP8285: NIC object ESP8285 connect(ssid, key) Connect to a hotspot (AP/router). Parameters ssid: hotspot SSID key: password for hotspot Return Value None. An exception will be thrown if an error occurs. 2.2. ifconfig Display the current WiFi connection information. Currently, the network does not support setting the network card configuration. nic.ifconfig() Parameters None Return Value tuple type, the elements are all strings: (ip, netmask, gateway, dns_server, dhcp_server, mac, ssid), if not queried or invalid, the value is `\"0\". isconnected Check if WiFi is connected. nic.isconnected() Parameters None Return Value True: Already connected False: Disconnected disconnect Disconnect WiFi. Parameters None Return Value None scan Scan for surrounding WiFi hotspots. Parameters None Return Value A list object, each element containing a string, the string comes from the response of the AT module, the content is the same as described in esp8285 AT directive document, as follows: ',,,,,,,, ,,' : encryption method 0: OPEN 1: WEP 2: WPA_PSK 3: WPA2_PSK 4: WPA_WPA2_PSK 5: WPA2_Enterprise (current AT does not support connection to this encrypted AP) : string parameter, SSID of AP : signal strength : string parameter, AP's MAC address : channel number : AP frequency offset, unit: kHz. This value is divided by 2.4 to get the ppm value. : frequency offset calibration value : 0: CIPHER_NONE 1: CIPHER_WEP40 2: CIPHER_WEP104 3: CIPHER_TKIP 4: CIPHER_CCMP 5: CIPHER_TKIP_CCMP 6: CIPHER_UNKNOWN : definition is the same as : bit0 stands for b mode; bit1 stands for g mode; bit2 stands for n mode If the corresponding bit is 1, it indicates that the mode is enabled; if the corresponding bit is 0, the mode is not enabled. :0, WPS is not enabled; 1, WPS is enabled example: info_strs = ['4,\"ChinaNet-lot0\",-79,\"c8:50:e9:e8:21:3e\",1,-42,0,4,3,7,1', '4,\"TOPSTEP2G4\",-7 0,\"f8:e7:1e:0d:0d:f8\",1,-57,0,4,4,7,0'] This may seem strange, because each AP's information is a string of characters, there are integers and strings in the message, the string is enclosed in double quotes, so you need to deal with it again after getting this string, for example: def wifi_deal_ap_info(info): res = [] for ap_str in info: ap_str = ap_str.split(\",\") info_one = [] for node in ap_str: if node.startswith('\"'): info_one.append(node[1:-1]) else: info_one.append(int(node)) res.append(info_one) return res info_strs = ['4,\"ChinaNet-lot0\",-79,\"c8:50:e9:e8:21:3e\",1,-42,0,4,3,7,1', '4,\"TOPSTEP2G4\",-70,\"f8:e7:1e:0d:0d:f8\",1,-57,0,4,4,7,0'] info = wifi_deal_ap_info(info_strs) print(info) The output is: [[4, 'ChinaNet-lot0', -79, 'c8:50:e9:e8:21:3e', 1, -42, 0, 4, 3, 7, 1], [4, 'TOPSTEP2G4', -70, 'f8:e7:1e:0d:0d:f8', 1, -57, 0, 4, 4, 7, 0]] Then for example to get every AP SSID: for ap_info in info: print(ap_info[1]) enable_ap(ssid, key, chl=5, ecn=3) Connect to the specified WiFi hotspot. Parameters ssid: SSID key: password chl: channel number of the WiFi signal ecn: encryption method, there are OPEN``WPA2_PSK, etc., refer to the constant part of this page ESP8285, the default value is 3, which is ESP8285.WPA2_PSK, for exampleNic = network.ESP8285(uart) Nic.enable_ap(\"maixpy\", \"12345678\", 5, nic.OPEN) orNic.enable_ap(\"maixpy\", \"12345678\", 5, network.ESP8285.OPEN) disable_ap() Disconnect from the currently connected WiFi hotspot. Constants OPEN No encryption and no password required. WPA_PSK WPA_PSK encryption WPA2_PSK WPA2_PSK encryption WPA_WPA2_PSK WPA_WPA2_PSK encryption Code Refer to [code in the network directory] (https://github.com/sipeed/MaixPy_scripts/tree/master/network) ESP32_Module network.ESP32_SPI(cs,rst,rdy,mosi,miso,sclk) To instantiate an ESP32_SPI NIC object, you need to pass in the corresponding GPIOHS FUNC. If the number of parameters passed in is incorrect, an error will be returned. Parameters fpioa_func for pin function Return Value ESP32_SPI NIC object ESP32_SPI adc Read the adc value of the esp32 module Parameters None Return Value tuple, the adc value of 5 channels is \"PIN36\", \"PIN39\", \"PIN34\", \"PIN35\", \"PIN32\" Code demo_esp32_read_adc.py powered by GitbookFile Modify: 2020-09-11 12:05:50 "},"libs/Maix/":{"url":"libs/Maix/","title":"Maix","keywords":"","body":"Maix库 FPIOA GPIO KPU FFT I2S Audio freq utils powered by GitbookFile Modify: 2020-09-11 12:05:50 "},"libs/Maix/fpioa.html":{"url":"libs/Maix/fpioa.html","title":"FPIOA","keywords":"","body":"FPIOA (Field Programmable Input and Output Array) The K210 supports each peripheral to be randomly mapped to any pin, using the FPIOA function. Attention: Some GPIOHS used by default, don't use these GPIOHS if you don't have to, GPIOHS used as follows: GPIOHS Function GPIOHS31 LCD_DC GPIOHS30 LCD_RST GPIOHS29 SD_CS GPIOHS28 MIC_LED_CLK GPIOHS27 MIC_LED_DATA Class FPIOA Method help(func) Display peripherals and their brief description Parameters func: Peripheral name (function/number), you can not pass the parameter, then display all the peripheral names in a tabular form, which is also a brief description. This table can also be found at the end of this page (Appendix: Peripheral Table); If the parameter is passed, an integer value is passed. When the peripheral corresponding to the number is found, the peripheral name and description are printed, For example FPIOA.JTAG_TCLK or fm.fpioa.JTAG_TCLK (fm is described later in this page) or 0 such as: From Maix import FPIOA Fpioa = FPIOA() Fpioa.help() Fpioa.help(0) Fpioa.help(fpioa.JTAG_TCLK) Fm.fpioa.help() Fm.fpioa.help(fm.fpioa.JTAG_TCLK) Back Peripheral name and its brief description set_function(pin, func) Set the peripheral function corresponding to the pin, that is, pin mapping Parameters pin: pin number, value [0, 47], please refer to the circuit diagram for the specific pin connection. You can also use board_info. and then press the TAB button to get the common pins of the board. board_info.LED_G func: Peripheral function, passing an integer value, can be obtained by fm.fpioa.help() or by looking at the [Appendix: Peripheral Table] (#Appendix: Peripheral Table) table at the end of this page. For example, you need to map the pin connecting green LED to high speed GPIO0: Fpioa = FPIOA() Fpioa.set_function(board_info.LED_G, fm.fpioa.GPIOHS0) get_Pin_num(func) Get which pin the peripheral is mapped to Parameters func: Peripheral function, passing an integer value, can be obtained by fm.fpioa.help() or by looking at the Appendix: Peripheral Table table at the end of this page. such as: Fpioa = FPIOA() Fpioa.set_function(board_info.LED_G, fm.fpioa.GPIOHS0) Pin = fpioa.get_Pin_num(fm.fpioa.GPIOHS0) If pin == board_info.LED_G: Print(\"set function ok\") Appendix: Peripheral Table Peripheral Functions (func) Brief Description JTAG_TCLK JTAG Test Clock JTAG_TDI JTAG Test Data In JTAG_TMS JTAG Test Mode Select JTAG_TDO JTAG Test Data Out SPI0_D0 SPI0 Data 0 SPI0_D1 SPI0 Data 1 SPI0_D2 SPI0 Data 2 SPI0_D3 SPI0 Data 3 SPI0_D4 SPI0 Data 4 SPI0_D5 SPI0 Data 5 SPI0_D6 SPI0 Data 6 SPI0_D7 SPI0 Data 7 SPI0_SS0 SPI0 Chip Select 0 SPI0_SS1 SPI0 Chip Select 1 SPI0_SS2 SPI0 Chip Select 2 SPI0_SS3 SPI0 Chip Select 3 SPI0_ARB SPI0 Arbitration SPI0_SCLK SPI0 Serial Clock UARTHS_RX UART High speed Receiver UARTHS_TX UART High speed Transmitter RESV6 Reserved function RESV7 Reserved function CLK_SPI1 Clock SPI1 CLK_I2C1 Clock I2C1 GPIOHS0 GPIO High speed 0 GPIOHS1 GPIO High speed 1 GPIOHS2 GPIO High speed 2 GPIOHS3 GPIO High speed 3 GPIOHS4 GPIO High speed 4 GPIOHS5 GPIO High speed 5 GPIOHS6 GPIO High speed 6 GPIOHS7 GPIO High speed 7 GPIOHS8 GPIO High speed 8 GPIOHS9 GPIO High speed 9 GPIOHS10 GPIO High speed 10 GPIOHS11 GPIO High speed 11 GPIOHS12 GPIO High speed 12 GPIOHS13 GPIO High speed 13 GPIOHS14 GPIO High speed 14 GPIOHS15 GPIO High speed 15 GPIOHS16 GPIO High speed 16 GPIOHS17 GPIO High speed 17 GPIOHS18 GPIO High speed 18 GPIOHS19 GPIO High speed 19 GPIOHS20 GPIO High speed 20 GPIOHS21 GPIO High speed 21 GPIOHS22 GPIO High speed 22 GPIOHS23 GPIO High speed 23 GPIOHS24 GPIO High speed 24 GPIOHS25 GPIO High speed 25 GPIOHS26 GPIO High speed 26 GPIOHS27 GPIO High speed 27 GPIOHS28 GPIO High speed 28 GPIOHS29 GPIO High speed 29 GPIOHS30 GPIO High speed 30 GPIOHS31 GPIO High speed 31 GPIO0 GPIO pin 0 GPIO1 GPIO pin 1 GPIO2 GPIO pin 2 GPIO3 GPIO pin 3 GPIO4 GPIO pin 4 GPIO5 GPIO pin 5 GPIO6 GPIO pin 6 GPIO7 GPIO pin 7 UART1_RX UART1 Receiver UART1_TX UART1 Transmitter UART2_RX UART2 Receiver UART2_TX UART2 Transmitter UART3_RX UART3 Receiver UART3_TX UART3 Transmitter SPI1_D0 SPI1 Data 0 SPI1_D1 SPI1 Data 1 SPI1_D2 SPI1 Data 2 SPI1_D3 SPI1 Data 3 SPI1_D4 SPI1 Data 4 SPI1_D5 SPI1 Data 5 SPI1_D6 SPI1 Data 6 SPI1_D7 SPI1 Data 7 SPI1_SS0 SPI1 Chip Select 0 SPI1_SS1 SPI1 Chip Select 1 SPI1_SS2 SPI1 Chip Select 2 SPI1_SS3 SPI1 Chip Select 3 SPI1_ARB SPI1 Arbitration SPI1_SCLK SPI1 Serial Clock SPI_SLAVE_D0 SPI Slave Data 0 SPI_SLAVE_SS SPI Slave Select SPI_SLAVE_SCLK SPI Slave Serial Clock I2S0_MCLK I2S0 Master Clock I2S0_SCLK I2S0 Serial Clock(BCLK) I2S0_WS I2S0 Word Select(LRCLK) I2S0_IN_D0 I2S0 Serial Data Input 0 I2S0_IN_D1 I2S0 Serial Data Input 1 I2S0_IN_D2 I2S0 Serial Data Input 2 I2S0_IN_D3 I2S0 Serial Data Input 3 I2S0_OUT_D0 I2S0 Serial Data Output 0 I2S0_OUT_D1 I2S0 Serial Data Output 1 I2S0_OUT_D2 I2S0 Serial Data Output 2 I2S0_OUT_D3 I2S0 Serial Data Output 3 I2S1_MCLK I2S1 Master Clock I2S1_SCLK I2S1 Serial Clock(BCLK) I2S1_WS I2S1 Word Select(LRCLK) I2S1_IN_D0 I2S1 Serial Data Input 0 I2S1_IN_D1 I2S1 Serial Data Input 1 I2S1_IN_D2 I2S1 Serial Data Input 2 I2S1_IN_D3 I2S1 Serial Data Input 3 I2S1_OUT_D0 I2S1 Serial Data Output 0 I2S1_OUT_D1 I2S1 Serial Data Output 1 I2S1_OUT_D2 I2S1 Serial Data Output 2 I2S1_OUT_D3 I2S1 Serial Data Output 3 I2S2_MCLK I2S2 Master Clock I2S2_SCLK I2S2 Serial Clock(BCLK) I2S2_WS I2S2 Word Select(LRCLK) I2S2_IN_D0 I2S2 Serial Data Input 0 I2S2_IN_D1 I2S2 Serial Data Input 1 I2S2_IN_D2 I2S2 Serial Data Input 2 I2S2_IN_D3 I2S2 Serial Data Input 3 I2S2_OUT_D0 I2S2 Serial Data Output 0 I2S2_OUT_D1 I2S2 Serial Data Output 1 I2S2_OUT_D2 I2S2 Serial Data Output 2 I2S2_OUT_D3 I2S2 Serial Data Output 3 RESV0 Reserved function RESV1 Reserved function RESV2 Reserved function RESV3 Reserved function RESV4 Reserved function RESV5 Reserved function I2C0_SCLK I2C0 Serial Clock I2C0_SDA I2C0 Serial Data I2C1_SCLK I2C1 Serial Clock I2C1_SDA I2C1 Serial Data I2C2_SCLK I2C2 Serial Clock I2C2_SDA I2C2 Serial Data CMOS_XCLK DVP System Clock CMOS_RST DVP System Reset CMOS_PWDN DVP Power Down Mode CMOS_VSYNC DVP Vertical Sync CMOS_HREF DVP Horizontal Reference output CMOS_PCLK Pixel Clock CMOS_D0 Data Bit 0 CMOS_D1 Data Bit 1 CMOS_D2 Data Bit 2 CMOS_D3 Data Bit 3 CMOS_D4 Data Bit 4 CMOS_D5 Data Bit 5 CMOS_D6 Data Bit 6 CMOS_D7 Data Bit 7 SCCB_SCLK SCCB Serial Clock SCCB_SDA SCCB Serial Data UART1_CTS UART1 Clear To Send UART1_DSR UART1 Data Set Ready UART1_DCD UART1 Data Carrier Detect UART1_RI UART1 Ring Indicator UART1_SIR_IN UART1 Serial Infrared Input UART1_DTR UART1 Data Terminal Ready UART1_RTS UART1 Request To Send UART1_OUT2 UART1 User-designated Output 2 UART1_OUT1 UART1 User-designated Output 1 UART1_SIR_OUT UART1 Serial Infrared Output UART1_BAUD UART1 Transmit Clock Output UART1_RE UART1 Receiver Output Enable UART1_DE UART1 Driver Output Enable UART1_RS485_EN UART1 RS485 Enable UART2_CTS UART2 Clear To Send UART2_DSR UART2 Data Set Ready UART2_DCD UART2 Data Carrier Detect UART2_RI UART2 Ring Indicator UART2_SIR_IN UART2 Serial Infrared Input UART2_DTR UART2 Data Terminal Ready UART2_RTS UART2 Request To Send UART2_OUT2 UART2 User-designated Output 2 UART2_OUT1 UART2 User-designated Output 1 UART2_SIR_OUT UART2 Serial Infrared Output UART2_BAUD UART2 Transmit Clock Output UART2_RE UART2 Receiver Output Enable UART2_DE UART2 Driver Output Enable UART2_RS485_EN UART2 RS485 Enable UART3_CTS UART3 Clear To Send UART3_DSR UART3 Data Set Ready UART3_DCD UART3 Data Carrier Detect UART3_RI UART3 Ring Indicator UART3_SIR_IN UART3 Serial Infrared Input UART3_DTR UART3 Data Terminal Ready UART3_RTS UART3 Request To Send UART3_OUT2 UART3 User-designated Output 2 UART3_OUT1 UART3 User-designated Output 1 UART3_SIR_OUT UART3 Serial Infrared Output UART3_BAUD UART3 Transmit Clock Output UART3_RE UART3 Receiver Output Enable UART3_DE UART3 Driver Output Enable UART3_RS485_EN UART3 RS485 Enable TIMER0_TOGGLE1 TIMER0 Toggle Output 1 TIMER0_TOGGLE2 TIMER0 Toggle Output 2 TIMER0_TOGGLE3 TIMER0 Toggle Output 3 TIMER0_TOGGLE4 TIMER0 Toggle Output 4 TIMER1_TOGGLE1 TIMER1 Toggle Output 1 TIMER1_TOGGLE2 TIMER1 Toggle Output 2 TIMER1_TOGGLE3 TIMER1 Toggle Output 3 TIMER1_TOGGLE4 TIMER1 Toggle Output 4 TIMER2_TOGGLE1 TIMER2 Toggle Output 1 TIMER2_TOGGLE2 TIMER2 Toggle Output 2 TIMER2_TOGGLE3 TIMER2 Toggle Output 3 TIMER2_TOGGLE4 TIMER2 Toggle Output 4 CLK_SPI2 Clock SPI2 CLK_I2C2 Clock I2C2 powered by GitbookFile Modify: 2020-09-11 12:05:50 "},"libs/Maix/gpio.html":{"url":"libs/Maix/gpio.html","title":"GPIO","keywords":"","body":"GPIO General Purpose Input Output is referred to as GPIO, or bus extender. High speed gpio and universal gpio on the K210 On the K210, GPIO has the following characteristics: High speed GPIO: The high-speed GPIO is GPIOHS, a total of 32. Has the following characteristics: • Configurable input and output signals • Each IO has an independent interrupt source • Interrupt support edge trigger and level trigger • Each IO can be assigned to one of the 48 pins on the FPIOA • Configurable up and down, or high resistance General GPIO: There are 8 general-purpose GPIOs with the following characteristics: • 8 IOs use one interrupt source • Configurable input and output signals • Configurable trigger IO total interrupt, edge trigger and level trigger • Each IO can be assigned to one of the 48 pins on the FPIOA Attention: Some GPIOHS used by default, don't use these GPIOHS if you don't have to, GPIOHS used as follows: GPIOHS Function GPIOHS31 LCD_DC GPIOHS30 LCD_RST GPIOHS29 SD_CS GPIOHS28 MIC_LED_CLK GPIOHS27 MIC_LED_DATA Constructor Class GPIO(ID, MODE, PULL, VALUE) Create a new SPI object with the specified parameters Parameters ID: The GPIO pin used (must be specified using the constants in GPIO) MODE: GPIO mode • GPIO.IN is the input mode • GPIO.OUT is the output mode PULL: GPIO pull-down mode * • GPIO.PULL_UP pull up • GPIO.PULL_DOWN dropdown • GPIO.PULL_NONE does not pull up or pull down method value Modify/read GPIO pin status GPIO.value([value]) Parameters [value]: optional parameter, if this parameter is not empty, return the current GPIO pin status return value Returns the current GPIO pin status if the [value] parameter is not empty irq Configure an interrupt handler to call when the pin's trigger source is active. If the pin mode is pin.in, the trigger source is an external value on the pin. GPIO.irq(CALLBACK_FUNC, TRIGGER_CONDITION, GPIO.WAKEUP_NOT_SUPPORT, PRORITY) Parameters CALLBACK_FUNC: callback function, called when the interrupt is triggered, it has two parameters, GPIO and PIN_NUM • GPIO returns a GPIO object • PIN_NUM returns the GPIO pin number that triggered the interrupt (only GPIOHS supports interrupts, so the pin number here is also the GPIOHS pin number) TRIGGER_CONDITION: Trigger interrupt when GPIO pin is in this state • GPIO.IRQ_RISING rising edge trigger • GPIO.GPIO.IRQ_FALLING falling edge trigger • GPIO.IRQ_BOTH is triggered on both rising and falling edges return value no disirq Close interrupt GPIO.disirq() Parameters no return value no mode GPIO mode GPIO.mode(MODE) Parameters MODE • GPIO.IN is the input mode • GPIO.OUT is the output mode return value no pull GPIO pull-down mode GPIO.pull(PULL) Parameters PULL • GPIO.IRQ_RISING rising edge trigger • GPIO.IRQ_FALLING falling edge trigger • GPIO.IRQ_BOTH is triggered on both rising and falling edges return value no Constant GPIO0: GPIO0 GPIO1: GPIO1 GPIO2: GPIO2 GPIO3: GPIO3 GPIO4: GPIO4 GPIO5: GPIO5 GPIO6: GPIO6 GPIO7: GPIO7 GPIOHS0: GPIOHS0 GPIOHS1: GPIOHS1 GPIOHS2: GPIOHS2 GPIOHS3: GPIOHS3 GPIOHS4: GPIOHS4 GPIOHS5: GPIOHS5 GPIOHS6: GPIOHS6 GPIOHS7: GPIOHS7 GPIOHS8: GPIOHS8 GPIOHS9: GPIOHS9 GPIOHS10: GPIOHS10 GPIOHS11: GPIOHS11 GPIOHS12: GPIOHS12 GPIOHS13: GPIOHS13 GPIOHS14: GPIOHS14 GPIOHS15: GPIOHS15 GPIOHS16: GPIOHS16 GPIOHS17: GPIOHS17 GPIOHS18: GPIOHS18 GPIOHS19: GPIOHS19 GPIOHS20: GPIOHS20 GPIOHS21: GPIOHS21 GPIOHS22: GPIOHS22 GPIOHS23: GPIOHS23 GPIOHS24: GPIOHS24 GPIOHS25: GPIOHS25 GPIOHS26: GPIOHS26 GPIOHS27: GPIOHS27 GPIOHS28: GPIOHS28 GPIOHS29: GPIOHS29 GPIOHS30: GPIOHS30 GPIOHS31: GPIOHS31 GPIO.IN: input mode GPIO.OUT: output mode GPIO.PULL_UP: Pull up GPIO.PULL_DOWN: drop down GPIO.PULL_NONE: does not pull up or pull down GPIO.IRQ_RISING: rising edge trigger GPIO.IRQ_FALLING: falling edge trigger GPIO.IRQ_BOTH: Both rising and falling edges are triggered DEMO1 import utime from Maix import GPIO fm.register(board_info.LED_R,fm.fpioa.GPIO0) led_r=GPIO(GPIO.GPIO0,GPIO.OUT) utime.sleep_ms(500) led_r.value() fm.unregister(board_info.LED_R,fm.fpioa.GPIO0) DEMO2 import utime from Maix import GPIO fm.register(board_info.LED_R,fm.fpioa.GPIO0) led_r=GPIO(GPIO.GPIO0,GPIO.IN) utime.sleep_ms(500) led_r.value() fm.unregister(board_info.LED_R,fm.fpioa.GPIO0) DEMO3 import utime from Maix import GPIO def test_irq(GPIO,pin_num): print(\"key\",pin_num,\"\\n\") fm.register(board_info.BOOT_KEY,fm.fpioa.GPIOHS0) key=GPIO(GPIO.GPIOHS0,GPIO.IN,GPIO.PULL_NONE) utime.sleep_ms(500) key.value() key.irq(test_irq,GPIO.IRQ_BOTH,GPIO.WAKEUP_NOT_SUPPORT,7) key.disirq() fm.unregister(board_info.BOOT_KEY,fm.fpioa.GPIOHS0) powered by GitbookFile Modify: 2020-09-11 12:05:50 "},"libs/Maix/kpu.html":{"url":"libs/Maix/kpu.html","title":"KPU","keywords":"","body":"KPU KPU is a general-purpose neural network processor, which can do convolutional neural network calculation at low power consumption, for example obtain the size, coordinates and types of detected objects or detect and classify faces and objects. KPU has the following features: Supports fixed-point models trained by mainstream framework with some restrictions There is no direct limit on the number of network layers. It supports separate configuration of each layer of convolutional neural network parameters, including the number of input and output channels, input and output line width and column height. Supports two convolution kernels 1x1 and 3x3 Support any form of activation function The maximum supported neural network parameter size in real-time work is 5.5MiB to 5.9MiB Maximum supported network parameter size when working in non-real time (Flash capacity - software volume) Module Method Loading the model Load a model from flash or file system import KPU as kpu task = kpu.load(offset or file_path) Parameters offtset: The offset of the model in flash, such as 0xd00000 indicates that the model is flashed at the beginning of 13M file_path: The model is the file name in the file system, such as \"/sd/xxx.kmodel\" Back kpu_net: kpu network object Initializing the yolo2 network Passing initialization parameters for the yolo2 network model import KPU as kpu task = kpu.load(offset or file_path) anchor = (1.889, 2.5245, 2.9465, 3.94056, 3.99987, 5.3658, 5.155437, 6.92275, 6.718375, 9.01025) kpu.init_yolo2(task, 0.5, 0.3, 5, anchor) Parameters kpu_net: kpu network object threshold: probability threshold nms_value: box_iou threshold anchor_num: number of anchors anchor: anchor parameters are consistent with model parameters initialization import KPU as kpu task = kpu.load(offset or file_path) kpu.deinit(task) Parameters kpu_net: kpu_net object returned by kpu_load Running yolo2 network import KPU as kpu import image task = kpu.load(offset or file_path) anchor = (1.889, 2.5245, 2.9465, 3.94056, 3.99987, 5.3658, 5.155437, 6.92275, 6.718375, 9.01025) kpu.init_yolo2(task, 0.5, 0.3, 5, anchor) img = image.Image() kpu.run_yolo2(task, img) #This is not right, please refer to the routine Parameters kpu_net: kpu_net object returned by kpu_load image_t: image captured from sensor Back list: list of kpu_yolo2_find Network forward operation (forward) Calculate the loaded network model to the specified number of layers 3, and output the feature map of the target layer import KPU as kpu task = kpu.load(offset or file_path) …… fmap=kpu.forward(task,img,3) Parameters kpu_net: kpu_net object image_t: image captured from sensor int: specifies the number of layers to calculate to the network Back fmap: Feature map object, containing the feature map of all channels of the current layer fmap feature map Take the specified channel data of the feature map to the image object img=kpu.fmap(fmap,1) Parameters fmap: feature map object int: specify the channel number of the feature map Back img_t: The grayscale image generated by the corresponding map of the feature map fmap_free Release Feature Map Release feature map object kpu.fmap_free(fmap) Parameters fmap: feature map object Back none netinfo Get the network structure information of the model info=kpu.netinfo(task) layer0=info[0] Parameters kpu_net: kpu_net object Back netinfo list: a list of all layers of information, including information:Index: the number of layers of the current layer in the network Wi: input width Hi: input height Wo: output width Ho: output height Chi: number of input channels Cho: number of output channels Dw: whether it is a depth wise layer Kernel_type: convolution kernel type, 0 is 1x1, 1 is 3x3 Pool_type: pooling type, 0 is not pooled; 1:2x2 max pooling; 2:... Para_size: the number of bytes of the convolution parameter of the current layer Routine Running face recognition demo Model download address: http://dl.sipeed.com/MAIX/MaixPy/model/face_model_at_0x300000.kfpkg import sensor import image import lcd import KPU as kpu lcd.init() sensor.reset() sensor.set_pixformat(sensor.RGB565) sensor.set_framesize(sensor.QVGA) sensor.run(1) task = kpu.load(0x300000) #使用kfpkg将 kmodel 与 maixpy 固件打包下载到 flash anchor = (1.889, 2.5245, 2.9465, 3.94056, 3.99987, 5.3658, 5.155437, 6.92275, 6.718375, 9.01025) a = kpu.init_yolo2(task, 0.5, 0.3, 5, anchor) while(True): img = sensor.snapshot() code = kpu.run_yolo2(task, img) if code: for i in code: print(i) a = img.draw_rectangle(i.rect()) a = lcd.display(img) a = kpu.deinit(task) Operational feature map Model download address: http://dl.sipeed.com/MAIX/MaixPy/model/face_model_at_0x300000.kfpkg The model is an 8-bit fixed-point model, about 380KB in size, and the layer information is: 1 2 : 160x120 3 4 5 6 : 80x60 7 8 9 10 :40x30 11~16 : 20x15 import sensor import image import lcd import KPU as kpu index=3 lcd.init() sensor.reset() sensor.set_pixformat(sensor.RGB565) sensor.set_framesize(sensor.QVGA) sensor.run(1) task=kpu.load(0x300000) img=image.Image() info=kpu.netinfo(task) layer=info[index] w=layer.wo() h=layer.ho() num=int(320*240/w/h) list=[None]*num x_step=int(320/w) y_step=int(240/h) img_lcd=image.Image() while True: img=sensor.snapshot() fmap=kpu.forward(task,img,index) for i in range(0,num): list[i]=kpu.fmap(fmap,i) for i in range(0,num): list[i].stretch(64,255) for i in range(0,num): a=img_lcd.draw_image(list[i],((i%x_step)*w,(int(i/x_step))*h)) lcd.display(img_lcd) kpu.fmap_free(fmap) powered by GitbookFile Modify: 2020-09-11 12:05:50 "},"libs/Maix/fft.html":{"url":"libs/Maix/fft.html","title":"FFT","keywords":"","body":"FFT operation The FFT fast Fourier transform module performs Fourier transform on the input data and returns the corresponding frequency amplitudes. The FFT fast Fourier operation can convert the time domain signal into the frequency domain signal. Module function arithmetic function Enter time domain data and perform Fourier transform import FFT res = FFT.run(data, points, shift) Parameters data: input time domain data, bytearray type points: FFT operation points, only supports 64, 128, 256 and 512 points shift: offset, default is 0 return value res: Returns the calculated frequency domain data, presented as list type. The list has points tuples, each tuple has 2 elements, the first element is the real part, and the second is Imaginary Frequency function FFT res = FFT.freq(points, sample_rate) Parameters points: Calculate points sample_rate: sample rate return value res : Returns a list of the frequency values ​​of all frequency points after the operation Amplitude function It is used to calculate the amplitude of each frequency point after the FFT operation. It is currently used as a test. Users can write their own amplitude processing functions in python. amp = FFT.amplitude(FFT_res) Parameters FFT_res: function run results after running return value res : Returns a list that stores the magnitude of each frequency point Routine Acquire sound and perform FFT operation, and display the calculated data on the screen as a histogram from Maix import GPIO from Maix import I2S from Maix import FFT import image import lcd lcd.init() fm.register(8, fm.fpioa.GPIO0) wifi_en=GPIO(GPIO.GPIO0,GPIO.OUT) wifi_en.value(0) fm.register(20,fm.fpioa.I2S0_IN_D0) fm.register(19,fm.fpioa.I2S0_WS) fm.register(18,fm.fpioa.I2S0_SCLK) rx = I2S(I2S.DEVICE_0) rx.channel_config(rx.CHANNEL_0, rx.RECEIVER, align_mode = I2S.STANDARD_MODE) sample_rate = 38640 rx.set_sample_rate(sample_rate) img = image.Image() sample_points = 1024 FFT_points = 512 lcd_width = 320 lcd_height = 240 hist_num = FFT_points #changeable if hist_num > 320: hist_num = 320 hist_width = int(320 / hist_num)#changeable x_shift = 0 while True: audio = rx.record(sample_points) FFT_res = FFT.run(audio.to_bytes(),FFT_points) FFT_amp = FFT.amplitude(FFT_res) img = img.clear() x_shift = 0 for i in range(hist_num): if FFT_amp[i] > 240: hist_height = 240 else: hist_height = FFT_amp[i] img = img.draw_rectangle((x_shift,240-hist_height,hist_width,hist_height),[255,255,255],2,True) x_shift = x_shift + hist_width lcd.display(img) powered by GitbookFile Modify: 2020-09-11 12:05:50 "},"libs/Maix/i2s.html":{"url":"libs/Maix/i2s.html","title":"I2S","keywords":"","body":"I2S The I2S module is mainly used to drive I2S devices. The k210 has a total of 3 I2S devices and each device has a total of 4 channels. Before use, it is necessary to map and manage the pins. Module functions Constructor Create a new I2S object from Maix import I2S i2s_dev = I2S (device_num) parameters device_num UART number, using the specified I2S, which can be completed by pressing the I2S.` tab return value Returns an I2S object Channel configuration function Used to configure I2S channels. Pin mapping is required before i2s_dev.channel_config (channel, mode, resolution, cycles, align_mode) parameters channel: I2S channel number mode: channel transmission mode. There are a total of receiving and sending modes. resolution: channel resolution, ie the number of received data bits cycles: number of single data clocks align_mode: channel alignment mode return value no Set the sampling rate Used to configure the I2S sampling rate i2s_dev.set_sample_rate (sample_rate) parameters sample_rate: return value no Receive audio Receive audio data using I2S audio = i2s_dev.record (points) parameters points: audio points collected at one time return value audio: an audio audio object Send audio Send audio data using I2S i2s_dev.play (audio) parameters audio: the audio object to send return value no Examples Routine 1 from Maix import I2S import time fm.register (20, fm.fpioa.I2S0_IN_D0) #GO fm.register (19, fm.fpioa.I2S0_WS) fm.register (18, fm.fpioa.I2S0_SCLK) fm.register (34, fm.fpioa.I2S2_OUT_D1) fm.register (35, fm.fpioa.I2S2_SCLK) fm.register (33, fm.fpioa.I2S2_WS) sample_rate = 44 * 1000 rx = I2S (I2S.DEVICE_0) rx.channel_config (rx.CHANNEL_0, rx.RECEIVER, align_mode = I2S.STANDARD_MODE) rx.set_sample_rate (sample_rate) tx = I2S (I2S.DEVICE_2) tx.channel_config (tx.CHANNEL_1, tx.TRANSMITTER, align_mode = I2S.RIGHT_JUSTIFYING_MODE) tx.set_sample_rate (sample_rate) while True: audio = rx.record (256) #sampling points number must be smaller than 256 tx.play (audio) Routine 2 from Maix import I2S from Maix import Audio from Maix import FFT import time fm.register (20, fm.fpioa.I2S0_IN_D0) fm.register (19, fm.fpioa.I2S0_WS) fm.register (18, fm.fpioa.I2S0_SCLK) fm.register (34, fm.fpioa.I2S2_OUT_D1) fm.register (35, fm.fpioa.I2S2_SCLK) fm.register (33, fm.fpioa.I2S2_WS) rx = I2S (I2S.DEVICE_0) rx.channel_config (rx.CHANNEL_0, rx.RECEIVER, align_mode = I2S.STANDARD_MODE) rx.set_sample_rate (16000) tx = I2S (I2S.DEVICE_2) tx.channel_config (tx.CHANNEL_1, tx.TRANSMITTER, align_mode = I2S.RIGHT_JUSTIFYING_MODE) tx.set_sample_rate (16000) while True: audio = rx.record (256) audio_data = audio.to_bytes () play_audio = Audio (audio_data) tx.play (play_audio) powered by GitbookFile Modify: 2020-09-11 12:05:50 "},"libs/Maix/audio.html":{"url":"libs/Maix/audio.html","title":"Audio","keywords":"","body":"audio An abstract audio object that can be passed in as a parameter or use its methods to play audio directly Module functions Constructor Constructing an Audio object audio.Audio (array = None, path = None, points = 1024) parameters This interface can pass a parameter, each parameter will determine a different audio type array: data of typebytearray, which can be converted to audio objects, default None path: The path of the opened audio file, currently only supports thewav format. The default is None, Note The keywordspath, audio.Audio (\" / sd / 1.wav \" )This is wrong! !! audio.Audio (path =\" /sd/1.wav \") is correct points: open audio buffer with points sample points, one sample point size is 32bit. If it is 0, the buffer will not be opened. The default is 1024. return value Returns an Audio object to_bytes: bytes conversion function Converts audio data in an audio object to an object of type bytearray audio_data = test_audio.to_bytes () parameters no return value The returned audio data bytearray object play_process: Play preprocessing function It is used to preprocess audio objects, and audio files need to be parsed before playback, so preprocessing is required. Here you need to pass in an I2S device for playback wav_info = test_audio.play_process (i2s_dev) parameters i2s_dev: i2s device for playback return value Header information of the wav file, list type, which arenumchannels, samplerate,byterate, blockalign,bitspersample, datasize play: Play function Read audio files and parse them. Generally used in conjunction with loops. parameters no return value None: Format does not support playback 0: End of playback 1: Now playing finish: Audio post-processing functions Complete the audio playback. This function must be called after the playback is completed, and the underlying allocated resources are recycled. parameters no return value no Examples Play wav audio from fpioa_manager import * from Maix import I2S, GPIO import audio # disable wifi fm.register (8, fm.fpioa.GPIO0) wifi_en = GPIO (GPIO.GPIO0, GPIO.OUT) wifi_en.value (0) # register i2s (i2s0) pin fm.register (34, fm.fpioa.I2S0_OUT_D1) fm.register (35, fm.fpioa.I2S0_SCLK) fm.register (33, fm.fpioa.I2S0_WS) # init i2s (i2s0) wav_dev = I2S (I2S.DEVICE_0) # init audio player = audio.Audio (path = \"/sd/6.wav\") player.volume (40) # read audio info wav_info = player.play_process (wav_dev) print (\"wav file head information:\", wav_info) # config i2s according to audio info wav_dev.channel_config (wav_dev.CHANNEL_1, I2S.TRANSMITTER, resolution = I2S.RESOLUTION_16_BIT, cycles = I2S.SCLK_CYCLES_32, align_mode = I2S.RIGHT_JUSTIFYING_MODE) wav_dev.set_sample_rate (wav_info [1]) # loop to play audio while True: ret = player.play () if ret == None: print (\"format error\") break elif ret == 0: print (\"end\") break player.finish () powered by GitbookFile Modify: 2020-09-11 12:05:50 "},"libs/Maix/freq.html":{"url":"libs/Maix/freq.html","title":"freq","keywords":"","body":"Maix.freq Frequency module, support program to modify cpu and kpu frequency Method freq.set (cpu, pll1, kpu_div) Set cpu or kpu frequency, it will restart automatically after setting Please note that after the frequency setting is completed, some peripheral performance may be changed. from Maix import freq freq.set (cpu = 400, kpu = 400) The configuration file will be saved in the /flash/freq.conf file of the file system. Do not modify this file. If the file does not exist, it will be automatically created parameters Parameters not set will retain their previous values Note: If the cpu frequency setting is less than60MHz, the default REPL serial baud rate will be set to9600 cpu: The cpu frequency you want to set, the range is [26,600] (The chip has a maximum800 but has voltage requirements. The series supported by MaixPy do not support up to800, the default 400, different boards May behave differently, not recommended for stability pll1: Frequency ofpll1 output, value range [26,1200] (chip maximum 1800, MaixPy limited to 1200), default 400 kpu_div:kpu clock frequency divider. The value range is [1,16]. kpu frequency =pll1 / kpu_div. For example, if you want to set thekpu frequency to 400, you only need to setpll1 to 400 andkpu_div to 1. Note the kpu frequency range: [26,600] return value If the frequency does not change, it returns null. If the frequency changes, the machine will restart automatically. Please confirm whether the current situation can restart before using this interface freq.get () Get the currently set frequency parameters return value cpu frequency andkpu frequency, returned as a tuple, such as (400,400) freq.get_cpu () Get the current cpu frequency return value cpu frequency freq.get_kpu () Get the currently set kpu frequency return value Current kpu frequency powered by GitbookFile Modify: 2020-09-11 12:05:50 "},"libs/Maix/utils.html":{"url":"libs/Maix/utils.html","title":"utils","keywords":"","body":"Maix.utils gc_heap_size ([size]) Get or set the GC heap size. If you report insufficient memory, you can consider setting a larger size. Parameters None or Pass in a new GC heap size. If there is no parameter, just get the heap size; If there are parameters, set the heap size, and then restart automatically Return value GC heap size powered by GitbookFile Modify: 2020-09-11 12:05:50 "},"libs/builtin_py/":{"url":"libs/builtin_py/","title":"Built-in class","keywords":"","body":"Built-in class The library is a user-level interface that encapsulates the underlying classes of MaixPy, making it easy for users to use MaixPy, which includes the following: fpioa_manager board_info 需要注意的是， 这些类在开机启动的时候在 _boot.py 里面已经被导入了， 所以在串口终端可以直接使用， 但是， 如果是执行文件， 则需要手动写代码导入， 否则找不到类 Be attention, theses class imported at the start up by _boot.py, so we can directly use it in serial terminal without any import, but if we execute file, we need to import by ourselves~ from board import board_info from fpioa_manager import fm or from fpioa_manager import fm, board_info powered by GitbookFile Modify: 2020-09-11 12:05:50 "},"libs/builtin_py/fm.html":{"url":"libs/builtin_py/fm.html","title":"fpioa_manager","keywords":"","body":"FPIOA Manager fpioa_manager: referred to as fm, this module is used to register internal functions and pins of the chip, to help users manage internal functions and pins. If the functions and pins are already registered, the internal functions and pins will not be available. Actually fm is global variable define with Fpioa_Manager class, written by Micropython and integrated to firmware, source code see board.py method Registration function Register pins and functions fm.register(pin,function) Parameters This method must pass in 2 parameters, otherwise it will return a null value. pin: function mapping pin function : chip function return value This method has 2 return values. Parameter error returns None,None Set the success to return pin, function Setting fails to return reg_pin, reg_func, indicating the pins and functions that have been registered Logout function Logout pin and function fm.unregister(pin,function) Parameters This method can pass 1 or 2 parameters. When passing in 1 parameter, you need to add a parameter keyword. If it is 1 parameter, its pins and functions will be logged out. pin: function mapping pin function : chip function return value Parameter error returns None,None Set successfully returns pin, function, indicating the pin and function being logged out Set failure to return 0,0 Routine from fpioa_manager import fm, board_info fm.register(board_info.WIFI_RX,fm.fpioa.UART2_TX) fm.register(board_info.WIFI_RX,fm.fpioa.UART2_TX)#Register again fm.register(board_info.WIFI_RX,fm.fpioa.SPI0_SS0)#Register the same pin fm.register(board_info.WIFI_RX,fm.fpioa.SPI0_SS0)#Register the same function fm.unregister(board_info.WIFI_RX, fm.fpioa.UART2_TX)#Logout function and pin fm.register(board_info.WIFI_RX,fm.fpioa.UART2_TX) fm.unregister(function = fm.fpioa.UART2_TX)#Logout function fm.register(board_info.WIFI_RX,fm.fpioa.UART2_TX) fm.unregister(pin = board_info.WIFI_RX)#Logout pin Appendix The following pins have been registered when MaxiPy is powered on. Please pay attention to the user. SD card Function: SPI1_SCLK/SPI1_D0/SPI1_D1/GPIOHS7/SPI0_SS1 Pin: PIN25/PIN26/PIN27/PIN28/PIN29 LCD Function: SPI0_SS3/SPI0_SCLK/GPIOHS1/GPIOHS2 Pin: PIN36/PIN37/PIN38/PIN39 sensor Function: SCCB_SDA/SCCB_SCLK/CMOS_RST/CMOS_VSYNC/CMOS_PWDN/CMOS_HREF/CMOS_XCLK/CMOS_PCLK Pin: PIN40/PIN41/PIN42/PIN43/PIN44/PIN45/PIN46/PIN47 REPL Function: UARTHS_RX/UARTHS_TX Pin: PIN4/PIN5 powered by GitbookFile Modify: 2020-09-11 12:05:50 "},"libs/builtin_py/board_info.html":{"url":"libs/builtin_py/board_info.html","title":"board_info","keywords":"","body":"board_info board_info: Mainly used for user-friendly development board pin configuration, built-in user-friendly naming and interface, which allows users to reduce the dependence on the electrical connection schematic. board_info is a global variable defined with Board_Info class, written by MicroPython and integrated to firmware, source code see fpioa_manager.py Members Board_info has many pin indexes and a list pin_namelist The list is mainly used internally by the class, and the user does not operate it. Pin Index The pin index is mainly to convert numbers into human-friendly strings, which is convenient for users to program. Enter the following, please be careful not to ignore the . number, then press the tab key to complete, you can see the board-related pin functions. Board_info. For example, enter the following code, it will return the number 8, which represents the 8th pin of the development board, and its electrical connection is the enable pin of the wifi module. board_info.WIFI_EN method Search method When the user does not know the pin electrical connection, you can use this method to find Board_info.pin_map(pin_num) Parameters This method does not pass in parameters or pass in a parameter pin_num: pin number, range [6,47] Board-level electrical connection information for all pins will be printed when no parameters are passed in When the parameters are passed in, only the board-level electrical connection information for the specified pin is printed. return value Parameter error returns False Unknown error return False Find successful return information Routine Routine 1 from board import board_info Wifi_en_pin = board_info.WIFI_EN Print(wifi_en_pin)# output is 8 Board_info.pin_map()# print all Board_info.pin_map(8)# prints only pin 8 information powered by GitbookFile Modify: 2020-09-11 12:05:50 "},"libs/machine_vision/":{"url":"libs/machine_vision/","title":"Machine vision","keywords":"","body":"Machine vision It mainly contains classes related to images and displays, including: LCD Sensor Image powered by GitbookFile Modify: 2020-09-11 12:05:50 "},"libs/machine_vision/lcd.html":{"url":"libs/machine_vision/lcd.html","title":"lcd","keywords":"","body":"Lcd screen display driver function lcd.init(type=1, freq=15000000, color=lcd.BLACK) Initialize the LCD screen to display Parameters type: type of LCD (reserved for future use): 0: None 1: lcd shield (default) type is a key-value parameter that must be explicitly called by writing type= in the function call freq: frequency of lcd ( actually maybe SPI ) color： LCD initialized color, 16 bits RGB565 color, e.g. 0xFFFF; or RGB888 tuple, e.g. (236, 36, 36), default lcd.BLACK lcd.deinit() Unregister the LCD driver to release the I/O pins lcd.width() Returns the width of the LCD (horizontal resolution) lcd.height() Returns the height of the LCD (vertical resolution). lcd.type() Returns the type of LCD (reserved for future use): 0: None 1: lcd Shield lcd.freq(freq) Set or get frequency of LCD (SPI) Paremeters freq: frequency of LCD (SPI) Return frequency of LCD lcd.set_backlight(state) Setting the backlight status of LCD, turning off the backlight will greatly reduce the energy consumption of the LCD expansion board. //TODO: Not implemented Parameters state: backlight brightness, value [0,100] lcd.get_backlight() Return to backlight status return value Backlight brightness, value [0,100] lcd.display(image, roi=Auto) Display a image (GRAYSCALE or RGB565) on the LCD. Roi is a rectangular tuple (x, y, w, h) of a region of interest. If not specified, it is an image rectangle If the roi width is less than the lcd width, the vertical black border is used to make roi at the center of the screen (that is, fill the unoccupied area with black). If the roi width is greater than the lcd width, roi is at the center of the screen, and the unmatched pixels are not displayed (ie, the LCD displays the center of roi in window form). If the roi height is less than the lcd height, use a vertical black border to center roi in the center of the screen (ie fill the unoccupied area with black). If the roi height is greater than the lcd height, roi is at the center of the screen, and the unmatched pixels are not displayed (ie, the LCD displays the center of roi in window form). roi is a key-value parameter that must be explicitly called by writing roi= in a function call. lcd.clear() Empty the LCD screen to black or other color. Parameters color： LCD initialized color, 16 bits RGB565 color, e.g. 0xFFFF; or RGB888 tuple, e.g. (236, 36, 36) lcd.direction(dir) Set LCD direction and mirror parameters maybe change in the future Parameters dir： nomally lcd.YX_LRUD or lcd.YX_RLDU， other values just exchange XY or LR or DU Routine Routine 1: Display English import lcd lcd.init() lcd.draw_string(100, 100, \"hello maixpy\", lcd.RED, lcd.BLACK) Routine 2: Displaying pictures import lcd import image img = image.Image(\"/sd/pic.bmp\") lcd.display(img) Routine 3: Display English in the form of displaying pictures import lcd import image img = image.Image() img.draw_string(60, 100, \"hello maixpy\", scale=2) lcd.display(img) Routine 4: Real-time display of images captured by the camera import sensor, lcd sensor.reset() sensor.set_pixformat(sensor.RGB565) sensor.set_framesize(sensor.QVGA) sensor.run(1) sensor.skip_frames() lcd.init() while(True): lcd.display(sensor.snapshot()) powered by GitbookFile Modify: 2020-09-11 12:05:50 "},"libs/machine_vision/sensor.html":{"url":"libs/machine_vision/sensor.html","title":"sensor","keywords":"","body":"Sensor Sensor module for camera configuration and image capture, etc., used to control the development board camera to complete the camera task method Reset function Reset and initialize the camera. This will automatically scan and get the camera address sensor.reset([, freq=24000000[, set_regs=True[, dual_buff=False]]]) Parameters freq: Set the clock frequency of sensor. The higher the frequency, the higher the frame rate, but the picture quality may be worse. The default is 24MHz. If the camera has colored spots (ov7740), you can lower it appropriately, such as20MHz set_regs: Allows the program to write camera registers. The default isTrue. If you need a custom reset sequence, you can set it to False, and then use the sensor.__ write_reg(addr, value) function to customize the write register sequence dual_buff: The default isFalse.Allowing double buffering will increase the frame rate, but the memory footprint will also increase (about 384KiB) return value no Start function Start or stop the camera sensor.run(enbale) Parameters enbale: 1 means open, 0 means stop return value return: returns 1 Setting the frame size It is used to set the camera output frame size. The k210 supports VGA format at most. If it is larger than VGA, it will not be able to acquire images. The screen of the MaixPy development board is 320*240 resolution, and the recommended setting is QVGA format. sensor.set_framesize(framesize[, set_regs=True]) Parameters framesize: frame size set_regs: Allows the program to write camera registers. The default isTrue. If you need a custom sequence, you can set it to False, and then use the sensor.__ write_reg(addr, value) function to customize the write register sequence return value True : set successfully False: setting error Setting the frame format Used to set the camera output format, k210 supports rgb565 and yuv422 formats. The screen of the MaixPy development board configuration is set using rgb565, and the recommended setting is RGB565 format. sensor.set_pixformat(format[, set_regs=True]) Parameters format: frame format set_regs: Allows the program to write camera registers. The default isTrue. If you need a custom sequence, you can set it to False, and then use the sensor.__ write_reg(addr, value) function to customize the write register sequence return value True : set successfully False: setting error Starting image capture Turn on image capture sensor.run(enable) Parameters enable: 1 means start grabbing image 0 means stop grabbing image return value True : set successfully False: setting error Getting images Control camera capture image img = sensor.snapshot() Parameters no return value img: returned image object Close the camera Turn off the camera sensor.shutdown(enable) Parameters enable: 1 means to turn on the camera 0 means to turn off the camera return value no Frame skipping Skip the specified number of frames or skip the image for the specified time sensor.skip_frames(n, [, time]) Parameters n: skip n frame image time: Skip the specified time in ms return value no Resolution width Get camera resolution width sensor.width() Parameters no return value camera resolution width of int type Resolution Height sensor.height() Parameters no return value int type camera resolution height Get frame buffer Get the current frame buffer sensor.get_fb() Parameters no return value Object of type image Get ID Get the current camera ID sensor.get_id() Parameters no return value int type ID Setting color bar mode Set the camera to color bar mode sensor.set_colorbar(enable) Parameters enable: 1 means to turn on the color bar mode 0 means to turn off the color bar mode return value no Setting the contrast Set camera contrast sensor.set_contrast(contrast) Parameters constrast: camera contrast, range [-2, +2] return value True : set successfully False: setting error Setting brightness Set camera brightness sensor.set_brightness(brightness) Parameters constrast: camera brightness, range [-2, +2] return value True : set successfully False: setting error Setting the saturation Set camera saturation sensor.set_saturation(saturation) Parameters constrast: camera saturation, range [-2, +2] return value True : set successfully False: setting error Setting automatic gain Set the camera automatic gain mode sensor.set_auto_gain(enable,gain_db) Parameters enable: 1 means to turn on automatic gain 0 means to turn off automatic gain gain_db: Set the camera fixed gain value when the auto gain is turned off, the unit is db return value no Get the gain value Get camera gain value sensor.get_gain_db() Parameters no return value Gain value of float type Setting up horizontal mirroring Set the camera horizontal mirror sensor.set_hmirror(enable) Parameters enable: 1 means to turn on horizontal mirroring 0 to turn off horizontal mirroring return value no Write register Write the specified value to the camera register sensor.__write_reg(address, value) Parameters address: register address value : write value return value no Read register Read camera register value sensor.__read_reg(address) Parameters address: register address return value Register value of type int Routine Routine 1 import sensor import lcd lcd.init() sensor.reset() sensor.set_pixformat(sensor.RGB565) sensor.set_framesize(sensor.QVGA) sensor.run(1) while 1: img = sensor.snapshot() lcd.display(img) powered by GitbookFile Modify: 2020-09-11 12:05:50 "},"libs/machine_vision/image.html":{"url":"libs/machine_vision/image.html","title":"image","keywords":"","body":"Image — machine vision Ported in openmv, same as openmv Routine Routine 1: Find green import sensor import image import lcd import time lcd.init() sensor.reset() sensor.set_pixformat(sensor.RGB565) sensor.set_framesize(sensor.QVGA) sensor.run(1) green_threshold = (0, 80, -70, -10, -0, 30) while True: img=sensor.snapshot() blobs = img.find_blobs([green_threshold]) if blobs: for b in blobs: tmp=img.draw_rectangle(b[0:4]) tmp=img.draw_cross(b[5], b[6]) c=img.get_pixel(b[5], b[6]) lcd.display(img) Routine 2: Display fps import sensor import image import lcd import clock clock = clock.clock() lcd.init() sensor.reset() sensor.set_pixformat(sensor.RGB565) sensor.set_framesize(sensor.QVGA) sensor.run(1) sensor.skip_frames(30) while True: clock.tick() img = sensor.snapshot() fps =clock.fps() img.draw_string(2,2, (\"%2.1ffps\" %(fps)), color=(0,128,0), scale=2) lcd.display(img) Routine 3: Scan QR code import sensor import image import lcd import clock clock = clock.clock() lcd.init() sensor.reset() sensor.set_pixformat(sensor.RGB565) sensor.set_framesize(sensor.QVGA) sensor.set_vflip(1) sensor.run(1) sensor.skip_frames(30) while True: clock.tick() img = sensor.snapshot() res = img.find_qrcodes() fps =clock.fps() if len(res) > 0: img.draw_string(2,2, res[0].payload(), color=(0,128,0), scale=2) print(res[0].payload()) lcd.display(img) If the lens is used, the picture will be distorted and the picture needs to be corrected. Use the lens_corr function to correct, such as 2.8mm, img.lens_corr(1.8) function The function can also press Ctrl+F on the page to search for functions using the browser's search function search image. image.rgb_to_lab(rgb_tuple) Returns the tuple (l, a, b) of the LAB format corresponding to the tuple rgb_tuple (r, g, b) in RGB888 format. RGB888 refers to 8 bits (0-255) of red, green and blue. In LAB, L has a value range of 0-100, and a/b ranges from -128 to 127. image.lab_to_rgb(lab_tuple) Returns the tuple (r, g, b) of the RGB888 format corresponding to the tuple lab_tuple (l, a, b) in LAB format. RGB888 refers to 8 bits (0-255) of red, green and blue. In LAB, L has a value range of 0-100, and a/b ranges from -128 to 127. image.rgb_to_grayscale(rgb_tuple) Returns the gray value corresponding to the tuple rgb_tuple (r, g, b) in RGB888 format. RGB888 refers to 8 bits (0-255) of red, green and blue. The gray value is from 0 to 255. image.grayscale_to_rgb(g_value) Returns the tuple (r, g, b) of the RGB888 format corresponding to the gray value g_value. RGB888 refers to 8 bits (0-255) of red, green and blue. The gray value is from 0 to 255. image.load_decriptor(path) Load a descriptor object from the disk. Path is the path where the descriptor file is saved. image.save_descriptor(path, descriptor) Save the descriptor object descriptor to disk. Path is the path where the descriptor file is saved. image.match_descriptor(descritor0, descriptor1[, threshold=70[, filter_outliers=False]]) For the LBP descriptor, this function returns an integer that represents the difference between the two descriptors. This distance measurement is especially necessary. This distance is a measure of similarity. The closer this measure is to 0, the better the LBPF feature points will match. For the ORB descriptor, this function returns the kptmatch object. See above. Threshold is used to filter the ambiguous matching service for the ORB keypoint. A lower threshold value will be tied to the keypoint matching algorithm. The threshold value is at 0-100 (int). The default is 70. Filter_outliers is used to filter outliers for ORB keypoints. Feature points allow the user to increase the threshold value. The default setting is False. HaarCascade Class – Feature Descriptors The Haar Cascade feature descriptor is used for the image.find_features() method. It has no methods for the user to call. Constructor Class image.HaarCascade(path[, stages=Auto]) Load a Haar Cascade from a Haar Cascade binary (a format suitable for OpenMV Cam). If you pass a \"frontalface\" string instead of a path, this constructor will load a built-in positive face Haar Cascade into memory. In addition, you can also load Haar Cascade into memory via \"eye\". Finally, this method returns the loaded Haar Cascade object, which is used to use image.find_features() . The stage default is the number of stages in Haar Cascade. However, you can specify a lower value to speed up the running of the feature detector, which of course leads to a higher false positive rate. You can make your own Haar Cascades to work with your OpenMV Cam. First, use Google search \" Haar Cascade\" to check if someone has created OpenCV Haar Cascade for the object you want to detect. If not, you need to do it yourself (the amount of work is huge). For information on how to make your own Haar Cascade, see here on how to turn OpenCV Haar Cascades into a mode that your OpenMV Cam can read, see this script Q: What is Haar Cascade? A: Haar Cascade is a series of comparison checks used to determine if an object is present in an image. This series of comparison checks is divided into phases, and the operation of the latter phase is premised on the completion of the previous phase. Contrast checks are not complicated, but are like processes that check if the center of the image is slightly more vertical than the edges. A wide range of inspections are carried out first in the early stages, and more small area inspections are carried out later. Q: How was Haar Cascades made? A: Haar Cascades trains generator algorithms with positive and negative images. For example, use hundreds of pictures containing cats (marked as containing cats) and hundreds of pictures that do not contain cats (have been marked differently) to train this generation algorithm. This generation algorithm will eventually generate a Haar Cascades for detecting cats. Similarity Class – Similarity Object The similarity object is returned by image.get_similarity. Constructor Class image.similarity Call the image.get_similarity() function to create this object. 方法 similarity.mean() Returns the mean of the similarity difference in 8x8 pixel block structure. Range [-1/+1], where -1 is completely different and +1 is identical. You can also get this value via index [0]. similarity.stdev() Returns the standard deviation of the 8x8 pixel block structure similarity difference. You can also get this value via index [1]. similarity.min() Returns the minimum value of the 8x8 pixel block structure similarity difference. Where -1 is completely different and +1 is identical. You can also get this value via index [2]. By looking at this value, you can quickly determine if any 8x8 pixel blocks between the two images are very different, which is much lower than +1. similarity.max() Returns the minimum value of the 8x8 pixel block structure similarity difference. Where -1 is completely different and +1 is identical. You can also get this value via index [3]. By looking at this value, you can quickly determine if any 8x8 pixel blocks between the two images are the same. That is much larger than -1. Histogram Class – Histogram Object The histogram object is returned by image.get_histogram. A grayscale histogram has a channel that contains multiple binaryes. All binaries are normalized to a total of one. RGB565 has three channels with multiple binary. All binaries are normalized to a total of one. Constructor Class image.histogram Please call the image.get_histogram() function to create this object. 方法 histogram.bins() Returns a list of floating point numbers for the grayscale histogram. You can also get this value via index [0]. histogram.l_bins() Returns a list of floating point numbers for the L channel of the RGB565 histogram LAB. You can also get this value via index [0]. histogram.a_bins() Returns a list of floating point numbers for the A channel of the RGB565 histogram LAB. You can also get this value via index [1]. histogram.b_bins() Returns a list of floating point numbers for the B channel of the RGB565 histogram LAB. You can also get this value via index [2]. histogram.get_percentile(percentile) Calculates the CDF of the histogram channel, returning a value that passes the histogram in percentile (0.0 - 1.0) (floating point). Therefore, if you pass in 0.1, this method will tell you which binary will cause the accumulator to cross 0.1 when accumulating the accumulator. This is effective for determining the minimum (0.1) and max(0.9) of the color distribution when there is no anomalous utility to corrupt your adaptive color tracking results. histogram.get_threhsold() Use the Otsu’s method to calculate the optimal threshold, dividing each channel of the histogram into two halves. This method returns an image.threshold object. This method is especially useful for determining the best image.binary() threshold. histogram.get_statistics() Calculates the mean, median, value, standard deviation, minimum, maximum, lower quartile, and upper quartile for each color channel in the histogram and returns a statistics object. You can also use histogram.statistics() and histogram.get_stats() as aliases for this method. Percentile Class – Percentage Value Object The percentage value object is returned by histogram.get_percentile. The grayscale value has one channel. Do not use the l* , a , or b_ methods. The RGB565 percentage value has three channels. Use the l* , a , and b_ methods. Constructor Class image.percentile Call the histogram.get_percentile() function to create this object. 方法 percentile.value() Returns the grayscale percentage value (value range 0-255). You can also get this value via index [0]. percentile.l_value() Returns the percentage value of the L channel of the RGB565 LAB (value range is 0-100). You can also get this value via index [0]. percentile.a_value() Returns the percentage value of the A channel of the RGB565 LAB (value range -128-127). You can also get this value via index [1]. percentile.b_value() Returns the percentage value of the B channel of the RGB565 LAB (value range -128-127). You can also get this value via index [2]. Threhsold Class – Threshold Object The threshold object is returned by histogram.get_threshold. The grayscale image has a channel. There are no l*, a, and b_ methods. The RGB565 threshold has three channels. Use the l*, a, and b_ methods. Constructor Class image.threshold Call the histogram.get_threshold() function to create this object. 方法 threhsold.value() Returns the threshold of the grayscale image (between 0 and 255). You can also get this value via index [0]. threhsold.l_value() Returns the L threshold in RGB565 map LAB (between 0 and 100). You can also get this value via index [0]. threhsold.a_value() Returns the A threshold in the RGB565 graph LAB (between -128 and 127). You can also get this value via index [1]. threhsold.b_value() Returns the B threshold in RGB565 map LAB (between -128 and 127). You can also get this value via index [2]. class Statistics – Statistics Object The statistics object is returned by histogram.get_statistics or image.get_statistics. Grayscale statistics have one channel, using non-l*, a, or b_ methods. The RGB565 percentage value has three channels. Use the l* , a , and b_ methods. Constructor Class image.statistics Call the histogram.get_statistics() or image.get_statistics() function to create this object. 方法 statistics.mean() Returns the grayscale mean (0-255) (int). You can also get this value via index [0]. statistics.median() Returns the gray value median (0-255) (int). You can also get this value via index [1]. statistics.mode() Returns the gray level value (0-255) (int). You can also get this value via index [2]. statistics.stdev() Returns the gray standard deviation (0-255) (int). You can also get this value via index [3]. statistics.min() Returns the minimum gray level (0-255) (int). You can also get this value via index [4]. statistics.max() Returns the grayscale maximum (0-255) (int). You can also get this value via index [5]. statistics.lq() Returns the quarter value (0-255) (int) under gray. You can also get this value via index [6]. statistics.uq() Returns the grayscale upper quartile (0-255) (int). You can also get this value via index [7]. statistics.l_mean() Returns the mean (0-255) (int) of L in RGB5656 LAB. You can also get this value via index [0]. statistics.l_median() Returns the median (0-255) (int) of L in RGB5656 LAB. You can also get this value via index [1]. statistics.l_mode() Returns the value of L (0-255) (int) in RGB5656 LAB. You can also get this value via index [2]. statistics.l_stdev() Returns the standard deviation value (0-255) (int) of L in RGB5656 LAB. You can also get this value via index [3]. statistics.l_min() Returns the minimum value (0-255) (int) of L in RGB5656 LAB. You can also get this value via index [4]. statistics.l_max() Returns the maximum value (0-255) (int) of L in RGB5656 LAB. You can also get this value via index [5]. statistics.l_lq() Returns the lower quartile (0-255) (int) of L in RGB5656 LAB. You can also get this value via index [6]. statistics.l_uq() Returns the upper quartile (0-255) (int) of L in RGB5656 LAB. You can also get this value via index [7]. statistics.a_mean() Returns the mean (0-255) (int) of A in RGB5656 LAB. You can also get this value via index [8]. statistics.a_median() Returns the median (0-255) (int) of A in RGB5656 LAB. You can also get this value via index [9]. statistics.a_mode() Returns the value of A (0-255) (int) in RGB5656 LAB. You can also get this value via index [10]. statistics.a_stdev() Returns the standard deviation value (0-255) (int) of A in RGB5656 LAB. You can also get this value via index [11]. statistics.a_min() Returns the minimum value (0-255) (int) of A in RGB5656 LAB. You can also get this value via index [12]. statistics.a_max() Returns the maximum value (0-255) (int) of A in RGB5656 LAB. You can also get this value via index [13]. statistics.a_lq() Returns the lower quartile (0-255) (int) of A in RGB5656 LAB. You can also get this value via index [14]. statistics.a_uq() Returns the upper quartile (0-255) (int) of A in RGB5656 LAB. You can also get this value via index [15]. statistics.b_mean() Returns the mean (0-255) (int) of B in RGB5656 LAB. You can also get this value via index [16]. statistics.b_median() Returns the median (0-255) (int) of B in RGB5656 LAB. You can also get this value via index [17]. statistics.b_mode() Returns the value of B (0-255) (int) in RGB5656 LAB. You can also get this value via index [18]. statistics.b_stdev() Returns the standard deviation (0-255) (int) of B in RGB5656 LAB. You can also get this value via index [19]. statistics.b_min() Returns the minimum value (0-255) (int) of B in RGB5656 LAB. You can also get this value via index [20]. statistics.b_max() Returns the maximum value (0-255) (int) of B in RGB5656 LAB. You can also get this value via index [21]. statistics.b_lq() Returns the lower quartile (0-255) (int) of B in RGB5656 LAB. You can also get this value via index [22]. statistics.b_uq() Returns the upper quartile (0-255) (int) of B in RGB5656 LAB. You can also get this value via index [23]. Blob class – color block object The patch object is returned by image.find_blobs. Constructor Class image.blob Call the image.find_blobs() function to create this object. 方法 blob.rect() Returns a rectangular tuple (x, y, w, h) for other image methods such as image.draw_rectangle of the color block bounding box. blob.x() Returns the x coordinate (int) of the bounding box of the patch. You can also get this value via index [0]. blob.y() Returns the y coordinate (int) of the bounding box of the patch. You can also get this value via index [1]. blob.w() Returns the w coordinate (int) of the bounding box of the patch. You can also get this value via index [2]. blob.h() Returns the h coordinate (int) of the bounding box of the patch. You can also get this value via index [3]. blob.pixels() Returns the number of pixels subordinate to a part of the int. You can also get this value via index [4]. blob.cx() Returns the center x position of the color block (int). You can also get this value via index [5]. blob.cy() Returns the center x position of the color block (int). You can also get this value via index [6]. blob.rotation() Returns the rotation of the patch (in radians). If the color block is similar to a pencil or pen, then this value is a unique value between 0-180. If the color block is round, then this value has no effect. If this color block is completely symmetrical, you can only get a 0-360 degree rotation. You can also get this value via index [7]. blob.code() Returns a 16-bit binary number with one bit set for each color threshold, which is part of the color block. For example, if you look for three color thresholds via image.find_blobs, this color block can be set to 0/1/2 digits. Note: You can only set one bit per color block unless you call image.find_blobs with merge=True . Then multiple color patches with different color thresholds can be merged together. You can also use this method and multiple thresholds to implement color code tracking. You can also get this value via index [8]. blob.count() Returns the number of multiple patches that are merged into this patch. This number is not 1 only if you call image.find_blobs with merge=True. You can also get this value via index [9]. blob.area() Returns the border area around the patch (w * h) blob.density() Returns the density ratio of this patch. This is the number of pixels in the bounding box area of ​​the patch. In general, a lower density ratio means that the object is not locked well. Line Class – Straight Line Object Line objects are returned by image.find_lines , image.find_line_segments or image.get_regression. Constructor Class image.line Call the image.find_lines(), image.find_line_segments(), or image.get_regression() function to create this object. 方法 line.line() Returns a line tuple (x1, y1, x2, y2) for use with other image methods such as image.draw_line . line.x1() Returns the p1 vertex x coordinate component of the line. You can also get this value via index [0]. line.y1() Returns the p1 y component of the line. You can also get this value via index [1]. line.x2() Returns the p2 x component of the line. You can also get this value via index [2]. line.y2() Returns the p2 y component of the line. You can also get this value via index [3]. line.length() Returns the length of the line ie sqrt(((x2-x1)^2) + ((y2-y1)^2). You can also get this value via index [4]. line.magnitude() Returns the length of the line after the Hough transform. You can also get this value via index [5]. line.theta() Returns the angle of the line after the Hough transform (0-179 degrees). You can also get this value via index [7]. line.rho() Returns the p value of the line after the Hough transform. You can also get this value via index [8]. CircleClass - Round Object The circular object is returned by image.find_circles. Constructor Class image.circle Call the image.find_circles() function to create this object. 方法 circle.x() Returns the x position of the circle. You can also get this value via index [0]. circle.y() Returns the y position of the circle. You can also get this value via index [1]. circle.r() Returns the radius of the circle. You can also get this value via index [2]. circle.magnitude() Returns the size of the circle. You can also get this value via index [3]. Rect class – rectangular object The rectangle object is returned by image.find_rects. Constructor Class image.rect Call the image.find_rects() function to create this object. 方法 rect.corners() Returns a list of four tuples (x, y) consisting of the four corners of a rectangular object. The four corners are usually returned in a clockwise order starting from the upper left corner. rect.rect() Returns a rectangular tuple (x, y, w, h) for other image methods such as image.draw_rectangle of the bounding box of the rectangle. rect.x() Returns the x position of the top left corner of the rectangle. You can also get this value via index [0]. rect.y() Returns the y position of the top left corner of the rectangle. You can also get this value via index [1]. rect.w() Returns the width of the rectangle. You can also get this value via index [2]. rect.h() Returns the height of the rectangle. You can also get this value via index [3]. rect.magnitude() Returns the size of the rectangle. You can also get this value via index [4]. QRCode Class – QR Code Object The QR code object is returned by image.find_qrcodes. Constructor Class image.qrcode Call the image.find_qrcodes() function to create this object. 方法 qrcode.corners() Returns a list of four tuples (x, y) consisting of the four corners of the object. The four corners are usually returned in a clockwise order starting from the upper left corner. qrcode.rect() Returns a rectangular tuple (x, y, w, h) for other image methods such as image.draw_rectangle of the bounding box of the QR code. qrcode.x() Returns the x coordinate (int) of the bounding box of the QR code. You can also get this value via index [0]. qrcode.y() Returns the y coordinate (int) of the bounding box of the QR code. You can also get this value via index [1]. qrcode.w() Returns the w coordinate (int) of the bounding box of the QR code. You can also get this value via index [2]. qrcode.h() Returns the h coordinate (int) of the bounding box of the QR code. You can also get this value via index [3]. qrcode.payload() Returns a string of the QR code payload, such as a URL. You can also get this value via index [4]. qrcode.version() Returns the version number (int) of the QR code. You can also get this value via index [5]. qrcode.ecc_level() Returns the ECC level (int) of the QR code. You can also get this value via index [6]. qrcode.mask() Returns the mask (int) of the QR code. You can also get this value via index [7]. qrcode.data_type() Returns the data type of the QR code. You can also get this value via index [8]. qrcode.eci() Returns the ECI of the QR code. The ECI stores the code for storing the data bytes in the QR code. If you want to process a QR code that contains more than standard ASCII text, you need to look at this value. You can also get this value via index [9]. qrcode.is_numeric() Returns True if the data type of the QR code is numeric. qrcode.is_alphanumeric() Returns True if the data type of the QR code is alphanumeric. qrcode.is_binary() Returns True if the data type of the QR code is binary. If you are dealing with all types of text carefully, you need to check if eci is True to determine the text encoding of the data. Usually it's just standard ASCII, but it could also be UTF8 with two byte characters. qrcode.is_kanji() Returns True if the data type of the QR code is Japanese Kanji. When set to True, you need to decode the string yourself, because the Japanese character is 10 digits per character, and MicroPython does not support parsing such text. AprilTag类 – AprilTag object The AprilTag object is returned by image.find_apriltags. Constructor Class image.apriltag Call the image.find_apriltags() function to create this object. 方法 apriltag.corners() Returns a list of four tuples (x, y) consisting of the four corners of the object. The four corners are usually returned in a clockwise order starting from the upper left corner. apriltag.rect() Returns a rectangular tuple (x, y, w, h) for other image methods such as image.draw_rectangle of the AprilTag bounding box. apriltag.x() Returns the x coordinate (int) of the AprilTag bounding box. You can also get this value via index [0]. apriltag.y() Returns the y coordinate (int) of the AprilTag bounding box. You can also get this value via index [1]. apriltag.w() Returns the w coordinate (int) of the AprilTag bounding box. You can also get this value via index [2]. apriltag.h() Returns the h coordinate (int) of the AprilTag bounding box. You can also get this value via index [3]. apriltag.id() Returns the numeric ID of the AprilTag. TAG16H5 -> 0 to 29 TAG25H7 -> 0 to 241 TAG25H9 -> 0 to 34 TAG36H10 -> 0 to 2319 TAG36H11 -> 0 to 586 ARTOOLKIT -> 0 to 511 You can also get this value via index [4]. apriltag.family() Return to the digital family of AprilTag. image.TAG16H5 image.TAG25H7 image.TAG25H9 image.TAG36H10 image.TAG36H11 image.ARTOOLKIT You can also get this value via index [5]. apriltag.cx() Returns the center x position (int) of the AprilTag. You can also get this value via index [6]. apriltag.cy() Returns the center y position (int) of the AprilTag. You can also get this value via index [7]. apriltag.rotation() Returns the curl (int) of the AprilTag in radians. You can also get this value via index [8]. apriltag.decision_margin() Returns the color saturation of the AprilTag match (values ​​0.0 - 1.0), where 1.0 is optimal. You can also get this value via index [9]. apriltag.hamming() Returns the acceptable digit error value for the AprilTag. TAG16H5 -> accepts up to 0 bit errors TAG25H7 -> accepts up to 1 bit error TAG25H9 -> accepts up to 3 bit errors TAG36H10 -> accepts up to 3 bit errors TAG36H11 -> accepts up to 4 errors ARTOOLKIT -> accepts up to 0 bit errors You can also get this value via index [10]. apriltag.goodness() Returns the color saturation of the AprilTag image (value 0.0 - 1.0), where 1.0 is optimal. Currently this value is usually 0.0. In the future, we can enable a feature called \"tag refinement\" to achieve detection of smaller AprilTag. However, this feature now reduces the frame rate below 1 FPS. You can also get this value via index [11]. apriltag.x_translation() Returns the transformation from the x direction of the camera. The unit of distance is unknown. This method is useful for determining the position of the AprilTag away from the camera. However, the size of the AprilTag and the factors you use will affect the determination of the X unit ownership. For ease of use, we recommend that you use a lookup table to convert the output of this method into information that is useful to your application. Note: The direction here is from left to right. You can also get this value via index [12]. apriltag.y_translation() Returns the transformation from the y direction of the camera, the unit of distance is unknown. This method is useful for determining the position of the AprilTag away from the camera. However, the size of the AprilTag and the factors you use will affect the determination of the Y unit ownership. For ease of use, we recommend that you use a lookup table to convert the output of this method into information that is useful to your application. Note: The direction here is from top to bottom. You can also get this value via index [13]. apriltag.z_translation() Returns the transformation from the camera's z direction, the unit of distance is unknown. This method is useful for determining the position of the AprilTag away from the camera. However, factors such as the size of the AprilTag and the lens you are using will affect the determination of the Z-unit attribution. For ease of use, we recommend that you use a lookup table to convert the output of this method into information that is useful to your application. Note: The direction here is from front to back. You can also get this value via index [14]. apriltag.x_rotation() Returns the curl of the AprilTag in radians on the X plane. Example: Visually see the AprilTag and move the camera from left to right. You can also get this value via index [15]. apriltag.y_rotation() Returns the curl of the AprilTag in radians on the Y plane. Example: Visualize the AprilTag and move the camera from top to bottom. You can also get this value via index [16]. apriltag.z_rotation() Returns the curl of the AprilTag in radians on the Z plane. Example: Visualize the AprilTag and rotate the camera. Note: This is just a renamed version of apriltag.rotation(). You can also get this value via index [17]. DataMatrix Class – Data Matrix Object The data matrix object is returned by image.find_datamatrices. Constructor Class image.datamatrix Call the image.find_datamatrices() function to create this object. 方法 datamatrix.corners() Returns a list of four tuples (x, y) consisting of the four corners of the object. The four corners are usually returned in a clockwise order starting from the upper left corner. datamatrix.rect() Returns a rectangular tuple (x, y, w, h) for other image methods such as image.draw_rectangle of the bounding box of the data matrix. datamatrix.x() Returns the x coordinate (int) of the bounding box of the data matrix. You can also get this value via index [0]. datamatrix.y() Returns the y coordinate (int) of the bounding box of the data matrix. You can also get this value via index [1]. datamatrix.w() Returns the w width of the bounding box of the data matrix. You can also get this value via index [2]. datamatrix.h() Returns the h height of the bounding box of the data matrix. You can also get this value via index [3]. datamatrix.payload() Returns a string of payloads for the data matrix. Example: String. You can also get this value via index [4]. datamatrix.rotation() Returns the curl (float) of the data matrix in radians. You can also get this value via index [5]. datamatrix.rows() Returns the number of rows (int) of the data matrix. You can also get this value via index [6]. datamatrix.columns() Returns the number of columns (int) of the data matrix. You can also get this value via index [7]. datamatrix.capacity() Returns the number of characters this data matrix can hold. You can also get this value via index [8]. datamatrix.padding() Returns the number of unused characters in this data matrix. You can also get this value via index [9]. BarCode Class – Barcode Object The barcode object is returned by image.find_barcodes. Constructor Class image.barcode Call the image.find_barcodes() function to create this object. 方法 barcode.corners() Returns a list of four tuples (x, y) consisting of the four corners of the object. The four corners are usually returned in a clockwise order starting from the upper left corner. barcode.rect() Returns a rectangular tuple (x, y, w, h) for other image methods such as image.draw_rectangle of the bounding box of the data matrix. barcode.x() Returns the x coordinate (int) of the bounding box of the barcode. You can also get this value via index [0]. barcode.y() Returns the y coordinate (int) of the bounding box of the barcode. You can also get this value via index [1]. barcode.w() Returns the w width (int) of the bounding box of the barcode. You can also get this value via index [2]. barcode.h() Returns the h height (int) of the bounding box of the barcode. You can also get this value via index [3]. barcode.payload() Returns a string of the payload of the barcode. Example: Quantity. You can also get this value via index [4]. barcode.type() Returns the enumerated type (int) of the barcode. You can also get this value via index [5]. image.EAN2 image.EAN5 image.EAN8 image.UPCE image.ISBN10 image.UPCA image.EAN13 image.ISBN13 image.I25 image.DATABAR image.DATABAR_EXP image.CODABAR image.CODE39 image.PDF417 - Enable in the future (e.g. is not working properly now). image.CODE93 image.CODE128 barcode.rotation() Returns the curl (floating point) of the barcode in radians. You can also get this value via index [6]. barcode.quality() Returns the number of times the barcode was detected in the image (int). When scanning a barcode, each new scan line can decode the same barcode. Each time this process is performed, the value of the barcode will increase. You can also get this value via index [7]. Displacement class – displacement object The displacement object is returned by image.find_displacement. Constructor Class image.displacement Call the image.find_displacement() function to create this object. 方法 displacement.x_translation() Returns an x ​​translation pixel between two images. This is a precise subpixel, so it is a floating point number. You can also get this value via index [0]. displacement.y_translation() Returns the y translation pixel between the two images. This is a precise subpixel, so it is a floating point number. You can also get this value via index [1]. displacement.rotation() Returns the z translation pixel between the two images. This is a precise subpixel, so it is a floating point number. You can also get this value via index [2]. displacement.scale() Returns the arc of rotation between two images. You can also get this value via index [3]. displacement.response() Returns the quality of the displacement match between the two images. Range 0-1. A displacement object with a response of less than 0.1 may be noise. You can also get this value via index [4]. Kptmatch class – feature point object The feature point object is returned by image.match_descriptor. Constructor Class image.kptmatch Please call the image.match_descriptor() function to create this object. 方法 kptmatch.rect() Returns a rectangular tuple (x, y, w, h) for other image methods such as image.draw_rectangle of the bounding box of the feature point. kptmatch.cx() Returns the center x position (int) of the feature point. You can also get this value via index [0]. kptmatch.cy() Returns the center y position (int) of the feature point. You can also get this value via index [1]. kptmatch.x() Returns the x coordinate (int) of the bounding box of the feature point. You can also get this value via index [2]. kptmatch.y() Returns the y coordinate (int) of the bounding box of the feature point. You can also get this value via index [3]. kptmatch.w() Returns the w width (int) of the feature point bounding box. You can also get this value via index [4]. kptmatch.h() Returns the h height (int) of the feature point bounding box. You can also get this value via index [5]. kptmatch.count() Returns the number of matching feature points (int). You can also get this value via index [6]. kptmatch.theta() Returns the curl of the estimated feature point (int). You can also get this value via index [7]. kptmatch.match() Returns a list of (x,y) tuples that match the key. You can also get this value via index [8]. ImageWriterClass – ImageWriter Object The ImageWriter object allows you to quickly write uncompressed images to disk. Constructor Class image.ImageWriter(path) Create an ImageWriter object and you can write uncompressed images to disk in a simple file format for OpenMV Cams. The uncompressed image can then be re-read using ImageReader. method imagewriter.size() Returns the size of the file being written. imagewriter.add_frame(img) Write an image to disk. Because the image is not compressed, it performs quickly but takes up a lot of disk space. imagewriter.close() Close the image stream file. You must close the file or the file will be corrupted. ImageReader Class – ImageReader Object The ImageReader object allows you to quickly read uncompressed images from disk. Constructor Class image.ImageReader(path) Create an ImageReader object to play back the image data written by the ImageWriter object. Frames played back by the ImageWriter object are played back under the same FPS as when writing to disk. method imagereader.size() Returns the size of the file being read. Imagereader.next_frame([copy_to_fb=True, loop=True]) Returns an image object from a file written by ImageWriter. If copy_to_fb is True, the image object will be loaded directly into the frame buffer. Otherwise the image object will be placed in the heap. Note: Unless the image is small, the heap may not have enough space to store the image object. If loop is True, playback will resume after the last image of the stream has been read. Otherwise, this method will return None after all frames have been read. Note: imagereader.next_frame attempts to limit the playback speed by pausing playback after reading the frame to match the speed of the frame recording. Otherwise, this method will play all images at a speed of 200+FPS. imagereader.close() Close the file being read. You need to do this to prevent the imagereader object from being damaged. However, since it is a read-only file, the file will not be damaged when it is not closed. ImageClass - Image Object Image objects are the basic objects of machine vision operations. Constructor Class image.Image(path[, copy_to_fb=False]) Create a new image object from the file in path. Support image files in bmp/pgm/ppm/jpg/jpeg format. If copy_to_fb is True, the image will be loaded directly into the framebuffer and you can load large images. If False, the image will be loaded into the MicroPython heap, which is much smaller than the frame buffer. In OpenMV Cam M4, if copy_to_fb is False, you should try to keep the image size below 8KB. If True, the image can be up to 160KB. In OpenMV Cam M7, if copy_to_fb is False, you should try to keep the image size below 16KB. If True, the image can be up to 320KB. The image supports the \"[]\" notation. Let image[index] = 8/16-bit value to assign image pixels or image[index] and get an image pixel. If it is a grayscale image of 16-bit RGB565 value for RGB image, this pixel is 8 Bit. For JPEG images, \"[]\" gives you access to JPEG image patches in the form of compressed section arrays. Since JPEG images are in the form of compressed byte streams, reading and writing of data sets is opaque. The image also supports read buffer operations. You can use the image as a section array object and enter the image into all types of MicroPython functions. If you want to transfer an image, you can pass it to the UART / SPI / I2C write function for automatic transfer. method image.width() Returns the width of the image in pixels. image.height() Returns the height of the image in pixels. image.format() Returns sensor.GRAYSCALE for grayscale images, sensor.RGB565 for RGB images, and sensor.JPEG for JPEG images. image.size() Returns the image size in bytes. image.get_pixel(x, y[, rgbtuple]) Grayscale: Returns the grayscale pixel value at the (x, y) position. RGB565l: Returns the RGB888 pixel tuple (r, g, b) at the (x, y) position. Bayer image: Returns the pixel value at the (x, y) position. Compressed images are not supported. image.get_pixel() and image.set_pixel() are the only ways you can manipulate Bayer mode images. The Bayer pattern image is a text image. For even rows, where the pixels in the image are R/G/R/G/ and so on. For odd lines, where the pixels in the image are G/B/G/B/etc. Each pixel is 8 bits. image.set_pixel(x, y, pixel) Grayscale: Set the pixel at the (x, y) position to the grayscale value pixel . RGB image: Set the pixel at the (x, y) position to RGB888 tuple (r, g, b) pixel . Compressed images are not supported. image.get_pixel() and image.set_pixel() are the only ways you can manipulate Bayer mode images. The Bayer pattern image is a text image. For even rows, where the pixels in the image are R/G/R/G/ and so on. For odd lines, where the pixels in the image are G/B/G/B/etc. Each pixel is 8 bits. image.mean_pool(x_div, y_div) Find the average of the x_div * y_div squares in the image and return a modified image consisting of the average of each square. This method allows you to quickly reduce the image on the original image. Compressed images and bayer images are not supported. image.mean_pooled(x_div, y_div) Find the average of the x_div * y_div squares in the image and return a new image consisting of the average of each square. This method allows you to create a reduced copy of the image. Compressed images and bayer images are not supported. image.midpoint_pool(x_div, y_div[, bias=0.5]) Finds the midpoint value of the x_div * y_div square in the image and returns a modified image consisting of the midpoint values ​​of each square. Bias is 0.0 to return the minimum value for each region, and bias is 1.0 to return the maximum value for each region. This method allows you to quickly reduce the image on the original image. Compressed images and bayer images are not supported. image.midpoint_pooled(x_div, y_div[, bias=0.5]) Finds the midpoint value of the x_div * y_div square in the image and returns a new image consisting of the midpoint values ​​of each square. Bias is 0.0 to return the minimum value for each region, and bias is 1.0 to return the maximum value for each region. This method allows you to create a reduced copy of the image. Compressed images and bayer images are not supported. image.to_grayscale([copy=False]) Convert the image to a grayscale image. This method also modifies the base image pixels and changes the image size in bytes, so it can only be done on grayscale images or RGB565 images. Otherwise copy must be True to create a new modified image on the heap. Returns an image object so that you can use the . notation to call another method. Compressed images and bayer images are not supported. image.to_rgb565([copy=False]) Convert an image to a color image. This method also modifies the base image pixels and changes the image size in bytes, so it can only be done on RGB565 images. Otherwise copy must be True to create a new modified image on the heap. Returns an image object so that you can use the . notation to call another method. Compressed images and bayer images are not supported. image.to_rainbow([copy=False]) Convert an image to a rainbow image. This method also modifies the base image pixels and changes the image size in bytes, so it can only be done on RGB565 images. Otherwise copy must be True to create a new modified image on the heap. A rainbow image is a color image that has a unique color value for each 8-bit mask grayscale illumination value in the image. For example, it provides a heat map color for a thermal image. Returns an image object so that you can use the . notation to call another method. Compressed images and bayer images are not supported. image.compress([quality=50]) JPEG properly compresses the image. Using this method to use a higher quality compression ratio is at the expense of destroying the original image compared to the compressed save heap space. Quality is the compression quality (0-100) (int). image.compress_for_ide([quality=50]) JPEG properly compresses the image. Using this method to use a higher quality compression ratio is at the expense of destroying the original image compared to the compressed save heap space. This method compresses the image and then formats the JPEG data by encoding each 6 bits into a byte between 128 and 191 and converts it to OpenMV IDE for display. This step is done to prevent JPEG data from being mistaken for other text data in the byte stream. You need to use this method to format the image data for display in the terminal window created by Open Terminal in OpenMV IDE. Quality is the compression quality (0-100) (int). image.compressed([quality=50]) Returns a JPEG compressed image - the original image is unprocessed. However, this method requires a large allocation of heap space, so image compression quality and image resolution must be low. Quality is the compression quality (0-100) (int). image.compressed_for_ide([quality=50]) Returns a JPEG compressed image - the original image is unprocessed. However, this method requires a large allocation of heap space, so image compression quality and image resolution must be low. This method compresses the image and then formats the JPEG data by encoding each 6 bits into a byte between 128 and 191 and converts it to OpenMV IDE for display. This step is done to prevent JPEG data from being mistaken for other text data in the byte stream. You need to use this method to format the image data for display in the terminal window created by Open Terminal in OpenMV IDE. Quality is the compression quality (0-100) (int). image.copy([roi[, copy_to_fb=False]]) Create a copy of the image object. Roi is a region of interest (x, y, w, h) of a rectangle to be copied. If not specified, the ROI copies the image rectangle of the entire image. But this does not apply to JPEG images. Remember that the image copy is stored in the MicroPython heap instead of the frame buffer. Again, you need to keep the image copy size below 8KB (OpenMV) or below 16KB (OpenMV Cam M7). If you want to use a copy operation to use all the heap space, this function will get an exception. An oversized image can easily trigger an exception. If copy_to_fb is True, this method replaces the framebuffer with an image. The frame buffer has much larger space than the heap and can accommodate large images. image.save(path[, roi[, quality=50]]) Save a copy of the image to the file system in path. Support image files in bmp/pgm/ppm/jpg/jpeg format. Note: You cannot save a compressed image in jpeg format to an uncompressed format. Roi is a region of interest (x, y, w, h) of a rectangle to be copied. If not specified, the ROI copies the image rectangle of the entire image. But this does not apply to JPEG images. Quality refers to the JPEG compression quality that saves the image to JPEG format when the image has not been compressed. image.clear() Set all pixels in the image to zero (very fast). Returns an image object so that you can use the . notation to call another method. Compressed images are not supported. image.draw_line(x0, y0, x1, y1[, color[, thickness=1]]) Draw a line from (x0, y0) to (x1, y1) on the image. You can pass x0, y0, x1, y1 individually or to a tuple (x0, y0, x1, y1). Color is the RGB888 tuple for grayscale or RGB565 images. The default is white. However, you can also pass the base pixel value of the grayscale image (0-255) or the byte of the RGB565 image to invert the RGB565 value. Thickness The thickness of the control line. Returns an image object so that you can use the . notation to call another method. Compressed images and bayer images are not supported. image.draw_rectangle(x, y, w, h[, color[, thickness=1[, fill=False]]]) Draw a rectangle on the image. You can pass x, y, w, h alone or as a tuple (x, y, w, h). Color is the RGB888 tuple for grayscale or RGB565 images. The default is white. However, you can also pass the base pixel value of the grayscale image (0-255) or the byte of the RGB565 image to invert the RGB565 value. Thickness The thickness of the control line. Set fill to True to fill the rectangle. Returns an image object so that you can use the . notation to call another method. Compressed images and bayer images are not supported. image.draw_circle(x, y, radius[, color[, thickness=1[, fill=False]]]) Draw a circle on the image. You can pass x, y, radius alone or as a tuple (x, y, radius). Color is the RGB888 tuple for grayscale or RGB565 images. The default is white. However, you can also pass the base pixel value of the grayscale image (0-255) or the byte of the RGB565 image to invert the RGB565 value. Thickness The thickness of the control line. Set fill to True to fill the circle. Returns an image object so that you can use the . notation to call another method. Compressed images and bayer images are not supported. image.draw_string(x, y, text[, color[, scale=1[, x_spacing=0[, y_spacing=0[, mono_space=True]]]]) Draw 8x10 text from the (x, y) position in the image. You can pass x, y alone or as a tuple (x, y). Text is a string that is written to the image. The \\n, \\r, and \\r\\n terminators move the cursor to the next line. Color is the RGB888 tuple for grayscale or RGB565 images. The default is white. However, you can also pass the base pixel value of the grayscale image (0-255) or the byte of the RGB565 image to invert the RGB565 value. You can increase the scale to increase the size of the text on the image. Only integer values ​​(for example, 1/2/3 / etc). X_spacing allows you to add (if positive) or subtract (if negative) x pixels between characters to set the character spacing. Y_spacing allows you to add (if positive) or subtract (if negative) y pixels between characters to set the line spacing. Mono_space defaults to True, which forces the text spacing to be fixed. For big text, this looks bad. Setting False to get a non-fixed width of character spacing looks much better. Returns an image object so that you can use the . notation to call another method. Compressed images and bayer images are not supported. image.draw_cross(x, y[, color[, size=5[, thickness=1]]]) Draw a cross on the image. You can pass x, y alone or as a tuple (x, y). Color is the RGB888 tuple for grayscale or RGB565 images. The default is white. However, you can also pass the base pixel value of the grayscale image (0-255) or the byte of the RGB565 image to invert the RGB565 value. Size Controls the extension of the crosshair. Thickness Controls the pixel thickness of the edge. Returns an image object so that you can use the . notation to call another method. Compressed images and bayer images are not supported. image.draw_arrow(x0, y0, x1, y1[, color[, thickness=1]]) Draw an arrow from (x0, y0) to (x1, y1) on the image. You can pass x0, y0, x1, y1 individually or to a tuple (x0, y0, x1, y1). Color is the RGB888 tuple for grayscale or RGB565 images. The default is white. However, you can also pass the base pixel value of the grayscale image (0-255) or the byte of the RGB565 image to invert the RGB565 value. Thickness The thickness of the control line. Returns an image object so that you can use the . notation to call another method. Compressed images and bayer images are not supported. image.draw_image(image, x, y[, x_scale=1.0[, y_scale=1.0[, mask=None]]]) Draw an image whose top left corner starts at position x, y. You can pass x, y alone or pass it to a tuple (x, y). X_scale Controls the extent to which the image is scaled in the x direction (floating point). Y_scale Controls the extent to which the image is scaled in the y direction (floating point). Mask is another image that is used as a pixel-level mask for drawing operations. The mask should be an image with only black or white pixels and should be the same size as the image you are drawing. You can use the mask mask to draw. Returns an image object so that you can use the . notation to call another method. Compressed images and bayer images are not supported. image.draw_keypoints(keypoints[, color[, size=10[, thickness=1[, fill=False]]]]) Draw a point of a feature point object on the image. Color is the RGB888 tuple for grayscale or RGB565 images. The default is white. However, you can also pass the base pixel value of the grayscale image (0-255) or the byte of the RGB565 image to invert the RGB565 value. Size Controls the size of feature points. Thickness The thickness of the control line. Set fill to True to fill the feature points. Returns an image object so that you can use the . notation to call another method. Compressed images and bayer images are not supported. image.flood_fill(x, y[, seed_threshold=0.05[, floating_threshold=0.05[, color[, invert=False[, clear_background=False[, mask=None]]]]]) The area where the image is filled starting from position x, y. You can pass x, y alone or pass it to a tuple (x, y). Seed_threshold Controls the difference between the pixels in the fill area and the original start pixel. Floating_threshold Controls the difference between pixels in the fill area and any adjacent pixels. Color is the RGB888 tuple for grayscale or RGB565 images. The default is white. However, you can also pass the base pixel value of the grayscale image (0-255) or the byte of the RGB565 image to invert the RGB565 value. Pass invert to True to repopulate everything outside the flood_fill connection area. Pass clear_background as True and zero the remaining flood_fill pixels that are not recolored. Mask is another image that is used as a pixel-level mask for drawing operations. The mask should be an image with only black or white pixels and should be the same size as the image you are drawing. Only the pixels set in the mask will be evaluated at flood_fill. Returns an image object so that you can use the . notation to call another method. Compressed images and bayer images are not supported. This method is not available on OpenMV Cam M4. image.binary(thresholds[, invert=False[, zero=False[, mask=None]]]) Sets all pixels in the image to black or white depending on whether the pixel is within the threshold in the threshold list thresholds. The thresholds must be a list of tuples. [(lo, hi), (lo, hi), ..., (lo, hi)] Define the range of colors you want to track. For grayscale images, each tuple needs to contain two values ​​- the minimum gray value and the maximum gray value. Only pixel regions that fall between these thresholds are considered. For RGB565 images, each tuple needs to have six values ​​(l_lo, l_hi, a_lo, a_hi, b_lo, b_hi) - the minimum and maximum values ​​for the LAB L, A and B channels, respectively. For ease of use, this feature will automatically fix the minimum and maximum values ​​of the exchange. Also, if the tuple is greater than six values, the remaining values ​​are ignored. Conversely, if the tuple is too short, the remaining thresholds are assumed to be in the maximum range. annotation To get the threshold of the tracked object, simply select (click and drag) the tracking object in the IDE framebuffer. The histogram will be updated accordingly to the area. Then just write down the color distribution in the starting and falling positions in each histogram channel. These will be the low and high values ​​of thresholds. Since the difference between the upper and lower quartiles is small, the threshold is manually determined. You can also determine the color threshold by going to Tools -> Machine Vision -> Threshold Editor in the OpenMV IDE and dragging the slider from the GUI window. Invert Reverses the threshold operation, where pixels are matched outside of the known color range, not within the known color range. Set zero to True to make the threshold pixel zero and leave the pixels that are not in the threshold list unchanged. Mask is another image that is used as a pixel-level mask for drawing operations. The mask should be an image with only black or white pixels and should be the same size as the image you are drawing. Only the pixels set in the mask are modified. Returns an image object so that you can use the . notation to call another method. Compressed images and bayer images are not supported. image.invert() Change binary image 0 (black) to 1 (white) and 1 (white) to 0 (black) to flip all pixel values ​​in the binary image very quickly. Returns an image object so that you can use the . notation to call another method. Compressed images and Bayer images are not supported. image.b_and(image[, mask=None]) Use another image to perform a logical AND operation with this image. Image can be an image object, the path to an uncompressed image file (bmp/pgm/ppm), or a scalar value. If a scalar value, the value can be an RGB888 tuple or a base pixel value (eg, an 8-bit grayscale of a grayscale image or a byte-inverted RGB565 value of an RGB image). Mask is another image that is used as a pixel-level mask for drawing operations. The mask should be an image with only black or white pixels and should be the same size as the image you are drawing. Only the pixels set in the mask are modified. Returns an image object so that you can use the . notation to call another method. Compressed images and bayer images are not supported. image.b_nand(image[, mask=None]) Use another image to perform a logical AND operation with this image. Image can be an image object, the path to an uncompressed image file (bmp/pgm/ppm), or a scalar value. If a scalar value, the value can be an RGB888 tuple or a base pixel value (eg, an 8-bit grayscale of a grayscale image or a byte-inverted RGB565 value of an RGB image). Mask is another image that is used as a pixel-level mask for drawing operations. The mask should be an image with only black or white pixels and should be the same size as the image you are drawing. Only the pixels set in the mask are modified. Returns an image object so that you can use the . notation to call another method. Compressed images and bayer images are not supported. image.b_or(image[, mask=None]) Use another image to perform a logical OR operation with this image. Image can be an image object, the path to an uncompressed image file (bmp/pgm/ppm), or a scalar value. If a scalar value, the value can be an RGB888 tuple or a base pixel value (eg, an 8-bit grayscale of a grayscale image or a byte-inverted RGB565 value of an RGB image). Mask is another image that is used as a pixel-level mask for drawing operations. The mask should be an image with only black or white pixels and should be the same size as the image you are drawing. Only the pixels set in the mask are modified. Returns an image object so that you can use the . notation to call another method. Compressed images and bayer images are not supported. image.b_nor(image[, mask=None]) Use another image to perform a logical OR operation with this image. Image can be an image object, the path to an uncompressed image file (bmp/pgm/ppm), or a scalar value. If a scalar value, the value can be an RGB888 tuple or a base pixel value (eg, an 8-bit grayscale of a grayscale image or a byte-inverted RGB565 value of an RGB image). Mask is another image that is used as a pixel-level mask for drawing operations. The mask should be an image with only black or white pixels and should be the same size as the image you are drawing. Only the pixels set in the mask are modified. Returns an image object so that you can use the . notation to call another method. Compressed images and bayer images are not supported. image.b_xor(image[, mask=None]) Use another image to perform an exclusive OR operation with this image. Image can be an image object, the path to an uncompressed image file (bmp/pgm/ppm), or a scalar value. If a scalar value, the value can be an RGB888 tuple or a base pixel value (eg, an 8-bit grayscale of a grayscale image or a byte-inverted RGB565 value of an RGB image). Mask is another image that is used as a pixel-level mask for drawing operations. The mask should be an image with only black or white pixels and should be the same size as the image you are drawing. Only the pixels set in the mask are modified. Returns an image object so that you can use the . notation to call another method. Compressed images and bayer images are not supported. image.b_xnor(image[, mask=None]) Use another image to logically AND the same image. Image can be an image object, the path to an uncompressed image file (bmp/pgm/ppm), or a scalar value. If a scalar value, the value can be an RGB888 tuple or a base pixel value (eg, an 8-bit grayscale of a grayscale image or a byte-inverted RGB565 value of an RGB image). Mask is another image that is used as a pixel-level mask for drawing operations. The mask should be an image with only black or white pixels and should be the same size as the image you are drawing. Only the pixels set in the mask are modified. Returns an image object so that you can use the . notation to call another method. Compressed images and bayer images are not supported. image.erode(size[, threshold[, mask=None]]) Remove pixels from the edges of the split area. This method is implemented by convolving the kernel of ((size2)+1)x((size2)+1) pixels on the convolution image. If the sum of the adjacent pixel sets is smaller than threshold, then the center pixel of the kernel is performed. Return to zero. If the threshold is not set, this method functions as the standard corrosion method. If the threshold is set, you can specify a specific pixel to be etched. For example, set a threshold of 2 around pixels that are less than 2 pixels. Mask is another image that is used as a pixel-level mask for drawing operations. The mask should be an image with only black or white pixels and should be the same size as the image you are drawing. Only the pixels set in the mask are modified. Returns an image object so that you can use the . notation to call another method. Compressed images and bayer images are not supported. image.dilate(size[, threshold[, mask=None]]) Add pixels to the edges of the split area. This method is implemented by convolving the kernel of ((size2)+1)x((size2)+1) pixels on the convolution image. If the sum of the adjacent pixel sets is greater than threshold, the central pixel of the kernel is performed. Settings. If the threshold is not set, this method functions as the standard corrosion method. If the threshold is set, you can specify a specific pixel to be etched. For example, set a threshold of 2 around pixels that are less than 2 pixels. Mask is another image that is used as a pixel-level mask for drawing operations. The mask should be an image with only black or white pixels and should be the same size as the image you are drawing. Only the pixels set in the mask are modified. Returns an image object so that you can use the . notation to call another method. Compressed images and bayer images are not supported. image.open(size[, threshold[, mask=None]]) The image is subjected to corrosion and expansion in sequence. See image.erode() and image.dilate() for more information. Mask is another image that is used as a pixel-level mask for drawing operations. The mask should be an image with only black or white pixels and should be the same size as the image you are drawing. Only the pixels set in the mask are modified. Returns an image object so that you can use the . notation to call another method. Compressed images and bayer images are not supported. image.close(size[, threshold[, mask=None]]) The image is expanded and etched in sequence. See image.erode() and image.dilate() for more information. Mask is another image that is used as a pixel-level mask for drawing operations. The mask should be an image with only black or white pixels and should be the same size as the image you are drawing. Only the pixels set in the mask are modified. Returns an image object so that you can use the . notation to call another method. Compressed images and bayer images are not supported. image.top_hat(size[, threshold[, mask=None]]) Returns the difference between the original image and the image after executing the image.open() function. Mask is another image that is used as a pixel-level mask for drawing operations. The mask should be an image with only black or white pixels and should be the same size as the image you are drawing. Only the pixels set in the mask are modified. Compressed images and bayer images are not supported. image.black_hat(size[, threshold[, mask=None]]) Returns the difference between the original image and the image after executing the image.close() function. Mask is another image that is used as a pixel-level mask for drawing operations. The mask should be an image with only black or white pixels and should be the same size as the image you are drawing. Only the pixels set in the mask are modified. Compressed images and bayer images are not supported. image.negate() Flip (number invert) all pixel values ​​in the image very quickly. The value of the pixel value of each color channel is converted. Example: (255 - pixel). Returns an image object so that you can use the . notation to call another method. Compressed images and bayer images are not supported. image.replace(image[, hmirror=False[, vflip=False[, mask=None]]]) Image can be an image object, the path to an uncompressed image file (bmp/pgm/ppm), or a scalar value. If a scalar value, the value can be an RGB888 tuple or a base pixel value (eg, an 8-bit grayscale of a grayscale image or a byte-inverted RGB565 value of an RGB image). Set hmirror to True to replace the image with a horizontal mirror. Set vflip to True to replace the image with a vertical flip. Mask is another image that is used as a pixel-level mask for drawing operations. The mask should be an image with only black or white pixels and should be the same size as the image you are drawing. Only the pixels set in the mask are modified. Returns an image object so that you can use the . notation to call another method. Compressed images and bayer images are not supported. image.add(image[, mask=None]) Add two images to each other in pixels. Image can be an image object, the path to an uncompressed image file (bmp/pgm/ppm), or a scalar value. If a scalar value, the value can be an RGB888 tuple or a base pixel value (eg, an 8-bit grayscale of a grayscale image or a byte-inverted RGB565 value of an RGB image). Mask is another image that is used as a pixel-level mask for drawing operations. The mask should be an image with only black or white pixels and should be the same size as the image you are drawing. Only the pixels set in the mask are modified. Returns an image object so that you can use the . notation to call another method. Compressed images and bayer images are not supported. image.sub(image[, reverse=False[, mask=None]]) The two images are subtracted from each other by pixel. Image can be an image object, the path to an uncompressed image file (bmp/pgm/ppm), or a scalar value. If a scalar value, the value can be an RGB888 tuple or a base pixel value (eg, an 8-bit grayscale of a grayscale image or a byte-inverted RGB565 value of an RGB image). Set reverse to True to reverse the subtraction from this_image-image to image-this_image . Mask is another image that is used as a pixel-level mask for drawing operations. The mask should be an image with only black or white pixels and should be the same size as the image you are drawing. Only the pixels set in the mask are modified. Returns an image object so that you can use the . notation to call another method. Compressed images and bayer images are not supported. image.mul(image[, invert=False[, mask=None]]) Multiply two images by pixel by pixel. Image can be an image object, the path to an uncompressed image file (bmp/pgm/ppm), or a scalar value. If a scalar value, the value can be an RGB888 tuple or a base pixel value (eg, an 8-bit grayscale of a grayscale image or a byte-inverted RGB565 value of an RGB image). Setting invert to True changes the multiplication operation from ab to 1/((1/a)(1/b)). In particular, this brightens the image rather than darkening the image (eg, multiply and burn operations). Mask is another image that is used as a pixel-level mask for drawing operations. The mask should be an image with only black or white pixels and should be the same size as the image you are drawing. Only the pixels set in the mask are modified. Returns an image object so that you can use the . notation to call another method. Compressed images and bayer images are not supported. image.div(image[, invert=False[, mask=None]]) Divide this image by another image. Image can be an image object, the path to an uncompressed image file (bmp/pgm/ppm), or a scalar value. If a scalar value, the value can be an RGB888 tuple or a base pixel value (eg, an 8-bit grayscale of a grayscale image or a byte-inverted RGB565 value of an RGB image). Set invert to True to change the division direction from a/b to b/a. Mask is another image that is used as a pixel-level mask for drawing operations. The mask should be an image with only black or white pixels and should be the same size as the image you are drawing. Only the pixels set in the mask are modified. Returns an image object so that you can use the . notation to call another method. Compressed images and bayer images are not supported. image.min(image[, mask=None]) At the pixel level, replace the pixels in this image with the smallest pixel value between this image and another image. Image can be an image object, the path to an uncompressed image file (bmp/pgm/ppm), or a scalar value. If a scalar value, the value can be an RGB888 tuple or a base pixel value (eg, an 8-bit grayscale of a grayscale image or a byte-inverted RGB565 value of an RGB image). The mask should be an image with only black or white pixels and should be the same size as the image you are drawing. Only the pixels set in the mask are modified. Returns an image object so that you can use the . notation to call another method. Compressed images and bayer images are not supported. This method is not available on OpenMV4. image.max(image[, mask=None]) Replace pixels in this image at the pixel level with the maximum pixel value between this image and another image. Image can be an image object, the path to an uncompressed image file (bmp/pgm/ppm), or a scalar value. If a scalar value, the value can be an RGB888 tuple or a base pixel value (eg, an 8-bit grayscale of a grayscale image or a byte-inverted RGB565 value of an RGB image). Mask is another image that is used as a pixel-level mask for drawing operations. The mask should be an image with only black or white pixels and should be the same size as the image you are drawing. Only the pixels set in the mask are modified. Returns an image object so that you can use the . notation to call another method. Compressed images and bayer images are not supported. image.difference(image[, mask=None]) The two images are taken to each other in absolute values. Example: For each color channel, replace each pixel with ABS (this.pixel-image.pixel). Image can be an image object, the path to an uncompressed image file (bmp/pgm/ppm), or a scalar value. If a scalar value, the value can be an RGB888 tuple or a base pixel value (eg, an 8-bit grayscale of a grayscale image or a byte-inverted RGB565 value of an RGB image). Mask is another image used as a pixel-level mask for drawing operations. The mask should be an image with only black or white pixels and should be the same size as the image you are drawing. Only the pixels set in the mask are modified. Returns an image object so that you can use the . notation to call another method. Compressed images and bayer images are not supported. image.blend(image[, alpha=128[, mask=None]]) Combine another image image with this image. Image can be an image object, the path to an uncompressed image file (bmp/pgm/ppm), or a scalar value. If a scalar value, the value can be an RGB888 tuple or a base pixel value (eg, an 8-bit grayscale of a grayscale image or a byte-inverted RGB565 value of an RGB image). Alpha controls how much other images are to be blended into this image. alpha should be an integer value between 0 and 256. A value close to zero will mix more images into this image, and close to 256 is the opposite. Mask is another image that is used as a pixel-level mask for drawing operations. The mask should be an image with only black or white pixels and should be the same size as the image you are drawing. Only the pixels set in the mask are modified. Returns an image object so that you can use the . notation to call another method. Compressed images and bayer images are not supported. image.histeq([adaptive=False[, clip_limit=-1[, mask=None]]]) Run a histogram equalization algorithm on the image. Histogram equalization normalizes contrast and brightness in the image. If adaptive passes to True, the adaptive histogram equalization method will be run on the image, which is usually better than the non-adaptive histogram qualification, but runs longer. Clip_limit provides a way to limit the contrast of adaptive histogram equalization. A good histogram equalization contrast limited image can be generated using a small value (eg 10). Mask is another image that is used as a pixel-level mask for drawing operations. The mask should be an image with only black or white pixels and should be the same size as the image you are drawing. Only the pixels set in the mask are modified. Returns an image object so that you can use the . notation to call another method. Compressed images and bayer images are not supported. image.mean(size, [threshold=False, [offset=0, [invert=False, [mask=None]]]]]) Standard mean blur filtering using a box filter. Size is the size of the kernel. Take 1 (3x3 core), 2 (5x5 core) or higher. If you want to adaptively set the threshold on the output of the filter, you can pass the threshold=True parameter to initiate adaptive threshold processing of the image, which is based on the brightness of the ambient pixel (the brightness of the pixels around the kernel function). Set to 1 or 0. A negative offset value sets more pixels to 1, while a positive value only sets the strongest contrast to 1. Set invert to invert the result output of the binary image. Mask is another image that is used as a pixel-level mask for drawing operations. The mask should be an image with only black or white pixels and should be the same size as the image you are drawing. Only the pixels set in the mask are modified. Returns an image object so that you can use the . notation to call another method. Compressed images and bayer images are not supported. Median(size, percentile=0.5, threshold=False, offset=0, invert=False, mask]) Run median filtering on the image. Median filtering is the best filtering to smooth the surface, but at very slow speeds, while preserving the edges. Size is the size of the kernel. Take 1 (3x3 core), 2 (5x5 core) or higher. Percentile Controls the percentile of the values ​​used in the kernel. By default, each pixel is replaced with an adjacent fiftyth percentile (center). You can set this value to 0 when using minimum filtering, to 0.25 for lower quartile filtering, to 0.75 for upper quartile filtering, and to 1 for maximum filtering. If you want to adaptively set the threshold on the output of the filter, you can pass the threshold=True parameter to initiate adaptive threshold processing of the image, which is based on the brightness of the ambient pixel (the brightness of the pixels around the kernel function). Set to 1 or 0. A negative offset value sets more pixels to 1, while a positive value only sets the strongest contrast to 1. Set invert to invert the result output of the binary image. Mask is another image that is used as a pixel-level mask for drawing operations. The mask should be an image with only black or white pixels and should be the same size as the image you are drawing. Only the pixels set in the mask are modified. Returns an image object so that you can use the . notation to call another method. Compressed images and bayer images are not supported. This method is not available on OpenMV Cam M4. image.mode(size[, threshold=False, offset=0, invert=False, mask]) Run a majority filter on the image, replacing each pixel with the pattern of adjacent pixels. This method works well on grayscale images. However, due to the non-linear nature of this operation, many artifacts are produced on the edges of the RGB image. Size is the size of the kernel. Take 1 (3x3 core), 2 (5x5 core). If you want to adaptively set the threshold on the output of the filter, you can pass the threshold=True parameter to initiate adaptive threshold processing of the image, which is based on the brightness of the ambient pixel (the brightness of the pixels around the kernel function). Set to 1 or 0. A negative offset value sets more pixels to 1, while a positive value only sets the strongest contrast to 1. Set invert to invert the result output of the binary image. Mask is another image that is used as a pixel-level mask for drawing operations. The mask should be an image with only black or white pixels and should be the same size as the image you are drawing. Only the pixels set in the mask are modified. Returns an image object so that you can use the . notation to call another method. Compressed images and bayer images are not supported. This method is not available on OpenMV Cam M4. image.midpoint(size[, bias=0.5, threshold=False, offset=0, invert=False, mask]) Run midpoint filtering on the image. This filter finds the midpoint of the neighborhood of each pixel in the image ((max-min)/2). Size is the size of the kernel. Take 1 (3x3 core), 2 (5x5 core) or higher. Bias Controls the minimum/maximum degree of image blending. 0 is only for minimum filtering and 1 is for maximum filtering only. You can minimize/maximize filtering of images with bias. If you want to adaptively set the threshold on the output of the filter, you can pass the threshold=True parameter to initiate adaptive threshold processing of the image, which is based on the brightness of the ambient pixel (the brightness of the pixels around the kernel function). Set to 1 or 0. A negative offset value sets more pixels to 1, while a positive value only sets the strongest contrast to 1. Set invert to invert the result output of the binary image. Mask is another image that is used as a pixel-level mask for drawing operations. The mask should be an image with only black or white pixels and should be the same size as the image you are drawing. Only the pixels set in the mask are modified. Returns an image object so that you can use the . notation to call another method. Compressed images and bayer images are not supported. This method is not available on OpenMV Cam M4. image.morph(size, kernel, mul=Auto, add=0) The image is convolved through the filter kernel. This allows you to perform a general convolution on the image. Size Controls the size of the kernel to ((size2)+1)x((size2)+1) pixels. Kernel The kernel used to convolve the image, either as a tuple or as a list of values ​​[-128:127]. Mul is the number used to multiply the result of the convolutional pixel. If not set, it defaults to a value that will prevent scaling in the convolution output. Add is the number used to add the convolution result to each pixel. Mul can be used for global contrast adjustment, and add can be used for global brightness adjustment. If you want to adaptively set the threshold on the output of the filter, you can pass the threshold=True parameter to initiate adaptive threshold processing of the image, which is based on the brightness of the ambient pixel (the brightness of the pixels around the kernel function). Set to 1 or 0. A negative offset value sets more pixels to 1, while a positive value only sets the strongest contrast to 1. Set invert to invert the result output of the binary image. Mask is another image that is used as a pixel-level mask for drawing operations. The mask should be an image with only black or white pixels and should be the same size as the image you are drawing. Only the pixels set in the mask are modified. Returns an image object so that you can use the . notation to call another method. Compressed images and bayer images are not supported. image.gaussian(size[, unsharp=False[, mul[, add=0[, threshold=False[, offset=0[, invert=False[, mask=None]]]]]]) The image is convolved by a smooth Gaussian kernel. Size is the size of the kernel. Take 1 (3x3 core), 2 (5x5 core) or higher. If unsharp is set to True, this method does not perform Gaussian filtering only, but performs an unsharp masking operation to improve the image sharpness of the edges. Mul is the number used to multiply the result of the convolutional pixel. If not set, it defaults to a value that will prevent scaling in the convolution output. Add is the number used to add the convolution result to each pixel. Mul can be used for global contrast adjustment, and add can be used for global brightness adjustment. If you want to adaptively set the threshold on the output of the filter, you can pass the threshold=True parameter to initiate adaptive threshold processing of the image, which is based on the brightness of the ambient pixel (the brightness of the pixels around the kernel function). Set to 1 or 0. A negative offset value sets more pixels to 1, while a positive value only sets the strongest contrast to 1. Set invert to invert the result output of the binary image. Mask is another image that is used as a pixel-level mask for drawing operations. The mask should be an image with only black or white pixels and should be the same size as the image you are drawing. Only the pixels set in the mask are modified. Returns an image object so that you can use the . notation to call another method. Compressed images and bayer images are not supported. This method is not available on OpenMV Cam M4. image.laplacian(size[, sharpen=False[, mul[, add=0[, threshold=False[, offset=0[, invert=False[, mask=None]]]]]]) The image is convolved by edge detection of the Laplacian kernel. Size is the size of the kernel. Take 1 (3x3 core), 2 (5x5 core) or higher. If sharpen is set to True, this method will instead sharpen the image instead of just outputting edge-detected images that have not been thresholded. Increase the kernel size and increase the image clarity. Mul is the number used to multiply the result of the convolutional pixel. If not set, it defaults to a value that will prevent scaling in the convolution output. Add is the number used to add the convolution result to each pixel. Mul can be used for global contrast adjustment, and add can be used for global brightness adjustment. If you want to adaptively set the threshold on the output of the filter, you can pass the threshold=True parameter to initiate adaptive threshold processing of the image, which is based on the brightness of the ambient pixel (the brightness of the pixels around the kernel function). Set to 1 or 0. A negative offset value sets more pixels to 1, while a positive value only sets the strongest contrast to 1. Set invert to invert the result output of the binary image. Mask is another image used as a pixel-level mask for drawing operations. The mask should be an image with only black or white pixels and should be the same size as the image you are drawing. Only the pixels set in the mask are modified. Returns an image object so that you can use the . notation to call another method. Compressed images and bayer images are not supported. This method is not available on OpenMV Cam M4. image.bilateral(size[, color_sigma=0.1[, space_sigma=1[, threshold=False[, offset=0[, invert=False[, mask=None]]]]]) The image is convolved by a bilateral filter. A bilateral filter smoothes the image while maintaining the edges in the image. Size is the size of the kernel. Take 1 (3x3 core), 2 (5x5 core) or higher. The color_sigma control uses a bilateral filter to match the proximity of the color. Increasing this value increases the color blur. Space_sigma controls the degree to which pixels are blurred in space. Increasing this value increases pixel blur. If you want to adaptively set the threshold on the output of the filter, you can pass the threshold=True parameter to initiate adaptive threshold processing of the image, which is based on the brightness of the ambient pixel (the brightness of the pixels around the kernel function). Set to 1 or 0. A negative offset value sets more pixels to 1, while a positive value only sets the strongest contrast to 1. Set invert to invert the result output of the binary image. Mask is another image that is used as a pixel-level mask for drawing operations. The mask should be an image with only black or white pixels and should be the same size as the image you are drawing. Only the pixels set in the mask are modified. Returns an image object so that you can use the . notation to call another method. Compressed images and bayer images are not supported. This method is not available on OpenMV Cam M4. image.cartoon(size[, seed_threshold=0.05[, floating_threshold=0.05[, mask=None]]]) Roam the image and fill all the pixel areas in the image using the flood-fills algorithm. This effectively removes texture from the image by flattening the colors in all areas of the image. For best results, the image should have a lot of contrast so that the areas don't penetrate too easily. Seed_threshold Controls the difference between the pixels in the fill area and the original start pixel. Floating_threshold Controls the difference between pixels in the fill area and any adjacent pixels. Mask is another image that is used as a pixel-level mask for drawing operations. The mask should be an image with only black or white pixels and should be the same size as the image you are drawing. Only the pixels set in the mask are modified. Returns an image object so that you can use the . notation to call another method. Compressed images and bayer images are not supported. This method is not available on OpenMV Cam M4. image.remove_shadows([image]) Remove the shadow from the image. If the current image does not have a \"shadowless\" version, this method will attempt to remove the shadow from the image, but there is no true unshaded image basis. This algorithm is suitable for removing shadows in a flat, uniform background. Note that this method takes many seconds to run and is only suitable for removing shadows in real time, dynamically generating an unshadowed version of the image. Future versions of the algorithm will work for more environments, but equally slow. If the current image has a \"shadowless\" version, this method will remove all shadows in the image using the \"true source\" background unshadowed image to filter out the shadows. Non-shaded pixels are not filtered out, so you can add new objects that didn't exist before to the scene, and any non-shaded pixels in those objects will be displayed. Returns an image object so that you can use the . notation to call another method. Only RGB565 images are supported. This method is not available on OpenMV Cam M4. image.chrominvar() Remove the lighting effect from the image, leaving only the color gradient. Faster than image.illuminvar() but affected by shadows. Returns an image object so that you can use the . notation to call another method. Only RGB565 images are supported. This method is not available on OpenMV Cam M4. image.illuminvar() Remove the lighting effect from the image, leaving only the color gradient. Slower than image.chrominvar() but not affected by shadows. Returns an image object so that you can use the . notation to call another method. Only RGB565 images are supported. This method is not available on OpenMV Cam M4. image.linpolar([reverse=False]) The image is re-projected from Cartesian coordinates to linear polar coordinates. Set reverse = True to re-project in the opposite direction. Linear polar re-projection converts image rotation to x translation. Compressed images are not supported. This method is not available on OpenMV Cam M4. image.logpolar([reverse=False]) The image is re-projected from Cartesian coordinates to log polar coordinates. Set reverse = True to re-project in the opposite direction. Log-polar polar re-projection converts the rotation of the image to x translation and zoom to y translation. Compressed images are not supported. This method is not available on OpenMV Cam M4. image.lens_corr([strength=1.8[, zoom=1.0]]) Perform lens distortion correction to remove the fisheye effect caused by the lens. Strength is a floating point number that determines how much the fisheye effect is applied to the image. By default, try the value of 1.8 first, then adjust this value to make the image show the best results. Zoom is the value at which the image is scaled. The default is 1.0. Returns an image object so that you can use the . notation to call another method. Compressed images and bayer images are not supported. img.rotation_corr([x_rotation=0.0[, y_rotation=0.0[, z_rotation=0.0[, x_translation=0.0[, y_translation=0.0[, zoom=1.0]]]]]) The perspective problem in the image is corrected by performing a 3D rotation of the frame buffer. X_rotation is the degree to which the image is rotated in the frame buffer around the x-axis (this causes the image to rotate up and down). Y_rotation is the degree of rotation of the image around the y-axis in the frame buffer (ie, the image is rotated left and right). Z_rotation is the degree by which the image is rotated in the frame buffer around the z-axis (ie, the image is rotated to the appropriate position). X_translation is the number of units that move the image to the left or right after rotation. Because this transformation is applied in 3D space, the unit is not a pixel... Y_translation is the number of units that move the image up or down after rotation. Because this transformation is applied in 3D space, the unit is not a pixel... Zoom is the amount that is scaled by the image. By default 1.0. Returns an image object so that you can use the . notation to call another method. Compressed images and bayer images are not supported. This method is not available on OpenMV Cam M4. image.get_similarity(image) Returns a \"similarity\" object describing the two images using the SSIM algorithm to compare the similarities of 8x8 pixel patches between the two images. Image can be an image object, the path to an uncompressed image file (bmp/pgm/ppm), or a scalar value. If a scalar value, the value can be an RGB888 tuple or a base pixel value (eg, an 8-bit grayscale of a grayscale image or a byte-inverted RGB565 value of an RGB image). Compressed images and bayer images are not supported. This method is not available on OpenMV Cam M4. image.get_histogram([thresholds[, invert=False[, roi[, bins[, l_bins[, a_bins[, b_bins]]]]]]) Normalize histogram operations on all color channels of roi and return histogram objects. Please refer to the histogram object for more information. You can also call this method using image.get_hist or image.histogram . If you pass the thresholds list, the histogram information will only be calculated from the pixels in the threshold list. The thresholds must be a list of tuples. [(lo, hi), (lo, hi), ..., (lo, hi)] Define the range of colors you want to track. For grayscale images, each tuple needs to contain two values ​​- the minimum gray value and the maximum gray value. Only pixel regions that fall between these thresholds are considered. For RGB565 images, each tuple needs to have six values ​​(l_lo, l_hi, a_lo, a_hi, b_lo, b_hi) - the minimum and maximum values ​​for the LAB L, A and B channels, respectively. For ease of use, this feature will automatically fix the minimum and maximum values ​​of the exchange. Also, if the tuple is greater than six values, the remaining values ​​are ignored. Conversely, if the tuple is too short, the remaining thresholds are assumed to be in the maximum range. annotation To get the threshold of the tracked object, simply select (click and drag) the tracking object in the IDE framebuffer. The histogram will be updated accordingly to the area. Then just write down the color distribution in the starting and falling positions in each histogram channel. These will be the low and high values ​​of thresholds. Since the difference between the upper and lower quartiles is small, the threshold is manually determined. You can also determine the color threshold by going to Tools -> Machine Vision -> Threshold Editor in the OpenMV IDE and dragging the slider from the GUI window. Invert Reverses the threshold operation, where pixels are matched outside of the known color range, not within the known color range. Unless you need to use color statistics for advanced operations, simply use the image.get_statistics() method instead of this method to see the pixel areas in the image. Roi is a rectangular tuple of interest regions (x, y, w, h). If not specified, the ROI is the image rectangle of the entire image. The operating range is limited to pixels in the roi area. Bins and other bins are the number of bins used for the histogram channel. For grayscale images, use bins, for RGB565 images, use each of the other channels. The bin count for each channel must be greater than 2. In addition, it makes no sense to set the bin count to a number greater than the unique pixel value of each channel. By default, the histogram will have the maximum number of bins per channel. Compressed images and bayer images are not supported. image.get_statistics([thresholds[, invert=False[, roi[, bins[, l_bins[, a_bins[, b_bins]]]]]]) Calculates the average, median, value, standard deviation, minimum, maximum, lower quartile, and upper quartile for each color channel in roi and returns a data object. See the statistics object for more information. You can also call this method using image.get_stats or image.statistics . If you pass the thresholds list, the histogram information will only be calculated from the pixels in the threshold list. The thresholds must be a list of tuples. [(lo, hi), (lo, hi), ..., (lo, hi)] Define the range of colors you want to track. For grayscale images, each tuple needs to contain two values ​​- the minimum gray value and the maximum gray value. Only pixel regions that fall between these thresholds are considered. For RGB565 images, each tuple needs to have six values ​​(l_lo, l_hi, a_lo, a_hi, b_lo, b_hi) - the minimum and maximum values ​​for the LAB L, A and B channels, respectively. For ease of use, this feature will automatically fix the minimum and maximum values ​​of the exchange. Also, if the tuple is greater than six values, the remaining values ​​are ignored. Conversely, if the tuple is too short, the remaining thresholds are assumed to be in the maximum range. annotation To get the threshold of the tracked object, simply select (click and drag) the tracking object in the IDE framebuffer. The histogram will be updated accordingly to the area. Then just write down the color distribution in the starting and falling positions in each histogram channel. These will be the low and high values ​​of thresholds. Since the difference between the upper and lower quartiles is small, the threshold is manually determined. You can also determine the color threshold by going to Tools -> Machine Vision -> Threshold Editor in the OpenMV IDE and dragging the slider from the GUI window. Invert Reverses the threshold operation, where pixels are matched outside of the known color range, not within the known color range. You can use this method when you need to get a pixel area information in an image. For example, if you want to use the frame difference method to detect motion, you need to use this method to determine the change in the color channel of the image, which triggers the motion detection threshold. Roi is a rectangular tuple of interest regions (x, y, w, h). If not specified, the ROI is the image rectangle of the entire image. The operating range is limited to pixels in the roi area. Bins and other bins are the number of bins used for the histogram channel. For grayscale images, use bins, for RGB565 images, use each of the other channels. The bin count for each channel must be greater than 2. In addition, it makes no sense to set the bin count to a number greater than the unique pixel value of each channel. By default, the histogram will have the maximum number of bins per channel. Compressed images and bayer images are not supported. image.get_regression(thresholds[, invert=False[, roi[, x_stride=2[, y_stride=1[, area_threshold=10[, pixels_threshold=10[, robust=False]]]]]]) Perform linear regression calculations on all threshold pixels of the image. This calculation is done by least squares, which is usually faster, but does not handle any outliers. If robust is True, the Theil index will be used. The Theil index calculates the median of all slopes between all threshold pixels in the image. If you set too many pixels after the threshold transition, even on an 80x60 image, this N^2 operation may lower your FPS below 5. However, as long as the number of pixels to be set after the threshold conversion is small, linear regression is effective even when the threshold pixel exceeding 30% is an abnormal value. This method returns an image.line object. How to easily use straight line objects, see the following blog post: https://openmv.io/blogs/news/linear-regression-line-following The thresholds must be a list of tuples. [(lo, hi), (lo, hi), ..., (lo, hi)] Define the range of colors you want to track. For grayscale images, each tuple needs to contain two values ​​- the minimum gray value and the maximum gray value. Only pixel regions that fall between these thresholds are considered. For RGB565 images, each tuple needs to have six values ​​(l_lo, l_hi, a_lo, a_hi, b_lo, b_hi) - the minimum and maximum values ​​for the LAB L, A and B channels, respectively. For ease of use, this feature will automatically fix the minimum and maximum values ​​of the exchange. Also, if the tuple is greater than six values, the remaining values ​​are ignored. Conversely, if the tuple is too short, the remaining thresholds are assumed to be in the maximum range. To get the threshold of the tracked object, simply select (click and drag) the tracked object in the IDE framebuffer. The histogram will be updated accordingly to the area. Then just write down the color distribution in the starting and falling positions in each histogram channel. These will be the low and high values ​​of thresholds. Since the difference between the upper and lower quartiles is small, the threshold is manually determined. You can also determine the color threshold by going to Tools -> Machine Vision -> Threshold Editor in the OpenMV IDE and dragging the slider from the GUI window. Invert Reverses the threshold operation, where pixels are matched outside of the known color range, not within the known color range. Roi is a rectangular tuple of interest regions (x, y, w, h). If not specified, the ROI is the image rectangle of the entire image. The operating range is limited to pixels in the roi area. X_stride is the number of x pixels to skip when calling a function. Y_stride is the number of y pixels to skip when calling a function. Returns None if the bounding box area after the regression is smaller than area_threshold . Returns None if the number of pixels after regression is less than pixel_threshold . Compressed images and bayer images are not supported. image.find_blobs(thresholds[, invert=False[, roi[, x_stride=2[, y_stride=1[, area_threshold=10[, pixels_threshold=10[, merge=False[, margin=0[, threshold_cb =None[, merge_cb=None]]]]]]]]]]]) Finds all the patches in the image and returns a list of patch objects that include each patch. Please observe the image.blob object for more information. The thresholds must be a list of tuples. [(lo, hi), (lo, hi), ..., (lo, hi)] Define the range of colors you want to track. For grayscale images, each tuple needs to contain two values ​​- the minimum gray value and the maximum gray value. Only pixel regions that fall between these thresholds are considered. For RGB565 images, each tuple needs to have six values ​​(l_lo, l_hi, a_lo, a_hi, b_lo, b_hi) - the minimum and maximum values ​​for the LAB L, A and B channels, respectively. For ease of use, this feature will automatically fix the minimum and maximum values ​​of the exchange. Also, if the tuple is greater than six values, the remaining values ​​are ignored. Conversely, if the tuple is too short, the remaining thresholds are assumed to be in the maximum range. annotation To get the threshold of the tracked object, simply select (click and drag) the tracking object in the IDE framebuffer. The histogram will be updated accordingly to the area. Then just write down the color distribution in the starting and falling positions in each histogram channel. These will be the low and high values ​​of thresholds. Since the difference between the upper and lower quartiles is small, the threshold is manually determined. You can also determine the color threshold by going to Tools -> Machine Vision -> Threshold Editor in the OpenMV IDE and dragging the slider from the GUI window. Invert Reverses the threshold operation, where pixels are matched outside of the known color range, not within the known color range. Roi is a rectangular tuple of interest regions (x, y, w, h). If not specified, the ROI is the image rectangle of the entire image. The operating range is limited to pixels in the roi area. X_stride is the number of x pixels that need to be skipped when looking for a patch. Once the color block is found, the line fill algorithm will be precise pixels. If the color block is known to be large, increase x_stride to increase the speed at which the color block is found. Y_stride is the number of y pixels that need to be skipped when looking for a patch. Once the color block is found, the line fill algorithm will be precise pixels. If the color block is known to be large, increase y_stride to increase the speed at which the patch is found. If the bounding box area of ​​a patch is smaller than area_threshold, it will be filtered out. If the number of pixels in a patch is smaller than pixel_threshold, it will be filtered out. Merge If True, merges all the patches that have not been filtered. The border rectangles of these patches overlap each other. Margin can be used in the intersection test to increase or decrease the size of the patch boundary rectangle. For example, patches with edges of 1 and border rectangles of 1 will be merged. Merging patches allows color code tracking to be achieved. Each patch object has a code value code , which is a bit vector. For example, if you enter two color thresholds in image.find_blobs, the first threshold code is 1 and the second code is 2 (the third code is 4, the fourth code is 8, and so on). Merged patches use logical OR operations on all code so you know the color that produced them. This allows you to track two colors, and if you get a patch object in two colors, it might be a color code. If you use a strict color range and cannot fully track all the pixels of the target object, you may need to merge the patches. Finally, if you want to merge the patches, but don't want the two different threshold colors to be merged, just call image.find_blobs twice, and the different threshold patches will not be merged. The threshold_cb can be set to a function that calls each color block after threshold filtering to filter it out of the list of patches to be merged. The callback function will receive a parameter: the patch object to be filtered. The callback function then returns True to preserve the color block or return False to filter the color block. Merge_cb can be set to function to call two patches to be merged to disable or permit the merge. The callback function will receive two arguments - two patch objects that will be merged. The callback function must return True to merge the color blocks, or return False to prevent color block merging. Compressed images and bayer images are not supported. image.find_lines([roi[, x_stride=2[, y_stride=1[, threshold=1000[, theta_margin=25[, rho_margin=25]]]]]) Use the Hough transform to find all the lines in the image. Returns a list of image.line objects. Roi is a rectangular tuple of interest regions (x, y, w, h). If not specified, the ROI is the image rectangle of the entire image. The operating range is limited to pixels in the roi area. X_stride is the number of x pixels that need to be skipped during the Hough transform. If the line is known to be large, increase x_stride. Y_stride is the number of y pixels that need to be skipped during the Hough transform. If the line is known to be large, increase y_stride. Threshold Controls the line that is detected from the Hough transform. Only return lines that are greater than or equal to threshold. The correct threshold value for the application depends on the image. Note: The magnitude of a line is the sum of the size of all Sobel filter pixels that make up the line. Theta_margin controls the merging of the lines being monitored. The part of the line angle of theta_margin is merged with the part of the line p value of rho_margin. Rho_margin controls the merging of the lines being monitored. The part of the line angle of theta_margin is merged with the part of the line p value of rho_margin. The method performs a Hough transform by running a Sobel filter on the image and using the amplitude and gradient response of the filter. No pre-processing of the image is required. However, cleaning up the image filter results in more stable results. Compressed images and bayer images are not supported. This method is not available on OpenMV Cam M4. image.find_line_segments([roi[, merge_distance=0[, max_theta_difference=15]]]) Use Hough transform to find line segments in the image. Returns a list of image.line objects. Roi is a region of interest (x, y, w, h) of a rectangle to be copied. If not specified, the ROI is the image rectangle. The operating range is limited to pixels in the roi area. Merge_distance specifies the maximum number of pixels between two segments that can be separated from each other without being merged. Max_theta_difference is the maximum angle difference between the two line segments that merge_distancede will merge above. This method uses the LSD library (also used by OpenCV) to find line segments in the image. This is a bit slow, but very accurate, the line segments won't jump. Compressed images and bayer images are not supported. This method is not available on OpenMV Cam M4. image.find_circles([roi[, x_stride=2[, y_stride=1[, threshold=2000[, x_margin=10[, y_margin=10[, r_margin=10]]]]]]) Use the Hough transform to find a circle in the image. Returns a list of image.circle objects (see above). Roi is a region of interest (x, y, w, h) of a rectangle to be copied. If not specified, the ROI is the image rectangle. The operating range is limited to pixels in the roi area. X_stride is the number of x pixels that need to be skipped during the Hough transform. If the circle is known to be large, increase x_stride. Y_stride is the number of y pixels that need to be skipped during the Hough transform. If the circle is known to be large, increase y_stride. Threshold Controls the circle detected from the Hough transform. Only returns a circle greater than or equal to threshold. The correct threshold value for the application depends on the image. Note: The magnitude of a circle is the sum of the size of all Sobel filter pixels that make up the circle. X_margin controls the merge of the detected circles. The round pixels are partially merged for x_margin , y_margin , and r_margin . Y_margin controls the merge of the detected circles. The round pixels are partially merged for x_margin , y_margin , and r_margin . R_margin Controls the merge of the detected circles. The round pixels are partially merged for x_margin , y_margin , and r_margin . Compressed images and bayer images are not supported. This method is not available on OpenMV Cam M4. image.find_rects([roi=Auto, threshold=10000]) Use the same quad detection algorithm used to find AprilTAg to find rectangles in the image. Ideal for rectangles that contrast sharply with the background. AprilTag's quad detection can handle arbitrary scaling/rotating/cutting rectangles. Returns a list of image.rect objects. Roi is a region of interest (x, y, w, h) of a rectangle to be copied. If not specified, the ROI is the image rectangle. The operating range is limited to pixels in the roi area. The border size (by sliding the Sobel operator over all pixels on the edge of the rectangle and adding the value) is smaller than the rectangle of the threshold and is filtered from the return list. The correct value for threshold depends on your application/scenario. Compressed images and bayer images are not supported. This method is not available on OpenMV Cam M4. image.find_qrcodes([roi]) Find all the QR codes in roi and return a list of image.qrcode objects. Please refer to the image.qrcode object for more information. In order for this method to work successfully, the QR code on the image needs to be flat. By using the sensor.set_windowing function to zoom in at the center of the lens, the image.lens_corr function to dissipate the barrel distortion of the lens, or by replacing a lens with a narrow field of view, you get a flatter QR code that is unaffected by lens distortion. Some machine vision lenses do not cause barrel distortion, but they are much more expensive than the standard lenses offered by OpenMV, which is an undistorted lens. Roi is a region of interest (x, y, w, h) of a rectangle to be copied. If not specified, the ROI is the image rectangle of the entire image. The operating range is limited to pixels in the roi area. Compressed images and bayer images are not supported. This method is not available on OpenMV Cam M4. Image.find_apriltags([roi[, families=image.TAG36H11[, fx[, fy[, cx[, cy]]]]]) Find all AprilTags in roi and return a list of image.apriltag objects. Please refer to the image.apriltag object for more information. Compared to QR codes, AprilTags can be detected in longer distances, poorer light, and more distorted image environments. AprilTags can handle all kinds of image distortion problems, and the QR code does not. That is, AprilTags can only encode the digital ID as its payload. AprilTags can also be used for localization. Each image.apriltag object returns its three-dimensional position information and rotation angle from the camera. The position information is determined by fx, fy, cx, and cy, which are the focal length and center point of the image in the X and Y directions, respectively. Create AprilTags using the Tag Generator tool built into OpenMV IDE. The tag generator creates a printable 8.5\"x11\" AprilTags. Roi is a region of interest (x, y, w, h) of a rectangle to be copied. If not specified, the ROI is the image rectangle of the entire image. The operating range is limited to pixels in the roi area. The family is the bit mask of the tag family to be decoded. Is a logical or: image.TAG16H5 image.TAG25H7 image.TAG25H9 image.TAG36H10 image.TAG36H11 image.ARTOOLKIT The default setting is the best image.TAG36H11 tag family. Note: every time a tag family is enabled, the speed of find_apriltags will be slightly slower. Fx is the focal length of the camera's x-direction in pixels. The value of the standard OpenMV Cam is (2.8 / 3.984) * 656, which is obtained by dividing the focal length value of the millimeter by the length of the photosensitive element in the X direction and multiplying by the number of pixels of the photosensitive element in the X direction (for the OV7725 photosensitive element) In terms of). Fy is the focal length of the camera in the y direction in pixels. The value of the standard OpenMV Cam is (2.8 / 2.952) * 488, which is obtained by dividing the focal length value of the millimeter meter by the length of the photosensitive element in the Y direction, and multiplying by the number of pixels of the photosensitive element in the Y direction (for the OV7725 photosensitive element) In terms of). Cx is the center of the image, image.width()/2 , not roi.w()/2 . Cy is the center of the image, image.height()/2, not roi.h()/2 . Compressed images and bayer images are not supported. This method is not available on OpenMV Cam M4. Image.find_datamatrices([roi[, effort=200]]) Finds all the data matrices in roi and returns a list of image.datamatrix objects. Please refer to the image.datamatrix object for more information. In order for this method to work successfully, the rectangular code on the image needs to be flat. By using the sensor.set_windowing function to zoom in on the center of the lens, the image.lens_corr function to dissipate the barrel distortion of the lens, or by replacing a lens with a narrow field of view, you get a flatter rectangular code that is unaffected by lens distortion. Some machine vision lenses do not cause barrel distortion, but they are much more expensive than the standard lenses offered by OpenMV, which is an undistorted lens. Roi is a region of interest (x, y, w, h) of a rectangle to be copied. If not specified, the ROI is the image rectangle of the entire image. The operating range is limited to pixels in the roi area. The effort controls the time used to find the rectangular code match. The default value of 200 should apply to all use cases. However, you may also increase the detection at the expense of the frame rate or increase the frame rate at the expense of detection. Note: If the effort is set below about 160, you will not be able to perform any tests; instead, you can set it to any high value you want, but if the setting is higher than 240, the detection rate will not continue to increase. Compressed images and bayer images are not supported. This method is not available on OpenMV Cam M4. image.find_barcodes([roi]) Find all the 1D barcodes in roi and return a list of image.barcode objects. Please refer to the image.barcode object for more information. For best results, use a long 640, wide 40/80/160 window. The lower the degree of verticality, the faster the speed. Since the barcode is a linear one-dimensional image, it is only necessary to have a higher resolution in one direction and a lower resolution in the other direction. Note: This function performs horizontal and vertical scanning, so you can use a window with a width of 40/80/160 and a length of 480. Finally, be sure to adjust the lens so that the bar code is positioned where the focal length produces the sharpest image. Fuzzy barcodes cannot be decoded. This function supports all 1D barcodes: image.EAN2 image.EAN5 image.EAN8 image.UPCE image.ISBN10 image.UPCA image.EAN13 image.ISBN13 image.I25 image.DATABAR (RSS-14) image.DATABAR_EXP (RSS-Expanded) image.CODABAR image.CODE39 image.PDF417 image.CODE93 image.CODE128 Roi is a region of interest (x, y, w, h) of a rectangle to be copied. If not specified, the ROI is the image rectangle of the entire image. The operating range is limited to pixels in the roi area. Compressed images and bayer images are not supported. This method is not available on OpenMV Cam M4. Image.find_displacement(template[, roi[, template_roi[, logpolar=False]]]) Find the transform offset for this image from the template. This method can be used to make light flow. This method returns an image.displacement object containing the results of the displacement calculation using phase correlation. Roi is a rectangular area (x, y, w, h) that needs to be processed. If not specified, it is equal to the image rectangle. Template_roi is the rectangular area (x, y, w, h) that needs to be processed. If not specified, it is equal to the image rectangle. Roi and template roi must have the same w/h, but x/y can be anywhere in the image. You can slide a smaller rois on a larger image to get a smoother image of the light flow. Image.find_displacement usually calculates the x/y translation between two images. However, if you set logpolar = True , it will find a change in rotation and scaling between the two images. The same image.displacement object results in two possible feedbacks. Compressed images and bayer images are not supported. annotation Use this method on images with a uniform length and width (for example, sensor.B64X64). This method is not available on OpenMV Cam M4. image.find_number(roi) A LENET-6 CNN (Convolutional Neural Network) trained on the MINST data set is run to detect numbers in the 28x28 ROI located anywhere on the image. Returns a tuple containing integers and floating point numbers representing the detected number (0-9) and the confidence of the detection (0-1). Roi is a rectangular tuple of interest regions (x, y, w, h). If not specified, the ROI is the image rectangle of the entire image. The operating range is limited to pixels in the roi area. Only grayscale images are supported. annotation This method is experimental. This method may be removed if you run any CNN that Caffe trains on your PC in the future. This function has been removed by the latest 3.0.0 firmware. This method is not available on OpenMV Cam M4. image.classify_object(roi) Run CIFAR-10 CNN on the ROI of the image to detect aircraft, cars, birds, cats, deer, dogs, frogs, horses, boats and trucks. This method automatically scales the image internally to 32x32 to feed to the CNN. Roi is a rectangular tuple of interest regions (x, y, w, h). If not specified, the ROI is the image rectangle of the entire image. The operating range is limited to pixels in the roi area. Only RGB565 images are supported. annotation This method is experimental. This method may be removed if you run any CNN that Caffe trains on your PC in the future. This method is not available on OpenMV Cam M4. Image.find_template(template, threshold[, roi[, step=2[, search=image.SEARCH_EX]]]) Try to find the location of the first template match in the image using the Normalized Cross Correlation (NCC) algorithm. Returns the bounding box tuple (x, y, w, h) of the matching position, otherwise returns None. Template is a small image object that matches this image object. Note: Both images must be grayscale. Threshold is a floating point number (0.0-1.0), where a smaller value increases the detection rate while increasing the false positive rate. Conversely, a higher value reduces the detection rate while reducing the false positive rate. Roi is a rectangular tuple of interest regions (x, y, w, h). If not specified, the ROI is the image rectangle of the entire image. The operating range is limited to pixels in the roi area. Step is the number of pixels that need to be skipped when looking up the template. Skip pixels can greatly increase the speed at which the algorithm runs. This method is only applicable to the algorithm in SERACH_EX mode. Search can be used for image.SEARCH_DS or image.SEARCH_EX. image.SEARCH_DS The algorithm used for searching templates is faster than image.SEARCH_EX, but if the template is around the edges of the image, it may not be searched successfully. image.SEARCH_EX performs a more detailed search of the image, but it runs much faster than image.SEARCH_DS . Only grayscale images are supported. image.find_features(cascade[, threshold=0.5[, scale=1.5[, roi]]]) This method searches for images of all regions that match Haar Cascade and returns a list of bounding box rectangle tuples (x, y, w, h) for these features. If no features are found, a blank list is returned. Cascade is a Haar Cascade object. See image.HaarCascade() for more information. Threshold is a floating point number (0.0-1.0), where a smaller value increases the detection rate while increasing the false positive rate. Conversely, a higher value reduces the detection rate while reducing the false positive rate. Scale is a floating point number that must be greater than 1.0. A higher scale factor runs faster, but its image matching is poorer. The ideal value is between 1.35 and 1.5. Roi is a rectangular tuple of interest regions (x, y, w, h). If not specified, the ROI is the image rectangle of the entire image. The operating range is limited to pixels in the roi area. Only grayscale images are supported. image.find_eye(roi) Find the pupil in the region of interest (x, y, w, h) around the eye. Returns a tuple containing the position of the pupil (x, y) in the image. If no pupil is found, it returns (0,0). Before using this function, you first need to search for someone's face using image.find_features() and Haar operator frontalface. Then use image.find_features and Haar operator find_eye to search for the eye on the face. Finally, this method is called on each eye ROI returned after calling the image.find_features function to get the coordinates of the pupil. Roi is a rectangular tuple of interest regions (x, y, w, h). If not specified, the ROI is the image rectangle of the entire image. The operating range is limited to pixels in the roi area. Only grayscale images are supported. image.find_lbp(roi) The LBP (local binary mode) key points are extracted from the ROI tuple (x, y, w, h). You can use the image.match_descriptor function to compare two sets of key points to get the matching distance. Roi is a rectangular tuple of interest regions (x, y, w, h). If not specified, the ROI is the image rectangle of the entire image. The operating range is limited to pixels in the roi area. Only grayscale images are supported. image.find_keypoints([roi[, threshold=20[, normalized=False[, scale_factor=1.5[, max_keypoints=100[, corner_detector=image.CORNER_AGAST]]]]]) The ORB key points are extracted from the ROI tuple (x, y, w, h). You can use the image.match_descriptor function to compare two sets of key points to get the matching area. If no key is found, return None. Roi is a rectangular tuple of interest regions (x, y, w, h). If not specified, the ROI is the image rectangle of the entire image. The operating range is limited to pixels in the roi area. Threshold is a number that controls the number of extractions (values ​​0-255). For the default AGAST corner detector, this value should be around 20. For the FAST corner detector, this value is approximately 60-80. The lower the threshold, the more corner points you extract. Normalized is a boolean value. If True, close the extraction keypoint at multiple resolutions. If you don't care about handling extensions and want the algorithm to run faster, set it to True. Scale_factor is a floating point number that must be greater than 1.0. A higher scale factor runs faster, but its image matching is poorer. The ideal value is between 1.35 and 1.5. Max_keypoints is the maximum number of key points a keypoint object can hold. If the key point object is too large and causes memory problems, lower the value. Corner_detector is the corner detector algorithm used to extract key points from an image. Can be image.CORNER_FAST or image.CORNER_AGAST . The FAST corner detector runs faster, but with less accuracy. Only grayscale images are supported. image.find_edges(edge_type[, threshold]) Turn the image into black and white and leave only the edges as white pixels. image.EDGE_SIMPLE - Simple threshold high-pass filtering algorithm image.EDGE_CANNY - Canny edge detection algorithm Threshold is a binary tuple containing a low threshold and a high threshold. You can control the edge quality by adjusting this value. The default is (100, 200). Only grayscale images are supported. Find_hog([roi[, size=8]]) The pixels in the ROI are replaced with HOG (Directed Gradient Histogram) lines. Roi is a rectangular tuple of interest regions (x, y, w, h). If not specified, the ROI is the image rectangle of the entire image. The operating range is limited to pixels in the roi area. Only grayscale images are supported. This method is not available on OpenMV Cam M4. Constant image.SEARCH_EX Detailed template matching search. image.SEARCH_DS Faster template matching search. image.EDGE_CANNY Edge detection is performed on the image using the Canny edge detection algorithm. image.EDGE_SIMPLE Edge detection is performed on the image using a threshold high-pass filtering algorithm. image.CORNER_FAST High-speed low-accuracy corner detection algorithm for ORB key points image.CORNER_AGAST Low speed high accuracy algorithm for ORB key points. image.TAG16H5 Bitmask enumeration for the TAG1H5 tag group. Used in AprilTags. image.TAG25H7 Bitmask enumeration for the TAG25H7 tag group. Used in AprilTags. image.TAG25H9 Bitmask enumeration for the TAG25H9 tag group. Used in AprilTags. image.TAG36H10 Bitmask enumeration for the TAG36H10 tag group. Used in AprilTags. image.TAG36H11 Bitmask enumeration for the TAG36H11 tag group. Used in AprilTags. image.ARTOOLKIT The bit mask enumeration of the ARTOOLKIT tag group. Used in AprilTags. image.EAN2 EAN2 barcode type enumeration. image.EAN5 EAN5 barcode type enumeration. image.EAN8 EAN8 barcode type enumeration. image.UPCE UPCE barcode type enumeration. image.ISBN10 ISBN10 barcode type enumeration. image.UPCA UPCA barcode type enumeration. image.EAN13 EAN13 barcode type enumeration. image.ISBN13 ISBN13 barcode type enumeration. image.I25 I25 barcode type enumeration. image.DATABAR DATABAR barcode type enumeration. image.DATABAR_EXP DATABAR_EXP barcode type enumeration. image.CODABAR CODABAR barcode type enumeration. image.CODE39 CODE39 barcode type enumeration. image.PDF417 PDF417 barcode type enumeration (currently not working). image.CODE93 CODE93 barcode type enumeration. image.CODE128 CODE128 barcode type enumeration. powered by GitbookFile Modify: 2020-09-11 12:05:50 "},"libs/machine_vision/video.html":{"url":"libs/machine_vision/video.html","title":"video","keywords":"","body":"video Support play and record video with avi format Global Function open(path, record=False, interval=100000, quality=50, width=320, height=240, audio=False, sample_rate=44100, channels=1) Open a avi file to play or record Parameters path： file path, e.g. /sd/badapple.avi record： record video or not, if False just to play video interval： Record interval, unit: micro second, fps = 1000000/interval, default to 100000, that is 10 frames per second quality： jpeg compress quality(%), default to 50 width： record screen width, default to 320 height： record screen height, default to 240 audio： record audio or not, default to False sample_rate： sample rate of recorded audio, default to 44100 (44.1k) channels： channels of recorded audio, default to 1 Return Value Return a object, just support avi format yet, so just return a instance of avi class Class avi Get from video.open() play() Play video, decode one frame data(video or audio) every once called Return value 0: play end 1: playing 2: pause(reverve) 3: current frame is video 4: current frame is audio volume(volume) Set play volume Parameters volume: value:[0,100] Return value Set value, ranges: [0,100] record() Record video frame, it will block until the interval time up Return Value The length of current frame( video ) Examples Example 1: Play avi video Encode a video with format: screen size 320x240， MJEPG compress format, PCM format audio You can download avi video here: badapple.avi import video,time from Maix import GPIO fm.register(34, fm.fpioa.I2S0_OUT_D1) fm.register(35, fm.fpioa.I2S0_SCLK) fm.register(33, fm.fpioa.I2S0_WS) fm.register(8, fm.fpioa.GPIO0) wifi_en=GPIO(GPIO.GPIO0,GPIO.OUT) wifi_en.value(0) v = video.open(\"/sd/badapple.avi\") print(v) v.volume(50) while True: if v.play() == 0: print(\"play end\") break v.__del__() By default, it will use I2S0 to display audio, so we need to set their corresponding pins; Turn off WiFi because of the interference of Dock board WiFi on sound quality Example 2: Record Video import video, sensor, image, lcd, time lcd.init() sensor.reset() sensor.set_pixformat(sensor.RGB565) sensor.set_framesize(sensor.QVGA) sensor.run(1) sensor.skip_frames(30) v = video.open(\"/sd/capture.avi\", record=1, interval=200000, quality=50) i = 0 tim = time.ticks_ms() while True: tim = time.ticks_ms() img = sensor.snapshot() lcd.display(img) img_len = v.record(img) # print(\"record\",time.ticks_ms() - tim) i += 1 if i > 100: break print(\"finish\") v.record_finish() lcd.clear() You can cancel the print comment to see if the actual recording interval has reached the set frame interval (such as 200000us set here). The actual print should be 200ms, If the actual frame interval is greater than the set value, the actual performance does not meet the set requirements. You need to increase the set frame interval to decrease the frame rate. In addition, removing the display and printing can also increase the frame rate to some extent. powered by GitbookFile Modify: 2020-09-11 12:05:50 "},"libs/peripheral_modules/":{"url":"libs/peripheral_modules/","title":"Peripheral modules","keywords":"","body":"Peripheral Modules Here peripheral means offchip modules, for example: LCD、 Camera、 touchscreen etc. The peripheral related to vision are put into machine vision), modules as follows: lcd: Display image on LCD sensor: Get camera data, we name it as sensor just like openmv do, but not totally the same as openmv's, see the doc Other Modules: touchscreen: Touchscreen related operation, like get click status or get click coordinate ws2812: WS2812 LED Thermal infrared temperature sensor Ultrasonic Grove chainable RGB LED powered by GitbookFile Modify: 2020-09-11 12:05:50 "},"libs/peripheral_modules/touchscreen.html":{"url":"libs/peripheral_modules/touchscreen.html","title":"touchscreen","keywords":"","body":"touchscreen Touchscreen related operation, like get click status or get click coordinate the drivers supported currently: ns2009 ( default ) To change driver, we need to rebuild the Maixpy firmware Global Function init(i2c=None, cal=None) Initialize touchscreen This API may be changed later, considering the different type of touchscreen Parameters i2c: Currently just support I2C touchscreen, so should give I2C object, we may rename this paramter or remove it later cal: Calibration data, a touple consist of 7 integer, get by touchscreen.calibrate() function calibrate() Calibrate touchscreen with LCD screen pixels Return Return a tuple consist of 7 integer, you can save it to file system or flash, use it in init function, so we no need to calibrate every power on read() Read the click status of touchscreen, and return coordinate of click( press ) Return 一个由 3 个整型值组成的元组 (status, x, y)， 注意这个值会一直保持上一个状态 A touple consist of 3 integet (status, x, y), be attention, the value always keep the last value if status did'nt change status： click status, values: touchscreen.STATUS_PRESS， touchscreen.STATUS_MOVE， touchscreen.STATUS_RELEASE x： x coordinate y： y coordinate Constant touchscreen.STATUS_PRESS The touchscreen is pressed, the firt value of tuple returned by read() touchscreen.STATUS_MOVE The touchscreen is pressed and pen is moving, the firt value of tuple returned by read() touchscreen.STATUS_RELEASE The touchscreen is released, the firt value of tuple returned by read() Examples Demo 1: Drawing Board Drawing board, you can clear content with boot key uncomment ts.calibrate() to execute calibration program import touchscreen as ts from machine import I2C import lcd, image from board import board_info from fpioa_manager import * board_info=board_info() fm.register(board_info.BOOT_KEY, fm.fpioa.GPIO1) btn_clear = GPIO(GPIO.GPIO1, GPIO.IN) lcd.init() i2c = I2C(I2C.I2C0, freq=400000, scl=30, sda=31) ts.init(i2c) #ts.calibrate() lcd.clear() img = image.Image() status_last = ts.STATUS_IDLE x_last = 0 y_last = 0 draw = False while True: (status,x,y) = ts.read() print(status, x, y) if draw: img.draw_line((x_last, y_last, x, y)) if status_last!=status: if (status==ts.STATUS_PRESS or status == ts.STATUS_MOVE): draw = True else: draw = False status_last = status lcd.display(img) x_last = x y_last = y if btn_clear.value() == 0: img.clear() ts.__del__() powered by GitbookFile Modify: 2020-09-11 12:05:50 "},"libs/peripheral_modules/ultrasonic.html":{"url":"libs/peripheral_modules/ultrasonic.html","title":"modules.ultrasonic","keywords":"","body":"modules.ultrasonic Ultrasonic sensor Construction method ultrasonic(gpiohs) Parameters gpiohs: gpiohs number, you need to register the pin withfm first, for example ```python from fpioa_manager import * from modules import ultrasonic fm.register (board_info.D [6], fm.fpioa.GPIOHS0, force = True) device = ultrasonic (fm.fpioa.GPIOHS0) ``` return value Return object method measure(unit, timeout) Parameters unit: unit, take the value in the following constants timeout: timeout time in microseconds (us) Constant ultrasonic.UNIT_CM Unit of distance returned, cm ultrasonic.UNIT_INCH Units of distance returned, feet powered by GitbookFile Modify: 2020-09-11 12:05:50 "},"libs/peripheral_modules/ws2812.html":{"url":"libs/peripheral_modules/ws2812.html","title":"modules.ws2812","keywords":"","body":"WS2812 light strip (modules.ws2812) This module uses the I2S ofK210 to drive the module, so you need to pay attention to the conflict during the use Currently supports up to 12 lights Constructor from modules import ws2812 class ws2812 (led_pin = -1, led_num = -1, i2s_num = I2S_DEVICE_2, i2s_chn = I2S_CHANNEL_3, i2s_dma_chn = DMAC_CHANNEL1) Create a new ws2812 object by specifying parameters Parameters led_pin: The pin of the light strip data cable connection, such asboard_info.D [4] led_num: How many lamp beads are there in the strip? i2s_num: WhichI2S device is used to drive this object, the default is I2S_DEVICE_2, the value range is0-2 i2s_chn: WhichI2S channel is used by this object, the default is I2S_CHANNEL_3, and the value range is0-3 i2s_dma_chn: The DMA channel used by this object, generally not considered by users Method set_led class_ws2812.set_led(num, color) parameters num: TheNth lamp, starting from 0 color: The color assigned to the lamp bead, of typetuple, (R, G, B) return value no display class_ws2812.display() parameters no return value no Routine 0 from modules import ws2812 class_ws2812 = ws2812 (board_info.D [4], 30) for i in range (30): class_ws2812.set_led (i, (0xff, 0,0)) class_ws2812.display () Routine 1 from modules import ws2812 class_ws2812 = ws2812 (board_info.D [4], 30) r = 0 dir = True while True: if dir: r + = 1 else: r-= 1 if r> = 255: r = 255 dir = False elif r Above routine, see MaixPy_scripts powered by GitbookFile Modify: 2020-09-11 12:05:50 "},"libs/peripheral_modules/htpa.html":{"url":"libs/peripheral_modules/htpa.html","title":"modules.htpa","keywords":"","body":"HTPA Thermal Infrared Temperature Measurement Module (modules.htpa) Hyman HTPA 32x32 Thermal Infrared Questioning Module Construction method htpa (i2c, scl_pin, sda_pin, i2c_freq) Create an instance Parameters i2c: I2C number, such asI2C.I2C0, value [0, 2] (see machine.I2C) scl_pin: I2C SCL pin sda_pin: I2C SDA pin i2c_freq: I2C clock frequency return value htpa object Instance method temperature() Get the sensor temperature value, which can only be called by the instance return value Array, the length is the width x height of the sensor, such as 32x32 Instance method width() Gets the sensor resolution width, which can only be called by the instance return value Integer, width instance method height() Gets the sensor resolution width, which can only be called by the instance Examples heimann_HTPA_32x32 powered by GitbookFile Modify: 2020-09-11 12:05:50 "},"libs/peripheral_modules/grove_chainable_rgb_led.html":{"url":"libs/peripheral_modules/grove_chainable_rgb_led.html","title":"Grove RGB LED","keywords":"","body":"Grove 链式 RGB LED 使用两跟线串行连接多个 RGB LED 灯（灯条） 使用 micropython 语法编写， 例程和资料见 MaixPy_Scripts powered by GitbookFile Modify: 2020-09-11 12:05:50 "},"application/":{"url":"application/","title":"Integrated Apps","keywords":"","body":"Integrated Application pye: Integrated MaixPy file editor. Directly edit files on the board using the serial port. nes: NES game emulator lvgl: LittlvGL GUI lib powered by GitbookFile Modify: 2020-09-11 12:05:50 "},"application/pye.html":{"url":"application/pye.html","title":"Micropython Editor","keywords":"","body":"pye Micropython Editor A file editor written by py, integrated into the MaixPy firmware. With it, you can directly edit files via the serial port terminal. Usage: from pye_mp import pye pye(\"/sd/boot.py\") powered by GitbookFile Modify: 2020-09-11 12:05:50 "},"application/nes.html":{"url":"application/nes.html","title":"nes","keywords":"","body":"NES game emulator Classic NES game emulator, take us back to childhood! Or... Let us find a way to let it play itself! Function init(rc_type=nes.KEYBOARD, cs, mosi, miso, clk, repeat=16, vol=5) Initializes the NES emulator Parameters tc_type： Remote control type, keyboard（nes.KEYBOARD） （The serial port communicates with the computer's keyboard, it's not directly connected to the board's USB port...） or PS2 joystick（nes.JOYSTICK）。 A PS2 joystick is recommended for a better experience. Serial communication can't send more than one key at a time. If you want, you can try to write your own scripts here cs： If using a PS2 joystick with SPI interface, enter the cs pin number mosi： If using a PS2 joystick with SPI interface, enter the mosi pin number miso： If using a PS2 joystick with SPI interface, enter the miso pin number clk： If using a PS2 joystick with SPI interface, enter the clk pin number repeat： (Only for keyboard mode!) key repetition rate vol： Initial volume, can be adjusted later run(nes) Run a NES game (ROM) Parameters nes： File path of the game's ROM ， /sd/mario.nes for example Shortcuts Keyboard (serial port) move ： W A S D A ： J B ： K start ： M or Enter option： N or \\ exit ： ESC volume - ： - volume + ： = run speed - ： R run speed + ： F Joystick move ： ^ V -> A ： □ B ： × start ： START select： SELECT exit ： no volume - ： R2 volume + ： R1 run speed - ： L1 run speed + ： L2 Examples Demo 1： Keyboard (Serial port) import nes, lcd lcd.init(freq=15000000) nes.init(nes.KEYBOARD) nes.run(\"/sd/mario.nes\") Demo 2： PS2 joystick import nes, lcd lcd.init(freq=15000000) nes.init(nes.JOYSTICK, cs=19, clk=18, mosi=23, miso=21) nes.run(\"/sd/mario.nes\") powered by GitbookFile Modify: 2020-09-11 12:05:50 "},"application/lvgl.html":{"url":"application/lvgl.html","title":"lvgl","keywords":"","body":"lvgl LittlevGL Refer to the official documentation: lvgl blog page Demo Refer to MaixPy_Scripts on github powered by GitbookFile Modify: 2020-09-11 12:05:50 "},"advanced/compile.html":{"url":"advanced/compile.html","title":"Custom Firmware-Compile","keywords":"","body":"Source code compilation Pre-compiled firmware may not meet specific usage scenarios. If you need to modify the configuration, configure and compile the required firmware Compiled please refer to build.md powered by GitbookFile Modify: 2020-09-11 12:05:50 "},"advanced/code_struct.html":{"url":"advanced/code_struct.html","title":"Code structure","keywords":"","body":"Code frame structure Directory Introduction Directory Subdirectory Subdirectory2 Subdirectory3 Brief assets Resource like image projects Project dir tools tools components ┐ component └-boards code for board specific └-drivers driver code └-micropython ┐ Micropython related └-core micropython source code └-port ┐ maixpy port code └-builtin_py maixpy defualt builtin script └-include headers └-src modules └-spiffs SPIFFS └-utils utils Add code The project is organized using CMake, and the project supports multiple configurable options (Kconfig) If you do not add folders and configuration items, you can add files to the existing folder for compilation. If you need to add modules, you can modify CMakeLists.txt to add content, you can refer to [c_cpp_project_framework] (https://github.com/Neutree/c_cpp_project_framework) with less content If you need to add configuration items, you can modify the Kconfig file to achieve the purpose. All configuration items will generate macro definitions and add them toglobal_config.h (generated file) at compile time, and in CmakeLists.txt This macro definition can be used in files. For example, config BOARD_M5STICK is defined in Kconfig, and CMakeLists.txt can determine whether to compile specific code by judging whether CONFIG_BOARD_M5STICK is true. When compiling, you can choose whether to check by python3 project.py menuconfig powered by GitbookFile Modify: 2020-09-11 12:05:50 "},"advanced/pack_fs.html":{"url":"advanced/pack_fs.html","title":"Pack SPIFFS","keywords":"","body":"Packaged file system Package several files on the PC into a SPIFFS file system image, use kflash to burn to a specific address of the flash, and these files can be read directly on the development board (MaixPy) See the instructions for details:pack SPIFFS for MaixPy powered by GitbookFile Modify: 2020-09-11 12:05:50 "},"others/Q_A.html":{"url":"others/Q_A.html","title":"Q&A","keywords":"","body":"MaixPy Frequently Asked Questions What are the similarities and differences between MaixPy and C development, how do I choose MaixPy is a scripting language based on Micropython, which does not require compilation and is parsed at runtime. It is easier and more convenient to write, but the runtime is not as good as the C language. So if you are fast verification, novice, only python, less hair, etc., you can use MaixPy; you can use C language for the pursuit of extreme performance efficiency or familiar with C MaixPy IDE cannot successfully connect to the development board Check if the serial port is occupied After clicking the connection, do not use it with the terminal tool at the same time, otherwise the serial port will be occupied and cannot be opened If you have been unable to connect successfully, check: Please check if the development board model is wrong; Observe whether the screen of the development board has changed. If there is no response, it may be that the serial port is selected incorrectly; Try to upgrade to the latest master branch firmware, and the latest MaixPy IDE software The document web page cannot be opened, it is slow If some pages cannot be accessed, please check the URL (path) is correct, you can return to the homepage (maixpy.sipeed.com) and enter again. For example, this URL is caused by clicking too fast: ` http://localhost:4000/zh/zh/get_started/how_to_read.html The correct URL should be: `` http://localhost:4000/zh/get_started/how_to_read.html ` In addition, you can try another network line, such as hanging a proxy, or trying mobile phone traffic. Download station file download speed is slow, the file cannot be downloaded If you experience slow download speed on the dl.sipeed.com download site, you can use the domestic synchronization server cn.dl.sipeed.com to download, the path is the same, and sync once a day; Some files provide CDN download links, which will be faster. For example, the IDE has a description in readme.txt Micro SD card cannot be read Format Micro SD to FAT format(not FAT32), and try again. At present the hardware can only support SPI protocol reading, try to buy a formal card For example: The two cards on the left in the figure below are not supported by the MaixPy driver, the middle and right are supported, but the class10 card in the middle is the fastest (up to 128GB available) In addition, I tested several SanDisk, Kingston, Samsung cards purchased online, and found that one Samsung card is unusable Why is the IDE frame rate lowered a lot? The K210 has no USB peripherals, so it can only communicate with the IDE using a serial port, which is not as fast as a USB device, so it will affect the frame rate. You can turn off the camera preview of the IDE. Why the preview camera image on the IDE is blurry The K210 has no USB peripherals, so it can only communicate with the IDE using a serial port. The speed is not as fast as a USB device. Therefore, the pictures are compressed. If you need to see a clear image, please see it on the screen of the development board, or save it as a picture and transfer it to the computer for viewing How to increase the camera frame rate Change to a better camera, for example ov7740 will have a higher frame rate thanov2640. But the premise is that the camera circuit must be compatible with the circuit of the development board Increase the camera clock frequency(sensor.reset(freq=)), but be careful not to be too high, it will make the picture worse You can compile the source code yourself, turn on the camera's double buffering option (by default), and sensor.reset (dual_buff = True), the frame rate will increase, but the corresponding memory will also increase (about 384KiB) powered by GitbookFile Modify: 2020-09-11 12:05:50 "},"contribute/":{"url":"contribute/","title":"Contribute","keywords":"","body":"Contribute to the project Since this is an open source project, everyone is welcome to join in and improve MaixPy. Due to the large number of people, we need a code convention (including format, style, etc.) The following documents describe the coding convention for both the documentation and code: Documentation convention Code convention powered by GitbookFile Modify: 2020-09-11 12:05:50 "},"contribute/doc_convention.html":{"url":"contribute/doc_convention.html","title":"Doc convention","keywords":"","body":"Documentation Convention Documents are built using gitbook and written in simple and efficient Markdown The documentation source code is hosted on GitHub Markdown syntax If you've never used the basic syntax of Markdown, please take half an hour to learn. We recommend the GitHub tutorial: GitHub Markdown Tutorial In this article, we need to pay attention to the following points: The syntax tags of the title class must be separated by spaces. A blank line is required between the headline and the body, such as: ## This is a secondary title * This is list item 1 * This is list item 2 The following example is not correct, it may cause the parser to parse the file with errors. ##This is a secondary title *This is list item 1 *This is list item 2 All pages have only one top level title Because the need to automatically generate a directory, mainly to ensure that the automatically generated directory is correct. Write each page like this Page title/top level title ======= (There is at least three equals here) (At least one more blank line is required, 2 lines are recommended) ## Secondary title 1 (You cannot use a first-level title here, and you cannot use a ##. You don't need to write a serial number, it will automatically generate a serial number.) ( Skip a line ) text (at least one line) ### Three-level title (similar to the second-level title, it does not need to be written, it will be generated automatically) text ## Secondary title 2 text Link Due to the large number of pages and the need to link resources such as images, relative paths are used when writing links. The directory structure is as follows: Assets/ (put public resource files) | ----pic000.png En/ | ----- get_started/ | ---- assets/ (put the resource file common to the md file in the get_started directory) | ------ pic.png | ---- get_hardware.md | ---- how_to_read.md Zh/ If you want to show the images in get_hardware.md, put the image in the assets folder, then use the following code to reference the image: ![pic](assets/pic.png) ![pic](../../assets/pic000.png) Chinese and English mixed When writing Chinese documents, the Chinese characters should be separated by spaces as much as possible. Punctuation should use full-width symbols as much as possible. Mainly to make it stand out and make the document more elegant. For example, the following comparison: In Micropython, we often use `deinit` to represent the destructor instead of setting the default value like STM32. In Micropython, we often use deinit to represent the destructor instead of setting the default value like STM32. In Micropython, we often use deinit to represent the destructor, instead of setting the default value like STM32. In Micropython, we often use deinit to represent the destructor, instead of setting the default value like STM32. Directory and file name The generated document directory is edited in the corresponding language folder SUMMARY.md The source document folder should be a function module corresponding to a folder, and the resource file (picture) is placed in the assets folder directory of the current path of the corresponding md document, which is more convenient when adding, deleting, and modifying. Assets/ (put public resource files) En/ | ----- get_started/ | ---- assets/ (put the resource file common to the md file in the get_started directory) | ---- get_hardware.md | ---- how_to_read.md Zh/ The file name is not limited to README.md, other file names are named with lowercase + underscore, such as get_hardware.md Catalog and links Try to guide readers to use the directory, and use the jump link in the text with caution. If the link jumps in a mess, it will cause the document to look messy and it will be difficult to read. Chinese and English (multi-language) page file directory structure and file name are the same Since there are multiple language switching options in the last generated page, clicking the switch will directly access the same path of the corresponding language, so the Chinese and English directory structure and file name must be the same. For example, English is accessing en/get_started/how_to_read.md. After clicking the button for language switching, it will automatically access zh/get_started/how_to_read.md. If this file does not exist, it will report a 404 error! Module Document Content Need to include a module introduction in the file header Need to explain the constructor, function, constant, etc. Explain that you can't be lazy. Simply translate the function name again. You need to explain the function of the function, the range of parameters, and the point of attention Multi-version management In addition to the Chinese and English (multi-language) support (not automatic translation, manual modification), the document also has multi-version management. Each version is a branch with requirements for the branch name, which are: master branch is the main branch dev branch for development branch Other published historical versions start with a lowercase v, such as creating a branch called v1.2 After creating a new branch, you need to modify the version link in book.json in the directory of each language version, otherwise the reader can't find the entry. You can preview it locally under the newly created branch (see the root directory README.md for the preview method). Note that the previewed page is the current branch. If you want to preview other branches locally, you need to switch to other points before previewing. Just fine. After confirming that the error is modified, push the branch to the remote (github), the automatic build system will be automatically built and published to the pages branch, and the effect will be seen when the access URL is built. powered by GitbookFile Modify: 2020-09-11 12:05:50 "},"contribute/code_convention.html":{"url":"contribute/code_convention.html","title":"Code convention","keywords":"","body":"Code Convention powered by GitbookFile Modify: 2020-09-11 12:05:50 "},"others/open_projects.html":{"url":"others/open_projects.html","title":"Related projects","keywords":"","body":"Open source projects related to MaixPy If you have any open source projects related to MaixPy, feel free to open a new pull request or let us know by opening an issue or sending an email (support@sipeed.com)! We are happy to receive your feedback and contributions! powered by GitbookFile Modify: 2020-09-11 12:05:50 "},"what_maix_do.html":{"url":"what_maix_do.html","title":"MaixPy 能做哪些事","keywords":"","body":"Powerful Maix Board(k210) Can Do 大多数是在 MaixPy 上已经有 API， 部分可能来自 Maixduino 或者其它开发者～ 人脸检测 MobileNet 物体识别 tiny yolov2 20分类 人脸识别 识别颜色值、找形状、找直线、面部识别等 视频来自 Hardware.ai MNIST 手写数字识别 Feature map 显示 视频播放和录制 NES 游戏模拟器 （FC 红白机） GBA 游戏模拟器 源码 游戏 Quake I 源码 游戏 Doom 源码 MMD 3D 实时渲染 源码 GUI 界面 littlevGL 云台脸部跟踪 麦克风阵列 FFT 频谱图 powered by GitbookFile Modify: 2020-09-11 12:05:50 "},"how_to_read.html":{"url":"how_to_read.html","title":"如何正确阅读本文档","keywords":"","body":"如何正确使用（阅读）本文 注意： 目前唯一文档官网： maixpy.sipeed.com 首先请仔细阅读一遍左边侧边栏的目录结构看一看文档有那些内容 刚接触，可以根据左边侧边栏的目录从上到下一页一页仔细看，跟着做即可。 学会如何更新固件，如何写代码，其中学会使用串口终端也十分重要，不建议过分依赖IDE 每个模块/库文档里面的结尾都附有简单例程， 或者到这里:[MaixPy_script](https://github.com/sipeed/MaixPy_scripts)查找需要的示例， 可以尝试运行看效果 最后关于模块的接口及参数，在使用时根据自己的需求进行查阅，左上角有搜索框，可以好好利用，同时也可以使用浏览器的页面搜索功能，即按键盘 Ctrl+F ，然后输入要搜索的内容后按确认键 如果有找不到的内容也请不要着急， 可以上 github 的 issue） 页面找一找（/搜一搜）是不是有人提过了，没有的话可以新建 issue, 或者到 论坛 向大家求助， 或者联系技术支持。 如果网页加载比较慢， 请尝试刷新或者等待， 或者换个线路（使用代理或者换手机流量试试） 文档使用 gitbook 从 markdown 自动生成为静态页面， 如果遇到有些页面无法访问， 请检查一下网址（路径）是否正确， 可以回到首页 (maixpy.sipeed.com) 重新进入即可。 比如这个网址就是由于点击过快导致的： http://localhost:4000/zh/zh/how_to_read.html 正确的网址应该是： http://localhost:4000/zh/how_to_read.html 除了文档，还可以浏览博客看用户写的教程 另外在 github 或者论坛提问时需要注意： 提问要尽量提供完整的问题复现步骤，方便开发者测试问题并解决！ 常见问题请见常见问题 powered by GitbookFile Modify: 2020-09-11 12:05:50 "},"develop_kit_board/get_hardware.html":{"url":"develop_kit_board/get_hardware.html","title":"开发板&&配件选购指南","keywords":"","body":"如何选购开发板 要开始使用 MaixPy, 必须需要一款 K210 开发板, 可以从 Sipeed 官方淘宝店获得心仪的硬件： Sipeed 官方淘宝店 需要的硬件 一款开发板 由于 MaixPy 早期产品线比较多，具体开发板及参数列表如下，用户可以根据自己的动手能力和需求选购对应开发板 MaixPy 系类开发板板载的 ROM 均为 16MB SPI FLASH, RAM: 6MB(通用) + 2MB(KPU 专用) MaixPy 系列开发板 描述 实物图 说明 Maix Amigo 点击购买 Maix Amigo Maix Cube 点击购买 Maix Cube Maix Dock(M1W) 点击购买 Maix Dock(M1W) 全引脚引出 Maix Dock(M1) 点击购买 Maix Dock(M1) 全引脚引出 Maix Bit 点击购买 Maix Bit 全引脚引出 Maix Duino 点击购买 Maix Duino 兼容 Arduino Maix GO 点击购买 Maix GO Maix Nano 点击购买 Maix Nano 核心开发板 开发板详细资料请看 Wiki, 选择一款合适自己的开发板～ USB Type-C 连接线 选用 Type-C 是因为它支持正反插，对开发十分友好 从淘宝官方购买可以询问是否附送，目前大部分安卓机也在使用 Type-C 连接线 屏幕 从淘宝官方购买可以询问是否包含, 推荐用户购买带 LCD 的板子或者套餐,方便后续运行程序时结果的直观展示, 板型 屏幕驱动 IC 屏幕分辨率 是否支持触摸 备注 Maix Cube(IPS) ST7789 240*240 不支持 --- Maix Amigo ILI9486 320*480 支持(FT6X36) --- Maix Amigo(IPS 版) XXX 320*480 支持(FT6X36) --- Maix Nano(不带屏幕) --- --- --- --- Maix Dock ST7789 320*240 不支持 --- Maix Bit ST7789 320*240 不支持 --- Maix Dock ST7789 320*240 不支持 --- Maix Go ST7789 320*240 支持(FT6X36) --- 摄像头 在售的有：OV2640（常规，M12）、OV7740、GC0328； 由于 K210 DVP 接口支持的分辨率为 VGA（640*480 30W）， 所以实际使用选取 30W 像素的摄像头即可。 截至 MaixPy 固件版本: MaixPy 0.5.0_160 ,支持的摄像头型号如下表 型号 设备 id 像素 说明 备注 OV2640 0x2642 200W 支持度较好 OV7740 0x7742 30W 支持度较好 OV3660 0x3660 300W 兼容运行 GC0328 0x9d 30W 支持度较好 GC2145 0x2145 200W 兼容运行 MT9D111 0x1519 200W 可以运行，支持不完整 OV5640 0x5640 500W 完整实现,支持自动变焦 --- 截止至固件版本 MicroPython v0.5.0-173 相关摄像头测试情况如下: 硬件型号 测试通过的单目或双目摄像头 M1/M1W 模组系列（Maixduino、Dock、Go） OV2640、GC0328、OV7740、GC2145、OV5640 M1n 模组系列（Nano、Cube） OV2640、GC0328、OV7740、GC2145、OV5640 MaixBit OV2640、GC0328、OV7740、GC2145、OV5640 Maix Amigo OV7740（后摄）、GC0328（前摄） 目前摄像头的颜色模式 YUV422 RGB565 & YUV422 OV2640 OV5640 OV7740 GC2145 GC0328 --- 从淘宝官方购买可以询问型号, OV7740 帧率相对高一点; OV2640 比较古老, 画质稍不如 GC0328 注：很多用户一上来就问哪款支持的帧率最高，其实帧率除了硬件上会有差异，而且在你使用的程序，由于程序的处理流程不同，帧率也是会有差异的，所以这里无法标注（以免误导用户）具体最高帧率。 Micro SD 卡 (TF 卡) (可选) 不使用 Micro SD 卡也是可以操作文件的, 在内部 Flash 上已经保留一部分来作为文件系统了, 只是 Flash 速度很慢！ 为了方便图片文件快速操作, 可以选择购买一张 Micro SD 卡, 　 MaixPy　内置了 SPI SD卡协议驱动, 购买时尽量选择速度快协议新的 Micro SD 卡, 比如 SD 2代协议, Class10 的内存卡 因为 K210 没有 SDIO 硬件外设, 所以使用了 SPI 来与 SD 卡通信, 当然, 市面上的 SD 卡品质参差不齐, SPI 模式不一定都能兼容, 尽量买正规的卡, 实在有需求请自行定制驱动～～ 比如：下图左边两张卡 MaixPy 的驱动不支持, 中间和右边的都支持, 但是中间的 class10 卡速度最快(最高测过 128GB可用) 另外测试过网上购买的几张闪迪、金士顿、三星的卡, 其中发现有一张三星的卡无法使用 Sipeed 官方店 SD 卡购买链接 ST-Link (用来给开发板 Maix Go 上的 STM32 更新固件) (可选) 如果购买的是 Maix Go, 上面集成了一颗 STM32 芯片, 用来模拟 USB转串口 工具, 以及模拟 JTAG, 如果想后期自行更新其固件, 建议购买一个 ST-Link 备用; 如果不需要JTAG 功能可以不用购买 JTAG 调试器 (可选) 注意： !!! 烧录过 ken_gen.bin 之后将永久禁用 K210 的 JTAG 调试功能 K210 这款芯片支持 JTAG 调试, 如果需要调试功能, 需要使用 JTAG 调试器, 请在 Sipeed 官方淘宝店咨询购买。 如果是 Maix Go 开发板, 可以不用另外购买 JTAG 调试器, Maix Go 开发板上面集成了一个 STM32芯片, 可以模拟 JTAG(STM32 使用 CMSIS-DAP 或者 open-ec 固件), open-ec 固件目前还不支持, 后续会支持, 请以 open-ec github 项目主页说明为准 powered by GitbookFile Modify: 2020-09-11 12:05:50 "},"develop_kit_board/maix_amigo.html":{"url":"develop_kit_board/maix_amigo.html","title":"MaixAmigo 开箱验证","keywords":"","body":"MaixAmigo 概述 SIPEED MaixAmigo 可开发编程学习套件, MaixAmigo 在硬件上集成前后各 30W 像素摄像头、可扩展 TF 卡槽、用户按键、3.5‘TFT 寸显示屏、520mAh 锂电池、扬声器,麦克风、SPMOD,GROVE 扩展接口等。 软件上 MaixAmigo 默认搭载 MaixPy, 用户可以非常轻松的使用 MicroPython 语法快速进行人脸识别、物体分类等多种 AIoT 开发，同时还预留开发调试接口，也能将其作为一款功能强大的 AI 学习开发板。 MaixAmigo 外观及功能介绍 外观一览 板载硬件功能介绍 项目 说明 CPU: 双核 64bit RISC-V / 400MHz* (双精度FPU集成) 内存: 8MiB 64bit 片上 SRAM 存储: 16MiB Flash, 支持 micro SDXC 拓展存储 (最大128GB**) 屏幕: 3.5寸 TFT 显示屏, 分辨率: 320*480, 支持电容触摸(FT6X36) 摄像头: OV7740 (后摄)与GC0328(前摄) 各 30W 像素(最大分辨率 VGA:640*480) 电池: 板载可充电锂聚合物电池 (容量520mAh ) 板载扬声器与麦克风 集成单音频控制器 ES8374 1W 8Ω 扬声器 板载接口: USB-C *2 (K210 调试供电接口+兼容 STM32 核心板 USB 接口) Grove *3 & SPMOD*3 (可拓展模块) 三轴加速度传感器: MSA301 电池: 520mAh 锂电池 硬件板载扩展接口 MaixAmigo 对用户开放了两个高度扩展的接口: SP-MOD 与 Grove 接口, 用户可以很方便的进行 DIY SP-MOD 接口 SP-MOD 即为 sipeed module, simplify PMOD, super module 接口 接口描述 SP-MODE 接口描述 硬件接口(举例) MaixAmigo 板载了三个 SPMOD 接口 PIN\\NO. SP-MOD1 SP-MOD2 SP-MOD3(游戏手柄) 1 GND GND GND 2 12 29 --- 3 6 28 --- 4 24 22 IO24 5 27 25 IO27 6 10 30 --- 7 11 8 --- 8 3V3 3V3 3V3 Grove 接口 Grove 模块接口 Grove 接口的线缆有 4 种颜色，用户可以根据颜色快速区别 Pin 颜色 描述 1 黄色 (例如, I2C Grove Connectors 上的SCL) 2 白色 (例如, I2C Grove Connectors 上的SDA) 3 红色 VCC (所有的Grove接口红色都是VCC) 4 黑色 GND (所有的Grove接口黑色都是GND) MaixAmigo 板载了三个 GROVE 接口 PIN GROVE 1 GROVE 2 GROVE 3 1 GND GND GND 2 3V3 3V3 3V3 3 IO5 IO3 IO1 4 IO4 IO2 IO0 板载 I2C 设备 MaixAmigo 板载 I2C 传感器/IC IC 设备 id I2C 地址(7位地址) 配置：SCL: IO_24, SDA: IO_27 --- I2C Address MaixPy 读取地址 ES8374 0x08 0x10 D(16) MSA301 0x13 0x26 D(38) AXP173 0x68 0x34 D(52) 上手把玩 由于 MaixAmigo 出厂自带 GUI 演示界面和示例程序，所以在拿到板子时可以先上手把玩下预设程序， 在之后那么我们就开始以 MaixAmigo 上手，借助 MaixPy 入门 AIoT. 而在开发之前我们需要了解并准备相关工具，以减少我们后边因为准备不足而走的坑路 上手步骤: 下载需要的驱动，软件 开发板连接电脑，并安装 USB 驱动 更新最新固件 下载并打开最新的 MaixPy IDE MaixPy IDE 连接开发板 运行 MaixPy 示例程序 软硬件准备 硬件准备: 电脑一台 MaixAmigo 开发板 可靠的 USB Type-C 数据线一条: 注意一定要可靠的数据线 软件准备: USB 驱动: FT2232 ->下载链接点这里 Kflash_gui: https://dl.sipeed.com/MAIX/tools/kflash_gui MaixPy IDE : https://dl.sipeed.com/MAIX/MaixPy/ide/_/v0.2.5 例程程序库: https://github.com/sipeed/MaixPy_scripts 安装驱动 我们在拿到 Maix Amigo 并连接到电脑的时候，可以打开设备管理器查看串口驱动是否已经安装，打开设备管理器的方法有: 此电脑(右键) -> 属性 -> 设备管理器 开始菜单(右键) -> 设备管理器 控制面板 -> (搜索)设备管理器 当我们的系统是 Win10 系统，系统则会帮我们自动安装驱动，而如果是旧版 Win7，win8 系统我们就需要自己手动安装: 打开上一节的的链接下载驱动 点击安装 安装完成之后，可以在设备管理器看到已经识别到两个串口设备了 更新固件到最新版 用户拿到开发板之后，板载的固件默认或许已经不是最新版的，那么在使用过程中会存在或多或少的 bug， 我们这时候就需要更新固件版本到最新版本 更新方法查看: 更新固件 运行第一个程序 Hello World LCD 实时预览 Camera # -*- coding: UTF-8 -*- # Amigo_sensor - By: Echo - 周五 4月 2 2020 # start of pmu_axp173.py import sensor, image, time, utime, lcd from machine import I2C, Timer from fpioa_manager import fm from Maix import GPIO ''' 说明: 该例程为 Amigo 前后摄像头切换的 example. 注意事项: 由于 Amigo 电源管理电路的设计 需要配置 PMU AXP173 的输出电压, 才可以正常使用摄像头 ''' # ------------- class AXP173: class PMUError(Exception): pass class OutOfRange(PMUError): pass def __init__(self, i2c_dev=None, i2c_addr=0x34): from machine import I2C if i2c_dev is None: try: self.i2cDev = I2C(I2C.I2C0, freq=400000, scl=24, sda=27) except Exception: raise PMUError(\"Unable to init I2C0 as Master\") else: self.i2cDev = i2c_dev self.i2cDev.scan() self.axp173Addr = i2c_addr def __write_reg(self, reg_address, value): self.i2cDev.writeto_mem( self.axp173Addr, reg_address, value, mem_size=8) def writeREG(self, regaddr, value): self.__write_reg(regaddr, value) # end of pmu_axp173.py # ------------------------ # i2cDev = I2C(I2C.I2C0, freq=400000, scl=24, sda=27) # print(i2cDev.scan()) axp173 = AXP173() axp173.writeREG(0x27, 0x20) axp173.writeREG(0x28, 0x0C) lcd.init(freq=20000000) while True: try: sensor.reset(choice=1) sensor.set_pixformat(sensor.YUV422) sensor.set_framesize(sensor.QVGA) sensor.skip_frames(time=2000) for i in range(50): img = sensor.snapshot() lcd.display(img) except Exception as e: print(e) try: sensor.reset(choice=2) sensor.set_pixformat(sensor.YUV422) sensor.set_framesize(sensor.QVGA) sensor.skip_frames(time=2000) for i in range(50): img = sensor.snapshot() lcd.display(img) except Exception as e: print(e) powered by GitbookFile Modify: 2020-09-11 12:05:50 "},"develop_kit_board/maix_cube.html":{"url":"develop_kit_board/maix_cube.html","title":"MaixCube 开箱验证","keywords":"","body":"MaixCube 外观及功能介绍 概述 SIPEED MaixCube 可开发编程学习套件, MaixCube 在硬件上集成 30W 摄像头、可扩展 TF 卡槽、用户按键、IPS 1.3 寸显示屏、200mAh 锂电池、扬声器,麦克风、SPMOD,GROVE 扩展接口等。 软件上 MaixCube 默认搭载 MaixPy, 用户可以非常轻松的使用 MicroPython 语法快速上手 AI IoT 开发，开发人脸识别，物体识别等 AI 应用，同时还预留开发调试接口，也能将其作为一款功能强大的 AI 学习开发板。 MaixCube 外观及功能介绍 外观一览 1.3 寸 IPS 屏幕: 分辨率 240*240 复位按键 电源按键: 短按开机，长按 8S 关机 Grove 接口: Grove 数字接口，传感器，控制器扩展无限可能~ SP-MOD 接口: 搭载更加强大，更高扩展性的 SP-MOD 数字接口，I2C，SPI(标准，双线，四线模式)等接口均可以使用 TF 卡槽: 多媒体资源扩展，支持大容量储存 摄像头: 搭载 0V7740 30W 像素 Sensor Type-C 接口: 三向按键: 板载功能介绍 电源管理控制单元: AXP173 板载 200mAh 锂电池，支持用户充放电控制 音频驱动 IC: ES8374 支持音频录制，播放 三轴加速度传感器: MSA301 Camera OV7740: 1.3 IPS LCD: RGB: 板载两颗 RGB LED USB Type-C:Type-C 接口，正反盲插 板载扩展接口 Maix Cube 对用户开放了两个高度扩展的接口: SP-MOD 与 Grove 接口， 用户可以很方便的进行 DIY SP-MOD 接口 SP-MOD 即为 sipeed module，simplify PMOD，super module 接口 接口描述 SP-MODE 接口描述 硬件接口 Grove 接口 Grove 模块接口 Grove 接口的线缆有 4 种颜色，用户可以根据颜色快速区别 --- 颜色 描述 pin 1 黄色 (例如，I2C Grove Connectors上的SCL) pin 2 白色 (例如，I2C Grove Connectors上的SDA) pin 3 红色 VCC (所有的Grove接口红色都是VCC) pin 4 黑色 GND (所有的Grove接口黑色都是GND) Grove模块主要有 4 种接口: Grove Digital 数字接口: Grove 数字接口由 Grove 插头的四条标准线组成. 两条信号线通常称为 D0 和 D1 . 大多数模块只使用D0，但有些(像LED Bar Grove显示屏)使用两者.通常核心板会将板卡上的第一个Grove连接头称为D0，第二个称为D1.第一个接头会连接到主控芯片的DO/D1管脚，第二个连接头会连接到主控芯片的D1/D2引脚，后面的连接头以此类推. pin Function Note pin1 Dn 第一个数字输入 — pin2 Dn+1 第二个数字输入 — pin3 VCC 供电引脚 5V/3.3V — pin4 GND 地 — Grove UART : The Grove UART 是特殊的一种数字输入输出接口. 它使用引脚 1 和引脚 2 进行串行输入和发送. 引脚1是 RX 线(用于接收数据，因此是输入)， 其中引脚 2 是 TX 线(用于向 Grove 模块传输数据). pin Function Note pin1 RX 串行接收 pin2 TX 串行发送 pin3 VCC 供电引脚 5V/3.3V pin4 GND 地 Grove I2C: 有许多类型的I2C Grove 传感器可用.MaixCube 上的 Grove 只支持 3.3V 传感器 Grove I2C 连接器具有标准布局.引脚 1 是SCL信号，引脚 2 是SDA信号 pin Function Note pin1 SCL I2C 时钟 pin2 SDA I2C 数据 pin3 VCC 供电引脚，5V/3.3V pin4 GND 地 板载 I2C 设备 MaixCube 板载 I2C 传感器/IC IC 设备 id I2C 地址(7位地址) 配置：SCL: IO_30，SDA: IO_31 --- I2C Address MaixPy 读取地址 ES8374 0x08 0x10 D(16) MSA301 0x13 0x26 D(38) AXP173 0x68 0x34 D(52) 上手把玩 由于 MaixCube 出厂自带 GUI 演示界面和示例程序，所以在拿到板子时可以先上手把玩下预设程序， 在之后那么我们就开始以 MaixCube 上手，借助 MaixPy 入门 AIoT. 而在开发之前我们需要了解并准备相关工具，以减少我们后边因为准备不足而走的坑路 上手步骤: 下载需要的驱动，软件 开发板连接电脑，并安装 USB 驱动 更新最新固件 下载并打开最新的 MaixPy IDE MaixPy IDE 连接开发板 运行 MaixPy 示例程序 软硬件准备 硬件准备: 电脑一台 MaixCube 开发板 可靠的 USB Type-C 数据线一条: 注意一定要可靠的数据线 软件准备: USB 驱动: FT2232 ->下载链接点这里 Kflash_gui: https://dl.sipeed.com/MAIX/tools/kflash_gui MaixPy IDE : https://dl.sipeed.com/MAIX/MaixPy/ide/_/v0.2.5 例程程序库: https://github.com/sipeed/MaixPy_scripts 安装驱动 我们在拿到 Maix Cube 并连接到电脑的时候，可以打开设备管理器查看串口驱动是否已经安装，打开设备管理器的方法有: 此电脑(右键) -> 属性 -> 设备管理器 开始菜单(右键) -> 设备管理器 控制面板 -> (搜索)设备管理器 当我们的系统是 Win10 系统，系统则会帮我们自动安装驱动，而如果是旧版 Win7，win8 系统我们就需要自己手动安装: 打开上一节的的链接下载驱动 点击安装 安装完成之后，可以在设备管理器看到已经识别到两个串口设备了 更新固件到最新版 用户拿到开发板之后，板载的固件默认或许已经不是最新版的，那么在使用过程中会存在或多或少的 bug， 我们这时候就需要更新固件版本到最新版本 更新方法查看: 更新固件 运行第一个程序 Hello World LCD 实时预览 Camera import sensor, image, time, lcd sensor.reset() sensor.set_pixformat(sensor.RGB565) sensor.set_framesize(sensor.QVGA) sensor.skip_frames(time = 2000) sensor.set_hmirror(1) sensor.set_vflip(1) clock = time.clock() lcd.init(type=2) lcd.rotation(2) while(True): clock.tick() img = sensor.snapshot() print(clock.fps()) img.draw_string(60, lcd.height()-120, \"fps:\"+str(clock.fps()), lcd.GREEN, scale=2) lcd.display(img) powered by GitbookFile Modify: 2020-09-11 12:05:50 "},"develop_kit_board/maix_duino.html":{"url":"develop_kit_board/maix_duino.html","title":"MaixDuino 开箱验证","keywords":"","body":"MaixDuino 开发板 概述 SIPEED MaixDuino 是基于我们 M1 模块(主控:Kendryte K210)开发的一款外形兼容 Arduino 的开发板 MaixDuino 集成摄像头、TF卡槽、用户按键、TFT显示屏、MaixDuino 扩展接口等, 用户可使用 MaixDuino 轻松搭建一款人脸识别门禁系统, 同时还预留开发调试接口, 也能将其作为一款功能强大的 AI 学习开发板. MaixDuino 外观及功能介绍 外观一览 引脚一览 板载功能介绍 电源输入 DC05: 6~12V 直流 电源输入 + 程序下载调试接口: USB Type-C 接口 DVP 24PIN: 标准 Camera DVP 24PIN 接口 TF 扩展槽: ESP32: ESP32 SPI 连接(ESP32 支持 WIFI 与 蓝牙) I2C DAC PA PAM8403A MaixDuino 引脚图 资料相关链接 MaixDuino 原理图 powered by GitbookFile Modify: 2020-09-11 12:05:50 "},"develop_kit_board/maix_dock.html":{"url":"develop_kit_board/maix_dock.html","title":"MaixDock 开箱验证","keywords":"","body":"Maix Dock 项目 说明 CPU: 双核 64bit RISC-V / 400MHz* (双精度FPU集成) 内存: 8MiB 64bit 片上 SRAM 存储: 16MiB Flash, 支持 micro SDXC 拓展存储 (最大128GB**) 屏幕: 3.5寸 TFT, 电容触摸屏幕分辨率: 320*480 powered by GitbookFile Modify: 2020-09-11 12:05:50 "},"develop_kit_board/maix_go.html":{"url":"develop_kit_board/maix_go.html","title":"MaixGo 开箱验证","keywords":"","body":"Maix Go 项目 说明 CPU: 双核 64bit RISC-V / 400MHz* (双精度FPU集成) 内存: 8MiB 64bit 片上 SRAM 存储: 16MiB Flash, 支持 micro SDXC 拓展存储 (最大128GB**) 屏幕: 2.4 寸 TFT, 电容触摸屏幕分辨率: 320*240 powered by GitbookFile Modify: 2020-09-11 12:05:50 "},"develop_kit_board/maix_nano.html":{"url":"develop_kit_board/maix_nano.html","title":"MaixNano 开箱验证","keywords":"","body":"Maix Nano 项目 说明 CPU: 双核 64bit RISC-V / 400MHz* (双精度FPU集成) 内存: 8MiB 64bit 片上 SRAM 存储: 16MiB Flash, 支持 micro SDXC 拓展存储 (最大128GB**) 屏幕: 3.5寸 TFT, 电容触摸屏幕分辨率: 320*480 Maix Nano 硬件板载扩展接口 Maix Nano 预留了一个 SPMOD 接口 SP-MOD 接口 SP-MOD 即为 sipeed module, simplify PMOD, super module 接口 接口描述 SP-MODE 接口描述 硬件接口 powered by GitbookFile Modify: 2020-09-11 12:05:50 "},"develop_kit_board/maix_bit.html":{"url":"develop_kit_board/maix_bit.html","title":"MaixBit 开箱验证","keywords":"","body":"Maix Bit 项目 说明 CPU: 双核 64bit RISC-V / 400MHz* (双精度FPU集成) 内存: 8MiB 64bit 片上 SRAM 存储: 16MiB Flash, 支持 micro SDXC 拓展存储 (最大128GB**) 屏幕: 3.5寸 TFT, 电容触摸屏幕分辨率: 320*480 外观一览 powered by GitbookFile Modify: 2020-09-11 12:05:50 "},"get_started/env_install_driver.html":{"url":"get_started/env_install_driver.html","title":"安装驱动","keywords":"","body":"安装 USB 驱动 正式使用 MaixPy 之前，我们需要先安装好串口驱动，才可进行下一步的开发与使用；因为板子是通过 USB 转串口设备与电脑连接（K210 没有 USB 硬件支持功能）。 根据板子的 USB 转串口芯片型号装驱动。 在 Linux 或者 Mac 下操作串口， 如果不想每次都使用 sudo 命令， 执行 sudo usermod -a -G dialout $(whoami) 将自己添加到 dialout 用户组即可，可能需要注销或者重启才能生效 现有开发板板载的 USB 转串口 IC 说明 开发板型号 USB 转串口 IC 说明 Maix Go STM32 STM32 USB 模拟 FT2232 Maix Dock CH340 Maix Duino CH552 CH552 模拟 FT2232 Maix Bit CH552(新版)/CH340(旧版) CH552 模拟 FT2232 Maix Cube GD32(新版)/CH552(旧版) CH552 模拟 FT2232 Maix Amigo GD32 GD32 模拟 FT2232 使用 CH340 IC 的板子直接装 CH340 的驱动即可，其他的均使用 FT2232 的驱动程序 对于 Dan Dock 和 Maix Bit（旧版） 开发板使用了 CH340 ： Linux 不需要装驱动，系统自带了，使用 ls /dev/ttyUSB* 即可看到设备号 Windows 在网上搜索 CH340 驱动 下载安装即可，然后可以在 设备管理器 中看到串口设备 对于 Maix Go 开发板使用了一颗 STM32 来实现模拟串口以及 JTAG 功能， Windows 需要安装 FT2232 的驱动，请自行搜索 FT2232 驱动 下载安装 这款 STM32 芯片的固件出厂默认采用 open-ec 的固件， 如果没问题，则会出现一个或者两个串口， 比如 Linux 下出现两个串口 /dev/ttyUSB0 和 /dev/ttyUSB1， 下载和访问串口时请使用 /dev/ttyUSB1。 Windows 也类似。 如果需要重新烧录这个固件，可以从 github 或者 官网下载 open-ec 固件， 然后使用 ST-LINK 连接板子上引出的 STM32 的 SW 引脚（GND, SWDIO, SWCLK）进行烧录。（目前版本的 Go 板子上的 STM32 不支持串口烧录，只能使用 ST-LINK 进行烧录， 有需要请自行购买，或者使用一款板子用 IO 模拟也可以（比如树莓派） ） 除了 open-ec 还有 CMSIS-DAP 固件， 相比 open-ec 可以模拟 JTAG 来对板子进行调试， open-ec 目前还未支持模拟 JTAG， 可以 从官网下载固件， 使用 ST-LINK 对其进行烧录， 在 Linux 下会出现 /dev/ttyACM0 设备 ST-LINK 对 STM32 的烧录方法资料很全，请自行搜索 请注意对 STM32 更新固件和更新 MaixPy 固件是不一样的， 一般情况不需要更新 STM32的固件， 默认的即够用了， STM32 只是一个 USB转串口的工具而已！！！勿混淆。。。 对于 Maixduino 开发板 和 Maix Bit 新版带麦克风版本（使用CH552） 开发板 开发板使用了 CH552 芯片来实现 USB 转串口功能，没有 JTAG 模拟功能， Windows 需要安装 FT2232 的驱动，请自行搜索 FT2232 驱动 下载安装 安装驱动 USB 驱动: FT2232 ->下载链接点这里 我们在拿到 MaixPy 开发板并连接到电脑的时候, 可以打开设备管理器查看串口驱动是否已经安装,打开设备管理器的方法有: 此电脑(右键) -> 属性 -> 设备管理器 开始菜单(右键) -> 设备管理器 控制面板 -> (搜索)设备管理器 当我们的系统是 Windows 10 系统,系统则会帮我们自动安装驱动，而如果是旧版 Win7，win8 系统，我们就需要自己手动安装 USB 驱动: 打开上一节的的链接下载驱动 点击安装 安装完成之后,可以在设备管理器看到已经识别到两个串口设备了(其中只有一个串口可用) powered by GitbookFile Modify: 2020-09-11 12:05:50 "},"get_started/env_serial_tools.html":{"url":"get_started/env_serial_tools.html","title":"使用串口终端工具","keywords":"","body":"使用串口工具 连接硬件 连接 Type C 线， 一端电脑一端开发板 查看设备是否已经正确识别： 在 Linux 下可以通过 ls /dev/ttyUSB* 或者 ls /dev/ttyACM* 来查看， 如果没有可以 ls /dev 来找找，具体的设备名跟串口芯片和驱动有关. 也可以用sudo dmesg来看是否有设备挂载记录 在 Windows 下可以打开设备管理器来查看 如果没有发现设备， 需要确认有没有装驱动以及接触是否良好 使用串口工具 Windows Windows 常用的串口终端软件有 putty, mobaxterm xshell 等工具 Putty 然后选择串口模式， 然后设置串口和波特率，打开串口。 然后点击回车键，即可看到 MaixPy 的交互界面了 >>> 输入 help()，可以查看帮助 上图来源： laurentopia 的上手教程 Mobaxterm MobaXterm 是 Windows 下一款非常好用的多功能终端软件（当然也包括串口终端） Linux 使用minicom（推荐） 或者 screen等工具即可 minicom sudo apt update sudo apt install minicom sudo minicom -s # 然后根据提示设置串口号以及波特率为 115200 等，不懂可以利用搜索工具搜索 # 设置 Backspace 为 DEL 功能 # 设置 linewrap 为 Yes sudo minicom 注意 minicom 的默认配置文件保存需要 sudo 权限，所以使用sudo minicom -s 这里按 A 即可设置设备 按 E 即可设置波特率， 波特率需要设置为 115200 这里按 A 和 R 将设置切换为图中的设置一样， 第一个是为了后面使用 pye 编辑器快捷键不冲突， 第二个自动换行的设置是为了能显示完全输出 设置完后保存退出，下次就不需要再设置了，只需要执行 sudo minicom 即可, 如果不想每次都使用sudo命令， 执行sudo usermod -a -G dialout $(whoami) 将自己添加到dialout用户组即可，可能需要注销或者重启才能生效，注意sudo minicom -s 如果需要修改默认配置文件还是需要 sudo 进入minicom后点击回车键或者开发板的复位按钮，即可看到 MaixPy 的交互界面了 输入 help()，可以查看帮助 要退出minicom， 按 Ctrl+A X，按 Enter 确认退出即可 另外，在开发过程中可能串口号会变， 可以在执行 minicom 的时候指定串口号，这样就不用每次串口号变了都设置一遍了，比如：minicom -D /dev/ttyUSB1 -b 115200 powered by GitbookFile Modify: 2020-09-11 12:05:50 "},"get_started/upgrade_maixpy_firmware.html":{"url":"get_started/upgrade_maixpy_firmware.html","title":"更新 MaixPy 固件","keywords":"","body":"更新 MaixPy 固件 准备 硬件: USB Type-C 数据线 MaixPy 开发板 PC(电脑) 软件: MaixPy 开发板 USB 驱动程序 kflash_gui 确认驱动已经正确安装 按照前面的说明安装好驱动，并且在电脑中能看到串口设备, Linux 和 Mac OS 执行 ls /dev/ 即可看到设备号，比如名字是ttyUSB0和ttyUSB1; Windows在设备管理器中查看 获得升级工具 下载 kflash_gui, 会得到一个压缩包 kflash_gui 是跨平台的，可以在多个系统下工作（包括 Windows、Linux、MacOS、甚至树莓派） 使用勘智（Kendryte）的Windows版本可能部分开发版无法下载成功，请使用 kflash_gui 这个软件来下载 解压到一个文件夹，双击 kflash_gui.exe(/kflsh_gui) 即可运行, Windows下建议右键固定到开始页面 或者固定到任务栏, Linux 下可以自己新建一个kflash_gui.desktop, 修改文件地址, 使用管理员身份复制到/usr/share/application目录，然后在系统菜单界面就可以看到kflash_gui这款应用了 另外也可以使用命令行版本下载 pip3 install kflash kflash --help kflash -p /dev/ttyUSB0 -b 1500000 -B goE maixpy.bin 获得固件 发布版本的固件从 github 页面下载 最新提交的代码自动构建生成的固件下载： master 分支 固件为 .bin 结尾或者 .kfpkg 的文件 .kfpkg其实就是多个.bin文件的打包版本, 可以使用kflash_gui打包或者手动打包 固件命名说明： 文件名 说明 备注 maixpy_vx.y.z_x_xxx*.bin 默认版本的 MaixPy 固件，包含了大多数功能, 支持连接 MaixPy IDE, 出厂默认固件版本 maixpy_vx.y.z_x_xxx*_m5stickv.bin 针对 M5Stickv 定制的固件, 支持连接 MaixPy IDE — maixpy_vx.y.z_x_xxx*_with_lvgl.bin MaixPy 固件, 支持连接 MaixPy IDE, 带 LVGL 版本.(LVGL是嵌入式 GUI 框架, 写界面的时候需要用到) — maixpy_vx.y.z_x_xxx*_minimum.bin MaixPy 固件最小集合，不支持 MaixPy IDE, 不包含OpenMV的相关算法和各种外设模块 — maixpy_vx.y.z_x_xxx*_minimum_with_ide_support.bin MaixPy 固件最小集合, 支持连接 MaixPy IDE, 不包含OpenMV的相关算法和各种外设模块 运行各种模型，建议使用这个 elf_maixpy_vx.y.z_x_xxx*.7z elf 文件，普通用户不用关心，用于死机调试 — face_model_at_0x300000.kfpkg 人脸模型，放置在地址位 0x300000, 可以和.bin分开多次下载，不冲突 — 下载固件到开发板 打开 kflash_gui 应用 然后选择固件、设置选项, 点击下载即可, 更多特性介绍、使用说明见 kflash_gui 项目主页 使用时注意串口不能被其它软件占用，选择正确的开发板和串口号，可以适当降低波特率和使用低速模式来提高下载成功率 对于最早期的 Maix Go, 如果确认选项是对的，仍然无法下载, 可以尝试将三相拨轮按键拨向 Down 的位置并保持再下载 Sipeed RV JATG 调试器 Sipeed USB-JTAG/TTL RISC-V调试器 STLINK V2 STM8/STM32模拟器 烧录常见问题FAQ 如果在使用 kflash_gui 烧录出现以下等问题 可以按照以下顺序进行排查 检查PC是否有权限打开端口，对于 win10，需要以管理员身份运行 kflash_gui 。 检查端口是否选择正确（如果出现两个设备端口，通常选择端口号小的那一个）。 检查端口是否被其他应用占用（如Maixpy IDE，putty等），应当关闭其他程序占用。 检查设备是否选择正确，对于 Maix Bit2.0（包括M1n模块），应该选择 Maix Bit ( with Mic )。 补充说明：对于Maix Bit 2.0两个串口端口的问题 只有其中一个串口端口有效，用于串口通信与ISP下载程序。 Maix Bit与PC采用串口通信，通过CH552T芯片实现USB虚拟串口功能，而该芯片可以虚拟出两个串口，在Maix Bit（M1n模块底板）中，我们只用到了一个串口，不过有些k210产品两个串口都使用了。 powered by GitbookFile Modify: 2020-09-11 12:05:50 "},"get_started/upgrade_esp32_firmware.html":{"url":"get_started/upgrade_esp32_firmware.html","title":"更新板载 ESP32 固件","keywords":"","body":"更新板载 ESP32 固件 简介： MaixPy 系列的开发板中 MaixDuino 板载了一块 ESP32 WIFI SOC，在默认情况下我们不需要更新板载的 ESP32 模块，但是但我们发现使用过程中存在 bug 并修复了之后我们就需要更新修复的固件。 更新 ESP32 固件步骤 准备 硬件: MaixDuino, USB Type-C 数据线 软件: ESPFLASH ESP32 固件更新工具：ESP32 flash_download_tools 下载链接：flash_download_tools ESP32 MaixDuino 固件： 下载链接：flash_download_tools 更新流程： 下载 flash_download_tools， 下载 MaixDuino ESP32 固件 连接 MaixDuino, 选择 ESP32 串口(一般都是串口号比较大的) 设置下载选项: 如图配置相应选项, 注意波特率一定要设置为 115200 点击 Start 更新固件，并等待完成更新 验证更新是否完成 使用 XCOM, 打开 ESP32 串口，点击 RST 复位 ESP32，如图即刷入成功 powered by GitbookFile Modify: 2020-09-11 12:05:50 "},"get_started/upgrade_esp8285_firmware.html":{"url":"get_started/upgrade_esp8285_firmware.html","title":"更新板载 ESP8285 固件","keywords":"","body":"更新板载 ESP8285 固件 简介： 目前 MaixPy 系列采用 M1W 模块的作为核心模块的开发板有: MaixDock(M1W)， MaixGo 通常情况下我们不需要更新模块内部 WIFI SOC ESP8285 的固件，但是如果使用过程中存在 bug，以及有新版本的固件发布是我们就可以更新固件 验证 ESP8285 是否能够正常工作 MaixDock 验证 ESP8285 是否正常工作例程 ------ MaixGo 验证 ESP8285 是否正常工作例程 ------ 外接 USB 转串口模块测试 使用 USB 转串口模块，按照下表连接之后上电 | M1W | USB 模块 | 说明 | | -------------------------------------- | -------- | ---- | | M1W GND | GND | 共地 | | K210 (IO6)/ESP8285 TX | RX | | | K210 (IO7)/ESP8285 RX | TX | | | k210 RST(上电之前接地，全过程拉低 RST) | GND | | | | | | | | | | | | | | 使用串口助手 (这里使用 XCOM) 来验证 ESP8285 是否正常启动 AT 指令集 ESP8285 和 ESP8266 为同一系列产品，使用同一套 AT 指令集 ESP8285/ESP8266/ESP32 最新 AT指令集 https://github.com/espressif/esp-at/blob/v2.0.0.0_esp8266/docs/ESP_AT_Commands_Set.md 更新 ESP8285 固件步骤 准备 这里以 MaixDock(M1W), Windows 10 系统为例 硬件: MaixDock, USB Type-C 数据线 软件: ESP 固件更新工具：ESP8285 flash_download_tools 下载链接：乐鑫官网：flash_download_tools ESP8285 AT 固件： 下载链接：flash_download_tools 更新流程： 下载 flash_download_tools， 下载 MaixDock ESP8285 固件 连接 MaixDock, 选择 ESP8285 串口(一般都是串口号比较大的) 设置下载选项: 如图配置相应选项, 注意波特率一定要设置为 115200 点击 Start 更新固件，并等待完成更新 验证更新是否完成 使用 XCOM, 打开 ESP8285 串口，点击 RST 复位 ESP，如图即刷入成功 2. powered by GitbookFile Modify: 2020-09-11 12:05:50 "},"get_started/env_maixpyide.html":{"url":"get_started/env_maixpyide.html","title":"MaixPy IDE 使用说明","keywords":"","body":"MaixPy IDE 安装与使用 关于 MaixPy IDE 首先需要弄清： MaixPy 使用 Micropython 脚本语法，所以不像 C 语言 一样需要编译，其实不用 IDE 也能愉快使用： 使用串口终端工具，前面已经安装了 使用 IDE 则会方便在电脑上实时编辑脚本并上传到开发板以及直接在开发板上执行脚本，以及在电脑上实时查看摄像头图像、保存文件到开发板等 当然， 使用 IDE 因为压缩、传输需要耗费一部分资源，所以性能会有所降低，而且如果MaixPy宕机也没有串口终端好发现问题 MaixPy 固件 要使用 MaixPy IDE , 固件必须是 v0.3.1 版本以上, 否则MaixPyIDE 上会连接不上， 使用前尽量检查固件版本和 IDE 版本，都更新到最新版以保障能正常使用 下载安装包 dl.sipeed.com 文件列表等说明 请看 最新版本文件夹下的 readme.txt 文件， 如果下载速度慢请使用 cdn 链接下载 安装 如果是安装程序(推荐，简单方便) Windows直接双击exe文件运行安装程序; Linux命令行给运行权限然后执行 chmod +x maixpy-ide-linux-x86_64-0.2.2.run ./maixpy-ide-linux-x86_64-0.2.2.run 如果是压缩包(7z) 则解压到文件夹 如果系统不支持 7z， 则需要 下载 7z解压缩工具，然后用 7z 在Linux下也可以双击压缩包进行解压！ 如果需要使用终端解压， 可以参考以下命令： sudo apt install p7zip-full 7z x maixpy-ide-linux-x86_64-0.2.2-installer-archive.7z -r -omaixpy-ide # `-o` 后面直接跟解压缩的路径, 中间没有空格. 解压后, 执行 如果是 Windows： 直接双击maixpyide来执行，可以右键固定到开始页面或者固定到任务栏方便后面使用 Linux： 执行 chmod +x setup.sh ./setup.sh ./bin/maipyide.sh 测试运行 打开 MaixPy IDE, 上方工具栏里面选择开发板的型号. Tool-> Select Board (工具->选择开发板) 点击 connect 连接 MaixPy IDE 连接成功之后，链接按钮会由绿变红． 连接按钮下方是运行按钮，会执行当前编辑区的py文件． 再次点击运行按钮(红色), 停止运行当前代码． 上传文件 在 Tool/工具 菜单中可以选择发送文件 注意 点击连接后，不用和终端工具同时使用，否则会出现串口占用无法打开 如果一直无法成功连接成功， 检查： 请检查是否开发板型号选择错误； 观察开发板屏幕是否有变化，如果没有反应可能是串口选择错误； 尝试升级到最新的 master 分支固件， 以及最新的 MaixPy IDE 软件 根据错误提示寻找原因 程序运行出错时会弹框提示错误，但是错误信息不一定完整，请在终端输出里面查找更详细的错误信息 如有必要，请断开 IDE， 仅使用串口终端运行程序（也许你需要先把程序保存到文件，然后运行文件）查看打印以排错 如果提交问题（bbs、群、github issue等），为了使问题快速得到解决，请务必带上上面所述完整信息 powered by GitbookFile Modify: 2020-09-11 12:05:50 "},"get_started/get_started_power_on.html":{"url":"get_started/get_started_power_on.html","title":"上电","keywords":"","body":"MaixPy 开发板上电 当我们拿到 MaixPy 开发板之后 连接硬件 连接 Type C 线， 一端电脑一端开发板 查看设备是否已经正确识别： 在 Linux 下可以通过 ls /dev/ttyUSB* 或者 ls /dev/ttyACM* 来查看， 如果没有可以 ls /dev 来找找，具体的设备名跟串口芯片和驱动有关 在 Windows 下可以打开设备管理器来查看 如果没有发现设备， 需要确认有没有装驱动以及接触是否良好 检查固件版本 使用串口终端打开串口，然后复位，看输出的版本信息，与github 或者 master 分支 的固件版本对比，根据当前版本情况考虑升级到最新版本 比如： [MaixPy] init end __ __ _____ __ __ _____ __ __ | \\/ | /\\ |_ _| \\ \\ / / | __ \\ \\ \\ / / | \\ / | / \\ | | \\ V / | |__) | \\ \\_/ / | |\\/| | / /\\ \\ | | > 查看版本号： 这里版本是 v0.5.0-12-g284ce83， 也可以使用下面的代码查看版本 注： 固件可以从下载站 dl.sipeed.com 中获取 import sys sys.implementation.version 执行代码 打开串口终端后，按开发板的复位按钮就可以看到打印的开机信息了，会输出 >>> 即在等待我们输入代码，如果没有这个符号，可能是有开机自动运行的程序正在运行，可以按Ctrl+C来取消正在运行的程序 然后输入程序执行 >>> print(\"hello world\") hello world >>> 粘贴执行多行代码 当我们有多行代码是从其它地方复制过来的，比如 import os f = os.listdir() print(f) 先复制好代码 串口终端按 Ctrl+E 粘贴代码 按 Ctrl+D（注意如果之前没有按 Ctrl+E 则是软件复位命令，MaixPy 会软复位），然后就可以看到所有代码执行了 >>> paste mode; Ctrl-C to cancel, Ctrl-D to finish === import os === f = os.listdir() === print(f) ['boot.py','main.py', 'freq.conf'] >>> 如果数据量比较大，串口可能丢失数据，会导致提示语法错误，可以多试几次 powered by GitbookFile Modify: 2020-09-11 12:05:50 "},"get_started/get_started_led_blink.html":{"url":"get_started/get_started_led_blink.html","title":"第一个程序: 点亮 LED","keywords":"","body":"点亮 LED 点灯程序作为学习所有开发板的第一个程序，就像学所有编程语言都是先学 hello world 一样，具有着神圣的意义 电路 众所周知， 点亮一个 LED 需要一个电源， 一个电阻， 一个 LED 灯泡， 在 Dan Dock 开发板上， 有三个 LED， 线路如下： 比如我们希望红灯点亮， 即 LED_R 连接的这个 LED， 图中可以看到 LED 的正极已经连接了 3.3V 电源， 所以我们只要让 LED_R 为低电平 LED 即可点亮。 注意， 这里 LED_R 是给这个引脚取的一个别名， 实际上是连接到芯片的一个引脚，比如 Pin13(13) 外设到引脚的映射： FPIOA(现场可编程 IO 阵列， Field Programmable Input and Output Array) 在写程序前，我们需要知道，MaixPy 所使用的硬件 K210 的片上外设（比如 GPIO、I2C 等）对应的引脚（硬件引脚）是可以任意映射的，STM32 片上外设和引脚对应关系已经固定了， 只有部分引脚可以复用， 相比之下 K210 自由度更大。 比如 I2C 可以使用 Pin11 和 Pin12，也可以改成其它任意引脚 代码 我们控制 LED 需要使用到 GPIO 程序如下： from fpioa_manager import * from Maix import GPIO fm.register(board_info.LED_R, fm.fpioa.GPIO0) led_r=GPIO(GPIO.GPIO0, GPIO.OUT) led_r.value(0) 我们只需要将这些代码一行行依次敲到终端里面键盘按确认来执行即可 其中， 我们先从包 Maix 导入了 GPIO 这个类； 前面说了　K210 的引脚可以任意设置，　所以我们使用fm(fpioa manager)这个内置的对象来注册芯片的外设和引脚的对应关系，　这里　fm.fpioa.GPIO0 是　K210 的一个 GPIO 外设（注意区分 GPIO（外设） 和引脚（实实在在的硬件引脚）的区别 ）， 所以把 fm.fpioa.GPIO0 注册到了 引脚 board_info.LED_R； 这里的 board_info 是一个板子信息的类， 可以在串口终端输入 board_info. 然后按 TAB 按键可以看到所有成员，主要是各个引脚值，也可以直接传引脚号，比如 13，实际情况根据开发板的电路图而定 然后定义一个 GPIO 对象， 具体参数看 GPIO 模块的文档， 在左边侧边栏查找。 使用 led_r.value(0) 或者 led_r.value(1) 来设置高低电平即可 到这里已经可以点灯了， 如果了解 Python 语法的小伙伴可以尝试 写个 for 循环来实现 LED 闪烁或者流水灯～ powered by GitbookFile Modify: 2020-09-11 12:05:50 "},"get_started/get_started_edit_file.html":{"url":"get_started/get_started_edit_file.html","title":"编辑并运行文件","keywords":"","body":"编辑并执行文件 MaixPy 内置了文件系统 支持 Flash 使用的 SPIFFS（目前不支持创建目录）, 默认分配了 3MB 给 SPIFF（从flash 0xD00000地址开始 3M）, 开机自动挂载到 /flash 目录下 也支持 FAT 格式的 Micro SD （TF）卡 ,开机自动挂在到 /sd 目录下 需要注意的是, 根目录只是用来挂载 Flash 或者 SD 卡, 具体的文件在 /flash 或者 /sd 目录下 为什么需要编辑并执行文件 在前面 点亮 LED 的实验中,我们直接在终端里面敲代码来一句一句执行,这样也简单方便,我们输入命令后会立即执行并及时得到返回的结果,这种交互方式称为 REPL（Read Eval Print Loop：交互式解释器）, 这种方式的好处就是简单方便,使用起来和 Linux 终端十分相似,只是使用的语法换成了 MaixPy(Micropython)的语法。 但实际大多数情况下我们更想将脚本写到文件中,然后执行文件,这样我们不用每次都敲代码,减少了很多麻烦 编辑并保存文件 方法一： 使用内置编辑器 Micropython Editor(pye) 在 MaixPy 中, 我们内置了一款编开源编辑器 Micropython Editor(pye) 使用 os.listdir() 可以查看当前目录下的文件, 使用 pye(\"hello.py\") 可以创建文件并进入编辑模式, 快捷键等使用说明可以在这里查看 比如我们写入代码 print(\"hello maixpy\") 然后按 Ctrl+S 按 Enter 键保存, 按 Ctrl+Q 退出编辑 注意： 使用这款编辑器对使用的串口工具有一定要求, 必须将 BackSpace 按键设置为 DEL 功能, 否则按 BackSpace 调用的是 Ctrl+H 一样的功能（即字符替换）。 Linux 下推荐使用 minicom, 需要使用 sudo minicom -s 来设置,参考前面的教程 Windows 下也一样, 根据自己使用的工具上网搜设置方法, 比如 xshell 搜 xshell如何设置backspace为del 得到结果： 文件 -> 属性 -> 终端 -> 键盘, 把 delete 和 backspace 序列改为 ASCII 127 即可. 方法二： 使用 MaixPy IDE 打开 MaixPy IDE, 连接开发板 编辑文件,然后在顶端Tool（工具）菜单中,点击将打开的文件保存为 boot.py 来将代码保存到开发板的boot.py文件,中,下次开发板开机上电会自动执行这个文件 当然也可以使用顶端Tool(工具)菜单中的发送文件功能来发送文件,会保存到开发板并且文件名和电脑上的文件名相同 方法三： 使用工具 uPyLoader 读取到 PC（电脑)上编辑后再保存到开发板 下载可执行文件:release 选择串口并点击 Connect 按钮来连接板子 第一次运行该软件需要初始化, 点击 File->Init transfer files 来完成初始化,这会在板子里创建两个文件,分别是 __upload.py 和 __download.py。 然后双机文件名即可打开文件并编辑,编辑完成后点击 save 来保存到开发板即可 方法四： 使用工具 rshell 读取到 PC（电脑)上编辑后再保存到开发板 按照 rshell 项目主页的说明安装好 rshell sudo apt-get install python3-pip sudo pip3 install rshell rshell -p /dev/ttyUSB1 # 这里根据实际情况选择串口 编辑文件 ls /flash edit /flash/boot.py # 编辑器使用方法和 vim 一样 执行文件 使用 os.chdir() 切换当前目录到文件的目录,比如 os.chdir(\"/flash\") 方法一： import 然后执行 import hello 即可看到输出 hello maixpy 使用此方法简单易用,但是需要注意的是, 目前 import 只能使用一次, 如果第二次 import, 则文件不会再执行, 如果需要多次执行,建议使用下面的方法 方法二： exec() 使用 exec() 函数来执行 with open(\"hello.py\") as f: exec(f.read()) 方法三： 使用 MaixPy IDE 来执行 打开文件, 然后点击执行按钮来执行 方法四： 使用 uPyLoader 来执行 连接好后选中文件, 点击 excute 按钮来执行文件 方法五： 使用 ampy 来直接运行电脑上的文件 ampy 执行命令 ampy run file_in_PC.py 来执行位于电脑上的文件（文件不会保存到开发板） powered by GitbookFile Modify: 2020-09-11 12:05:50 "},"get_started/get_started_upload_script.html":{"url":"get_started/get_started_upload_script.html","title":"上传脚本&模块到开发板","keywords":"","body":"上传脚本&模块到开发板 前面我们接触到了直接执行 pye(\"filename.py\") 命令可以打开一个编辑器，可以直接编辑文件系统中的文件 但是慢慢我们会发现，这样的方法只适合用来改少量的代码，当代码量庞大或者我们需要高亮支持时，它就不适用了，我们需要在电脑上写完代码，然后上传到板子的文件系统里面 目前有以下几种方法： 使用 MaixPy IDE 上传脚本到开发板 打开 MaixPy IDE， 连接开发板 编辑文件，然后在顶端Tool（工具）菜单中，点击将打开的文件保存为 boot.py 来将代码保存到开发板的boot.py文件，中，下次开发板开机上电会自动执行这个文件 当然也可以使用顶端Tool(工具)菜单中的发送文件功能来发送文件，会保存到开发板并且文件名和电脑上的文件名相同，（除了脚本也可以上传其它文件，不要太大） 使用图形工具 uPyLoader 上传、运行脚本 uPyLoader 是一款开源软件，使用它可以方便地连接 MaixPy 并且上传、下载、执行文件，同时监控输出等等功能，功能比较完善 下载可执行文件:release 选择串口并点击 Connect 按钮来连接板子 第一次运行该软件需要初始化， 点击 File->Init transfer files 来完成初始化，这会在板子里创建两个文件，分别是 __upload.py 和 __download.py。 左边选中需要上传的文件，点击 Transfer 即可上传到板子的文件系统。 右边是板子里面的文件， 点击 List files 可以刷新文件列表， 选中 文件名， 点击 Execute 即可执行该脚本文件 点击上面的 View -> terminal 可以打开终端 用来查看运行时的输出或者发送命令 使用工具 rshell 正如使用 linux 终端一样， 使用 rshell 的 cp 命令即可简单地复制文件到开发板 按照 rshell 项目主页的说明安装好 rshell sudo apt-get install python3-pip sudo pip3 install rshell rshell -p /dev/ttyUSB1 # 这里根据实际情况选择串口 ls /flash cp ./test.py /flash/ #复制电脑当前目录的文件 test.py 到开发板 flash 根目录 当然， 还有其它更多功能， 详情请访问其 项目主页 使用命令行工具 ampy ampy 是一个简单易用的命令行上传、下载、执行文件 的工具， 而且开源 注意这个工具是运行在电脑端的，而不是运行在板子上的 使用 ampy --help 来查看帮助信息 使用 ampy run file_in_PC.py 命令还可以不上传脚本到板子而是直接在板子上运行该脚本 TF 卡拷贝 拷贝到 TF 卡后， 在终端中执行 import 文件名 来运行脚本 powered by GitbookFile Modify: 2020-09-11 12:05:50 "},"get_started/get_started_boot.html":{"url":"get_started/get_started_boot.html","title":"开机自动运行脚本","keywords":"","body":"开机自启动脚本 系统会在 /flash 或者 /sd(优先) 目录创建 boot.py 文件和main.py， 开机会自动先执行boot.py，然后执行main.py（如果检测到SD卡则执行SD卡里的）， 编辑这两个脚本的内容即可实现开机自启，尽量不要在boot.py里面写死循环程序 另外，也可以在 Micro SD 卡中放 cover.boot.py 或者 cover.main.py 来覆盖 /flash/boot.py 或 /flash/main.py，在开机的时候系统会自动检测并复制，复制完成后会自动重启并运行新的启动文件 注意: * Micro SD 卡应该被格式化为 FAT(FAT32) 文件系统 * FAT 格式的储存卡会被挂载到 `/sd`, 内部 Flash 中的 SPIFFS 会被挂载到`/flash` powered by GitbookFile Modify: 2020-09-11 12:05:50 "},"get_started/maixpy_get_started_video.html":{"url":"get_started/maixpy_get_started_video.html","title":"上手视频教程","keywords":"","body":"MaixPy 视频入门教程 视频简单介绍了基本的上手过程，事实上文档上会更加详细， 视频只是提供一个比较直观的入门参考，对部分人群来说看视频入门会更加容易： 建议进入Bilibili登录看高清版本哦， 如果觉得节奏太慢可以右键调速～ powered by GitbookFile Modify: 2020-09-11 12:05:50 "},"get_started/knowledge_prepare.html":{"url":"get_started/knowledge_prepare.html","title":"基础知识","keywords":"","body":"必备基础知识 要开始使用 MaixPy， 我们建议至少有以下基础知识（如果没有，需要先学习）： 有足够的耐心和细心， 能够静下心来专研技术、仔细查看文档、专心写代码 有 Python 或者 Micropython 基础， 会使用 Python 基础语法。 如果不会 Python语法， 但是有其它编程语言基础，请用百度搜一下 Python 教程 学习基础语法部分即可； 如果不会任何一门编程语言， 那本文档看起来会很吃力， 请先学习 Python 基础语法和使用 至少有一种单片机开发基础，能看懂基本的电路图， 目前本文档还没有针对零基础的人群的教程 需要有单片机开发经验的原因是本文档目前还没有对一些基本的术语进行教学，比如 UART 是什么？ I2S 是什么？而且在未来也多半不会对这些基础知识进行详细地阐述 （但是实际上， 如果你善于使用搜索工具进行学习， 就算不懂也可以学习到） 了解 Micropython 是什么， 这里查看： MicroPython 语言介绍 大致上了解 Micropython 与 Python 的不同， 可以在这里：MicroPython 与 CPython（Python3） 的不同之处 查看 如果上述的几点有一点不满足， 那么建议先补足所缺， 否则学习和开发的过程将会异常艰辛！！！！ powered by GitbookFile Modify: 2020-09-11 12:05:50 "},"get_started/knowledge_micropython.html":{"url":"get_started/knowledge_micropython.html","title":"MicroPython 基础知识","keywords":"","body":"MicroPython 背景知识 由于 MaixPy 是基于 MicroPython 之上进行开发构建的, 提供给用户最终的接口是 Micropython ,所以在使用 MaixPy 开发之初我们需要熟悉下 MicroPython 的语法 不用考虑内存的申请和释放,有很多 MicroPython 库可以直接用(并不直接兼容 PC 上的 Python 模块) Python, 是一个很常用的语言, 在图像处理, 机器学习, 网络编程中都使用非常广.而且 Python 是一个非常容易上手的语言, 如果你有其他语言编程基础(例如C, C++, Java), 会更容易上手. 如果之前有 C/C++/Java (或任何其他语言)的编程经验, 推荐 《廖雪峰的 Python 教程》 如果之前没有任何编程经验, 推荐 《笨方法学 Python 》 REPL 和 串口 首先, 断开开发板 与 MaixPy IDE 的连接, 否则串口会冲突！ 打开 MaixPy IDE 中的终端窗口 print('The quick brown fox', 'jumps over', 'the lazy dog') 输出: The quick brown fox jumps over the lazy dog print() 会依次打印每个字符串, 遇到逗号“,”会输出一个空格, 因此, 输出的字符串是这样拼起来的: The quick brown fox jumps over the lazy dog print() 也可以打印整数, 或者计算结果: print(300) 300 print(100 + 200) 300 因此, 我们可以把计算100 + 200的结果打印得更漂亮一点: print('100 + 200 =', 100 + 200) 100 + 200 = 300 注意, 对于 100 + 200, Python 解释器自动计算出结果 300, 但是, '100 + 200 =' 是字符串而非数学公式, Python 把它视为字符串. 变量 在 Python 中, 等号 = 是赋值语句, 可以把任意数据类型赋值给变量, 同一个变量可以反复赋值, 而且可以是不同类型的变量, 例如: a = 123 # a是整数 print(a) a = 'ABC' # a变为字符串 print(a) 这种变量本身类型不固定的语言称之为动态语言, 与之对应的是 静态语言. 静态语言在定义变量时必须指定变量类型, 如果赋值的时候类型不匹配, 就会报错.例如 Java 是静态语言, 赋值语句如下(// 表示注释): int a = 123; // a是整数类型变量 a = \"ABC\";// 错误:不能把字符串赋给整型变量 和静态语言相比, 动态语言更灵活, 就是这个原因. list 列表 Python 内置的一种数据类型是列表: list. list 是一种有序的集合, 可以随时添加和删除其中的元素. 比如, 列出班里所有同学的名字, 就可以用一个 list 表示: classmates = ['Michael', 'Bob', 'Tracy'] classmates ['Michael', 'Bob', 'Tracy'] 变量 classmates 就是一个 list. 用 len() 函数可以获得list元素的个数: len(classmates) 3 用索引来访问 list 中每一个位置的元素, 索引是从 0 开始的: classmates[0] 'Michael' classmates[1] 'Bob' classmates[2] 'Tracy' classmates[3] Traceback (most recent call last): File \"\", line 1, in IndexError: list index out of range 当索引超出了范围时, Python 会报一个 IndexError 错误, 所以, 要确保索引不要越界, 记得最后一个元素的索引是 len(classmates) - 1. 如果要取最后一个元素, 除了计算索引位置外, 还可以用 -1 做索引, 直接获取最后一个元素: classmates[-1] 'Tracy' 以此类推, 可以获取倒数第2个、倒数第3个: classmates[-2] 'Bob' classmates[-3] 'Michael' classmates[-4] Traceback (most recent call last): File \"\", line 1, in IndexError: list index out of range 当然, 倒数第4个就越界了. list 是一个可变的有序表, 所以可以往list中追加元素到末尾: classmates.append('Adam') classmates ['Michael', 'Bob', 'Tracy', 'Adam'] 也可以把元素插入到指定的位置, 比如索引号为1的位置: classmates.insert(1, 'Jack') classmates ['Michael', 'Jack', 'Bob', 'Tracy', 'Adam'] 要删除list末尾的元素, 用pop()方法: classmates.pop() 'Adam' classmates ['Michael', 'Jack', 'Bob', 'Tracy'] 要把某个元素替换成别的元素, 可以直接赋值给对应的索引位置: classmates[1] = 'Sarah' classmates ['Michael', 'Sarah', 'Tracy'] list里面的元素的数据类型也可以不同, 比如: L = ['Apple', 123, True] 如果一个list中一个元素也没有, 就是一个空的list, 它的长度为0: L = [] len(L) 0 tuple 元组 另一种有序列表叫元组: tuple. tuple 和 list 非常类似, 但是 tuple 一旦初始化就不能修改, 比如同样是列出同学的名字: classmates = ('Michael', 'Bob', 'Tracy') 现在, classmates 这个 tuple 不能变了, 它也没有 append(), insert() 这样的方法.其他获取元素的方法和 list 是一样的, 你可以正常地使用 classmates[0], classmates[-1], 但不能赋值成另外的元素. 不可变的 tuple 有什么意义?因为 tuple 不可变, 所以代码更安全. 如果可能, 能用 tuple 代替 list 就尽量用 tuple. tuple 的陷阱:当你定义一个 tuple 时, 在定义的时候, tuple 的元素就必须被确定下来, 比如: t = (1, 2) t (1, 2) 但是, 要定义一个 只有1个元素的 tuple, 如果你这么定义: t = (1) t 1 但此时,定义的不是 tuple, t 是整型变量, 变量 t 的值为1! 这是因为括号()既可以表示tuple, 又可以表示数学公式中的小括号, 这就产生了歧义, 因此, Python规定, 这种情况下, 按小括号进行计算, 计算结果自然是1. 所以, 只有 1 个元素的 tuple 定义时必须加一个逗号,, 来消除歧义: t = (1,) t (1,) Python在显示只有 1 个元素的 tuple 时, 也会加一个逗号,, 以免你误解成数学计算意义上的括号. 条件判断 if 语句的完整形式是: if : elif : elif : else: 比如: age = 20 if age >= 6: print('teenager') elif age >= 18: print('adult') else: print('kid') 循环 Python 的循环有两种, 一种是 for...in 循环, 依次把 list 或 tuple 中的每个元素迭代出来, 看例子: names = ['Michael', 'Bob', 'Tracy'] for name in names: print(name) 执行这段代码, 会依次打印 names 的每一个元素: Michael Bob Tracy 所以 for x in ... 循环就是把每个元素代入变量x, 然后执行缩进块的语句. 如果要计算 1-100 的整数之和, 从 1 写到 100 有点困难, 幸好 Python提供一个 range() 函数, 可以生成一个整数序列, 再通过 list() 函数可以转换为 list. 比如 range(5) 生成的序列是从 0 开始小于 5 的整数: list(range(5)) [0, 1, 2, 3, 4] range(101) 就可以生成 0-100 的整数序列, 计算如下: sum = 0 for x in range(101): sum = sum + x print(sum) 第二种循环是 while 循环, 比如我们要计算 100 以内所有奇数之和, 可以用 while 循环实现: sum = 0 n = 99 while n > 0: sum = sum + n n = n - 2 print(sum) 数据类型转换 Python 内置的常用函数还包括数据类型转换函数, 比如 int() 函数可以把其他数据类型转换为整数: >>> int('123') 123 >>> int(12.34) 12 >>> float('12.34') 12.34 >>> str(1.23) '1.23' >>> str(100) '100' >>> bool(1) True >>> bool('') False 函数 在 Python 中, 定义一个函数要使用 def 语句, 依次写出函数名、括号、括号中的参数和冒号:, 然后在缩进块中编写函数体, 函数的返回值用 return 语句返回. 我们先写一个计算 x2 的函数: def power(x): return x * x 对于 power(x) 函数, 参数 x 就是一个位置参数. 当我们调用 power 函数时, 必须传入有且仅有的一个参数x: power(5) 25 power(15) 225 现在, 如果我们要计算 x3 怎么办?可以再定义一个 power3 函数, 但是如果要计算x4、x5……怎么办?我们不可能定义无限多个函数. 你也许想到了, 可以把 power(x) 修改为 power(x, n), 用来计算 xn , 说干就干: def power(x, n): s = 1 while n > 0: n = n - 1 s = s * x return s 对于这个修改后的power(x, n)函数, 可以计算任意n次方: power(5, 2) 25 power(5, 3) 125 修改后的 power(x, n) 函数有两个参数: x 和 n, 这两个参数都是位置参数, 调用函数时, 传入的两个值按照位置顺序依次赋给参数x和n. 切片 取一个 list 或 tuple 的部分元素是非常常见的操作.比如, 一个list 如下: L = ['Michael', 'Sarah', 'Tracy', 'Bob', 'Jack'] 取前3个元素, 用一行代码就可以完成切片: L[0:3] ['Michael', 'Sarah', 'Tracy'] L[0:3] 表示, 从索引 0 开始取, 直到索引 3 为止, 但不包括索引3.即索引0, 1, 2, 正好是3个元素. 如果第一个索引是0, 还可以省略: L[:3] ['Michael', 'Sarah', 'Tracy'] 也可以从索引1开始, 取出2个元素出来: L[1:3] ['Sarah', 'Tracy'] tuple 也是一种 list, 唯一区别是 tuple 不可变.因此, tuple 也可以用切片操作, 只是操作的结果仍是 tuple: (0, 1, 2, 3, 4, 5)[:3] (0, 1, 2) 字符串 'xxx' 也可以看成是一种 list, 每个元素就是一个字符.因此, 字符串也可以用切片操作, 只是操作结果仍是字符串: 'ABCDEFG'[:3] 'ABC' 对象 Python 是面向对象编程的, 比如一个 LED 灯 from pyb import LED red_led = LED(1) red_led.on() LED 是一个类, red_led 就是一个对象, 可以对这个对象进行操作, 比如点亮 on, 关掉 off, 查看 value. 模块 什么是模块? 随着代码的增多，在一个文件里的代码会越来越长，越来越难看懂。 为了编写可维护的代码，我们把很多函数分组，放到不同的文件里。在Python 中，一个 .py 文件就称之为一个模块(Module). 模块有什么好处? 复用代码方便！如果我写了一个模块，你也写了一个模块，我们就有了两个模块。我们把这些模块都组织起来，大家就可以少写很多代码了！ 在 MaixPy 中如何使用模块? from machine import GPIO import time LED_RED = GPIO(GPIO.GPIOHS0, GPIOHS.PP_OUT) LCD_RED.value(0) time.sleep_ms(500) LCD_RED.value(1) time.sleep_ms(500) import time 就是引入 time 这个模块。通过 import 语句，就可以引入模块。 还有 from xxx import ooo 的语句，意思是通过 xxx 模块引入 ooo类，或者通过 xxx 模块引入 ooo 函数。比如上面的程序可以写成: python powered by GitbookFile Modify: 2020-09-11 12:05:50 "},"get_started/knowledge_image.html":{"url":"get_started/knowledge_image.html","title":"MaixPy 图像处理知识","keywords":"","body":"图像处理背景知识 什么是摄像头？ 我们都见过各种摄像头，比如 那么什么是摄像头，说到底，就是一个将光学信号转变成电信号的一个装置。在计算机视觉中，最简单的相机模型是小孔成像模型： 小孔模型是一种理想相机模型，没有考虑实际相机中存在的场曲、畸变等问题。但是在实际使用时，这些问题可以通过在标定的过程中引入畸变参数解决，所以小孔模型仍然是目前最广泛使用的相机模型。 图像透过镜头，照在一个感光芯片上，感光芯片可以把光照的波长和强度等信息转成计算机(数字电路)可以识别的数字信号，感光元件是长这样的： (中间的方形元件就是感光元件) 什么是像素和分辨率？ 感光元件是有很多个感光点构成的，比如有 640 x 480 个点，每个点就是一个像素，把每个点的像素收集整理起来，就是一副图片，那么这张图片的分辨率就是 640x480： 什么是帧率 帧率(FPS)就是每秒钟处理的图片数量，如果超过20帧，人眼就基本分辨不出卡顿。当然，如果用在机器上，帧率是越高越好的，MaixPy 的最大帧率对比： 注：没有标注均为不传输图像给 IDE，因为这个过程很耗费时间。 什么是颜色 物理上，颜色就是不同波长的电磁波。 颜色 频率 波长 紫色 668–789 THz 380–450 nm 蓝色 631–668 THz 450–475 nm 青色 606–630 THz 476–495 nm 绿色 526–606 THz 495–570 nm 黄色 508–526 THz 570–590 nm 橙色 484–508 THz 590–620 nm 红色 400–484 THz 620–750 nm 但是，根据人眼的视觉效果，可以通过 RGB，CMYK，HSB，LAB 色域，来将可见光的颜色描述出来。 RGB 三原色 三原色的原理不是物理原因，而是由于人的生理原因造成的。人的眼睛内有几种辨别颜色的锥形感光细胞，分别对黄绿色、绿色和蓝紫色(或称紫罗兰色)的光最敏感(波长分别为564、534和420纳米)。 所以 RGB 经常用于显示器上，用来显示图片。 LAB 亮度-对比度 Lab颜色空间中，L亮度；a的正数代表红色，负端代表绿色；b的正数代表黄色，负端代表兰色。不像RGB和CMYK色彩空间，Lab颜色被设计来接近人类视觉。 因此L分量可以调整亮度对，修改a和b分量的输出色阶来做精确的颜色平衡。 注意：在MaixPy的查找色块的算法中，运用的就是这个LAB模式！ 光源的选择 如果你的机器是在工业上，或者24小时长时间运行的设备，保持一个稳定的光源是至关重要的，尤其在颜色算法中。亮度一变，整个颜色的值会变化的很大！ 镜头的焦距 因为图像是通过镜头的光学折射，照到感光元件上的。那么镜头就决定了，整个画面的大小和远近。一个最重要的参数就是焦距。 镜头焦距：是指镜头光学后主点到焦点的距离，是镜头的重要性能指标。镜头焦距的长短决定着拍摄的成像大小，视场角大小，景深大小和画面的透视强弱。当对同一距离远的同一个被摄目标拍摄时，镜头焦距长的所成的象大，镜头焦距短的所成的象小。注意焦距越长，视角越小。 还有一点是镜头的畸变，因为光学原理，在感光芯片上不同的位置，与镜头的距离不同的，简单说就是近大远小，所以在边缘会出现鱼眼效果(桶型畸变)。为了解决这个问题，可以在代码中使用算法来矫正畸变，注：MaixPy中使用image.lens_corr(1.8)来矫正2.8mm焦距的镜头。也可以直接使用无畸变镜头。无畸变镜头加入了额外的矫正透镜部分，价格自然会高不少。 下面是，当 MaixPy 距离桌面20cm左右时，不同焦距镜头的对比图 标配镜头 广角镜头 无畸变镜头 长焦镜头 镜头的滤片 在镜头上，通常会有一个滤片。 这个滤片是做什么的呢？ 我们知道，不同颜色的光，是波长不一样。在正常环境中，除了可见光，还有很多红外光，在夜视中，用的就是红外光。 但是，在正常颜色应用中，是不需要红外光的，因为红外光也会使感光元件受到反应，就使得整个画面泛白。所以我们在镜头上放一个只能通过波长 650nm 以内的滤光片，将红外光进行过滤。 powered by GitbookFile Modify: 2020-09-11 12:05:50 "},"get_started/knowledge_audio.html":{"url":"get_started/knowledge_audio.html","title":"MaixPy 音频处理知识","keywords":"","body":"音频处理背景知识 powered by GitbookFile Modify: 2020-09-11 12:05:50 "},"api_reference/Maix/fpioa.html":{"url":"api_reference/Maix/fpioa.html","title":"FPIOA","keywords":"","body":"FPIOA (现场可编程 IO 阵列， Field Programmable Input and Output Array) K210 支持每个外设随意映射到任意引脚， 使用 FPIOA 功能来实现。 注意: 以下 GPIOHS 默认已经被使用， 程序中如非必要尽量不要使用： GPIOHS 功能 GPIOHS31 LCD_DC GPIOHS30 LCD_RST GPIOHS29 SD_CS GPIOHS28 MIC_LED_CLK GPIOHS27 MIC_LED_DATA 类 FPIOA 方法 help(func) 显示外设及其简要描述 参数 func： 外设名（功能/编号），可以不传参， 则以表格的形式显示所有外设名即简要描述，这个表格也可以在本页的末尾找到（附录：外设表）； 如果传参，则传一个整型值， 找到该编号对应的外设后会打印外设名和描述， 比如 FPIOA.JTAG_TCLK 或者 fm.fpioa.JTAG_TCLK（fm在本页后面介绍） 或者 0 比如： from Maix import FPIOA fpioa = FPIOA() fpioa.help() fpioa.help(0) fpioa.help(fpioa.JTAG_TCLK) fm.fpioa.help() fm.fpioa.help(fm.fpioa.JTAG_TCLK) 返回 外设名及其简要描述 set_function(pin, func) 设置引脚对应的外设功能， 即引脚映射 参数 pin： 引脚编号，取值 [0, 47]， 具体的引脚连接请看电路图， 也可以使用 board_info. 然后按 TAB 按键补全来获得板子的常用引脚，比如 board_info.LED_G func： 外设功能，传一个整型值，可以通过 fm.fpioa.help()或者查本页末尾的 附录： 外设表 表得到 比如 需要将连接 绿色 LED 的引脚映射到 高速 GPIO0 上： fpioa = FPIOA() fpioa.set_function(board_info.LED_G, fm.fpioa.GPIOHS0) get_Pin_num(func) 获取外设映射到哪个引脚上了 参数 func： 外设功能，传一个整型值，可以通过 fm.fpioa.help()或者查本页末尾的 附录： 外设表 表得到 比如： fpioa = FPIOA() fpioa.set_function(board_info.LED_G, fm.fpioa.GPIOHS0) pin = fpioa.get_Pin_num(fm.fpioa.GPIOHS0) if pin == board_info.LED_G: print(\"set function ok\") 附录： 外设表 外设功能（func） 简要描述 JTAG_TCLK JTAG Test Clock JTAG_TDI JTAG Test Data In JTAG_TMS JTAG Test Mode Select JTAG_TDO JTAG Test Data Out SPI0_D0 SPI0 Data 0 SPI0_D1 SPI0 Data 1 SPI0_D2 SPI0 Data 2 SPI0_D3 SPI0 Data 3 SPI0_D4 SPI0 Data 4 SPI0_D5 SPI0 Data 5 SPI0_D6 SPI0 Data 6 SPI0_D7 SPI0 Data 7 SPI0_SS0 SPI0 Chip Select 0 SPI0_SS1 SPI0 Chip Select 1 SPI0_SS2 SPI0 Chip Select 2 SPI0_SS3 SPI0 Chip Select 3 SPI0_ARB SPI0 Arbitration SPI0_SCLK SPI0 Serial Clock UARTHS_RX UART High speed Receiver UARTHS_TX UART High speed Transmitter RESV6 Reserved function RESV7 Reserved function CLK_SPI1 Clock SPI1 CLK_I2C1 Clock I2C1 GPIOHS0 GPIO High speed 0 GPIOHS1 GPIO High speed 1 GPIOHS2 GPIO High speed 2 GPIOHS3 GPIO High speed 3 GPIOHS4 GPIO High speed 4 GPIOHS5 GPIO High speed 5 GPIOHS6 GPIO High speed 6 GPIOHS7 GPIO High speed 7 GPIOHS8 GPIO High speed 8 GPIOHS9 GPIO High speed 9 GPIOHS10 GPIO High speed 10 GPIOHS11 GPIO High speed 11 GPIOHS12 GPIO High speed 12 GPIOHS13 GPIO High speed 13 GPIOHS14 GPIO High speed 14 GPIOHS15 GPIO High speed 15 GPIOHS16 GPIO High speed 16 GPIOHS17 GPIO High speed 17 GPIOHS18 GPIO High speed 18 GPIOHS19 GPIO High speed 19 GPIOHS20 GPIO High speed 20 GPIOHS21 GPIO High speed 21 GPIOHS22 GPIO High speed 22 GPIOHS23 GPIO High speed 23 GPIOHS24 GPIO High speed 24 GPIOHS25 GPIO High speed 25 GPIOHS26 GPIO High speed 26 GPIOHS27 GPIO High speed 27 GPIOHS28 GPIO High speed 28 GPIOHS29 GPIO High speed 29 GPIOHS30 GPIO High speed 30 GPIOHS31 GPIO High speed 31 GPIO0 GPIO pin 0 GPIO1 GPIO pin 1 GPIO2 GPIO pin 2 GPIO3 GPIO pin 3 GPIO4 GPIO pin 4 GPIO5 GPIO pin 5 GPIO6 GPIO pin 6 GPIO7 GPIO pin 7 UART1_RX UART1 Receiver UART1_TX UART1 Transmitter UART2_RX UART2 Receiver UART2_TX UART2 Transmitter UART3_RX UART3 Receiver UART3_TX UART3 Transmitter SPI1_D0 SPI1 Data 0 SPI1_D1 SPI1 Data 1 SPI1_D2 SPI1 Data 2 SPI1_D3 SPI1 Data 3 SPI1_D4 SPI1 Data 4 SPI1_D5 SPI1 Data 5 SPI1_D6 SPI1 Data 6 SPI1_D7 SPI1 Data 7 SPI1_SS0 SPI1 Chip Select 0 SPI1_SS1 SPI1 Chip Select 1 SPI1_SS2 SPI1 Chip Select 2 SPI1_SS3 SPI1 Chip Select 3 SPI1_ARB SPI1 Arbitration SPI1_SCLK SPI1 Serial Clock SPI_SLAVE_D0 SPI Slave Data 0 SPI_SLAVE_SS SPI Slave Select SPI_SLAVE_SCLK SPI Slave Serial Clock I2S0_MCLK I2S0 Master Clock I2S0_SCLK I2S0 Serial Clock(BCLK) I2S0_WS I2S0 Word Select(LRCLK) I2S0_IN_D0 I2S0 Serial Data Input 0 I2S0_IN_D1 I2S0 Serial Data Input 1 I2S0_IN_D2 I2S0 Serial Data Input 2 I2S0_IN_D3 I2S0 Serial Data Input 3 I2S0_OUT_D0 I2S0 Serial Data Output 0 I2S0_OUT_D1 I2S0 Serial Data Output 1 I2S0_OUT_D2 I2S0 Serial Data Output 2 I2S0_OUT_D3 I2S0 Serial Data Output 3 I2S1_MCLK I2S1 Master Clock I2S1_SCLK I2S1 Serial Clock(BCLK) I2S1_WS I2S1 Word Select(LRCLK) I2S1_IN_D0 I2S1 Serial Data Input 0 I2S1_IN_D1 I2S1 Serial Data Input 1 I2S1_IN_D2 I2S1 Serial Data Input 2 I2S1_IN_D3 I2S1 Serial Data Input 3 I2S1_OUT_D0 I2S1 Serial Data Output 0 I2S1_OUT_D1 I2S1 Serial Data Output 1 I2S1_OUT_D2 I2S1 Serial Data Output 2 I2S1_OUT_D3 I2S1 Serial Data Output 3 I2S2_MCLK I2S2 Master Clock I2S2_SCLK I2S2 Serial Clock(BCLK) I2S2_WS I2S2 Word Select(LRCLK) I2S2_IN_D0 I2S2 Serial Data Input 0 I2S2_IN_D1 I2S2 Serial Data Input 1 I2S2_IN_D2 I2S2 Serial Data Input 2 I2S2_IN_D3 I2S2 Serial Data Input 3 I2S2_OUT_D0 I2S2 Serial Data Output 0 I2S2_OUT_D1 I2S2 Serial Data Output 1 I2S2_OUT_D2 I2S2 Serial Data Output 2 I2S2_OUT_D3 I2S2 Serial Data Output 3 RESV0 Reserved function RESV1 Reserved function RESV2 Reserved function RESV3 Reserved function RESV4 Reserved function RESV5 Reserved function I2C0_SCLK I2C0 Serial Clock I2C0_SDA I2C0 Serial Data I2C1_SCLK I2C1 Serial Clock I2C1_SDA I2C1 Serial Data I2C2_SCLK I2C2 Serial Clock I2C2_SDA I2C2 Serial Data CMOS_XCLK DVP System Clock CMOS_RST DVP System Reset CMOS_PWDN DVP Power Down Mode CMOS_VSYNC DVP Vertical Sync CMOS_HREF DVP Horizontal Reference output CMOS_PCLK Pixel Clock CMOS_D0 Data Bit 0 CMOS_D1 Data Bit 1 CMOS_D2 Data Bit 2 CMOS_D3 Data Bit 3 CMOS_D4 Data Bit 4 CMOS_D5 Data Bit 5 CMOS_D6 Data Bit 6 CMOS_D7 Data Bit 7 SCCB_SCLK SCCB Serial Clock SCCB_SDA SCCB Serial Data UART1_CTS UART1 Clear To Send UART1_DSR UART1 Data Set Ready UART1_DCD UART1 Data Carrier Detect UART1_RI UART1 Ring Indicator UART1_SIR_IN UART1 Serial Infrared Input UART1_DTR UART1 Data Terminal Ready UART1_RTS UART1 Request To Send UART1_OUT2 UART1 User-designated Output 2 UART1_OUT1 UART1 User-designated Output 1 UART1_SIR_OUT UART1 Serial Infrared Output UART1_BAUD UART1 Transmit Clock Output UART1_RE UART1 Receiver Output Enable UART1_DE UART1 Driver Output Enable UART1_RS485_EN UART1 RS485 Enable UART2_CTS UART2 Clear To Send UART2_DSR UART2 Data Set Ready UART2_DCD UART2 Data Carrier Detect UART2_RI UART2 Ring Indicator UART2_SIR_IN UART2 Serial Infrared Input UART2_DTR UART2 Data Terminal Ready UART2_RTS UART2 Request To Send UART2_OUT2 UART2 User-designated Output 2 UART2_OUT1 UART2 User-designated Output 1 UART2_SIR_OUT UART2 Serial Infrared Output UART2_BAUD UART2 Transmit Clock Output UART2_RE UART2 Receiver Output Enable UART2_DE UART2 Driver Output Enable UART2_RS485_EN UART2 RS485 Enable UART3_CTS UART3 Clear To Send UART3_DSR UART3 Data Set Ready UART3_DCD UART3 Data Carrier Detect UART3_RI UART3 Ring Indicator UART3_SIR_IN UART3 Serial Infrared Input UART3_DTR UART3 Data Terminal Ready UART3_RTS UART3 Request To Send UART3_OUT2 UART3 User-designated Output 2 UART3_OUT1 UART3 User-designated Output 1 UART3_SIR_OUT UART3 Serial Infrared Output UART3_BAUD UART3 Transmit Clock Output UART3_RE UART3 Receiver Output Enable UART3_DE UART3 Driver Output Enable UART3_RS485_EN UART3 RS485 Enable TIMER0_TOGGLE1 TIMER0 Toggle Output 1 TIMER0_TOGGLE2 TIMER0 Toggle Output 2 TIMER0_TOGGLE3 TIMER0 Toggle Output 3 TIMER0_TOGGLE4 TIMER0 Toggle Output 4 TIMER1_TOGGLE1 TIMER1 Toggle Output 1 TIMER1_TOGGLE2 TIMER1 Toggle Output 2 TIMER1_TOGGLE3 TIMER1 Toggle Output 3 TIMER1_TOGGLE4 TIMER1 Toggle Output 4 TIMER2_TOGGLE1 TIMER2 Toggle Output 1 TIMER2_TOGGLE2 TIMER2 Toggle Output 2 TIMER2_TOGGLE3 TIMER2 Toggle Output 3 TIMER2_TOGGLE4 TIMER2 Toggle Output 4 CLK_SPI2 Clock SPI2 CLK_I2C2 Clock I2C2 powered by GitbookFile Modify: 2020-09-11 12:05:50 "},"api_reference/Maix/gpio.html":{"url":"api_reference/Maix/gpio.html","title":"GPIO","keywords":"","body":"GPIO General Purpose Input Output （通用输入/输出）简称为 GPIO，或总线扩展器。 K210上有高速 GPIO(GPIOHS) 和通用 GPIO 在 K210 上， GPIO 有一下特征： 高速 GPIO： 高速 GPIO 为 GPIOHS，共 32 个。具有如下特点： 可配置输入输出信号 每个 IO 具有独立中断源 中断支持边沿触发和电平触发 每个 IO 可以分配到 FPIOA 上 48 个管脚之一 可配置上下拉，或者高阻 通用 GPIO： 通用 GPIO 共 8 个，具有如下特点: 8 个 IO 使用一个中断源 可配置输入输出信号 可配置触发 IO 总中断，边沿触发和电平触发 每个 IO 可以分配到 FPIOA 上 48 个管脚之一 注意: 一下 GPIOHS 默认已经被使用， 程序中如非必要尽量不要使用： GPIOHS 功能 GPIOHS31 LCD_DC GPIOHS30 LCD_RST GPIOHS29 SD_CS GPIOHS28 MIC_LED_CLK GPIOHS27 MIC_LED_DATA 构造函数 class GPIO(ID, MODE, PULL, VALUE) 通过指定的参数新建一个 SPI 对象 参数 ID： 使用的 GPIO 引脚(一定要使用 GPIO 里带的常量来指定) MODE： GPIO模式 • GPIO.IN就是输入模式 • GPIO.OUT就是输出模式 PULL： GPIO上下拉模式 • GPIO.PULL_UP 上拉 ​• GPIO.PULL_DOWN 下拉 ​• GPIO.PULL_NONE 即不上拉也不下拉 方法 value 修改/读取 GPIO 引脚状态 GPIO.value([value]) 参数 [value]： 可选参数，如果此参数不为空，则返回当前 GPIO 引脚状态 返回值 如果 [value] 参数不为空，则返回当前 GPIO 引脚状态 irq 配置一个中断处理程序，当 pin 的触发源处于活动状态时调用它。如果管脚模式为 pin.in，则触发源是管脚上的外部值。 GPIO.irq(CALLBACK_FUNC,TRIGGER_CONDITION,GPIO.WAKEUP_NOT_SUPPORT,PRORITY) 参数 CALLBACK_FUNC：中断回调函数，当中断触发的时候被调用，一个入口函数 pin_num ​• PIN_NUM 返回的是触发中断的 GPIO 引脚号(只有GPIOHS支持中断，所以这里的引脚号也是GPIOHS的引脚号) TRIGGER_CONDITION：GPIO 引脚的中断触发模式 ​• GPIO.IRQ_RISING 上升沿触发 ​• GPIO.IRQ_FALLING 下降沿触发 ​• GPIO.IRQ_BOTH 上升沿和下降沿都触发 返回值 无 disirq 关闭中断 GPIO.disirq() 参数 无 返回值 无 mode GPIO模式 GPIO.mode(MODE) 参数 MODE • GPIO.IN 就是输入模式 • GPIO.OUT 就是输出模式 返回值 无 pull GPIO上下拉模式 GPIO.pull(PULL) 参数 PULL • GPIO.IRQ_RISING 上升沿触发 • GPIO.IRQ_FALLING 下降沿触发 • GPIO.IRQ_BOTH 上升沿和下降沿都触发 返回值 无 常量 GPIO0: GPIO0 GPIO1: GPIO1 GPIO2: GPIO2 GPIO3: GPIO3 GPIO4: GPIO4 GPIO5: GPIO5 GPIO6: GPIO6 GPIO7: GPIO7 GPIOHS0: GPIOHS0 GPIOHS1: GPIOHS1 GPIOHS2: GPIOHS2 GPIOHS3: GPIOHS3 GPIOHS4: GPIOHS4 GPIOHS5: GPIOHS5 GPIOHS6: GPIOHS6 GPIOHS7: GPIOHS7 GPIOHS8: GPIOHS8 GPIOHS9: GPIOHS9 GPIOHS10: GPIOHS10 GPIOHS11: GPIOHS11 GPIOHS12: GPIOHS12 GPIOHS13: GPIOHS13 GPIOHS14: GPIOHS14 GPIOHS15: GPIOHS15 GPIOHS16: GPIOHS16 GPIOHS17: GPIOHS17 GPIOHS18: GPIOHS18 GPIOHS19: GPIOHS19 GPIOHS20: GPIOHS20 GPIOHS21: GPIOHS21 GPIOHS22: GPIOHS22 GPIOHS23: GPIOHS23 GPIOHS24: GPIOHS24 GPIOHS25: GPIOHS25 GPIOHS26: GPIOHS26 GPIOHS27: GPIOHS27 GPIOHS28: GPIOHS28 GPIOHS29: GPIOHS29 GPIOHS30: GPIOHS30 GPIOHS31: GPIOHS31 GPIO.IN: 输入模式 GPIO.OUT: 输出模式 GPIO.PULL_UP: 上拉 GPIO.PULL_DOWN: 下拉 GPIO.PULL_NONE: 即不上拉也不下拉 GPIO.IRQ_RISING: 上升沿触发 GPIO.IRQ_FALLING:下降沿触发 GPIO.IRQ_BOTH: 上升沿和下降沿都触发 DEMO1: 点亮 LED import utime from Maix import GPIO from board import board_info from fpioa_manager import fm fm.register(board_info.LED_R,fm.fpioa.GPIO0) led_r=GPIO(GPIO.GPIO0,GPIO.OUT) utime.sleep_ms(500) led_r.value() fm.unregister(board_info.LED_R,fm.fpioa.GPIO0) DEMO2: 按键按下点亮 LED import utime from Maix import GPIO from board import board_info from fpioa_manager import fm fm.register(board_info.LED_R,fm.fpioa.GPIO0) led_b = GPIO(GPIO.GPIO0,GPIO.OUT) led_b.value(1) fm.register(board_info.BOOT_KEY, fm.fpioa.GPIOHS1) key = GPIO(GPIO.GPIOHS1, GPIO.IN) utime.sleep_ms(100) while True: if key.value() == 0: # 等待按键按下 led_b.value(0) utime.sleep_ms(1000) break utime.sleep_ms(10) led_b.value(1) fm.unregister(board_info.LED_R,fm.fpioa.GPIOHS0) fm.unregister(board_info.BOOT_KEY,fm.fpioa.GPIOHS1) DEMO3: 在 3 秒内等待按键触发中断 import utime from Maix import GPIO from board import board_info from fpioa_manager import fm def test_irq(pin_num): print(\"key\", pin_num, \"\\n\") fm.register(board_info.BOOT_KEY, fm.fpioa.GPIOHS0) key = GPIO(GPIO.GPIOHS0, GPIO.IN, GPIO.PULL_NONE) utime.sleep_ms(100) key.irq(test_irq, GPIO.IRQ_BOTH, GPIO.WAKEUP_NOT_SUPPORT,7) utime.sleep_ms(3000) # 在 3 秒内等待触发 key.disirq() # 禁用中断 fm.unregister(board_info.BOOT_KEY,fm.fpioa.GPIOHS0) powered by GitbookFile Modify: 2020-09-11 12:05:50 "},"api_reference/Maix/i2s.html":{"url":"api_reference/Maix/i2s.html","title":"I2S","keywords":"","body":"I2S I2S模块主要用于驱动I2S设备，k210一共有3个I2S设备，每个设备一共有4个通道，在使用前需要对引脚进行映射管理 模块函数 构造函数 新建一个 I2S 对象 from Maix import I2S i2s_dev = I2S(device_num) 参数 device_num UART号，使用指定的 I2S，可以通过 I2S. 按tab键来补全 返回值 返回一个I2S 对象 通道配置函数 用于配置 I2S 通道，在此之前需要对引脚进行映射 i2s_dev.channel_config(channel, mode, resolution, cycles, align_mode) 参数 channel: I2S通道编号 mode: 通道传输模式，一共有接收和发送模式，录音为接受，播放为发送 resolution: 通道分辨率，即接收数据位数 cycles: 单个数据时钟数 align_mode: 通道对齐模式 返回值 无 设置采样率 用于配置 I2S 采样率 i2s_dev.set_sample_rate(sample_rate) 参数 sample_rate: 返回值 无 接收音频 使用I2S接收音频数据 audio = i2s_dev.record(points) 参数 points: 一次采集的音频点数 返回值 audio: 一个audio音频对象 发送音频 使用I2S发送音频数据 i2s_dev.play(audio) 参数 audio: 发送的音频对象 返回值 无 例程 例程1 from Maix import I2S import time fm.register(20,fm.fpioa.I2S0_IN_D0)#GO fm.register(19,fm.fpioa.I2S0_WS) fm.register(18,fm.fpioa.I2S0_SCLK) fm.register(34,fm.fpioa.I2S2_OUT_D1) fm.register(35,fm.fpioa.I2S2_SCLK) fm.register(33,fm.fpioa.I2S2_WS) sample_rate = 44*1000 rx = I2S(I2S.DEVICE_0) rx.channel_config(rx.CHANNEL_0, rx.RECEIVER, align_mode = I2S.STANDARD_MODE) rx.set_sample_rate(sample_rate) tx = I2S(I2S.DEVICE_2) tx.channel_config(tx.CHANNEL_1, tx.TRANSMITTER, align_mode = I2S.RIGHT_JUSTIFYING_MODE) tx.set_sample_rate(sample_rate) while True: audio = rx.record(256)#sampling points number must be smaller than 256 tx.play(audio) 例程2 from Maix import I2S from Maix import Audio from Maix import FFT import time fm.register(20,fm.fpioa.I2S0_IN_D0) fm.register(19,fm.fpioa.I2S0_WS) fm.register(18,fm.fpioa.I2S0_SCLK) fm.register(34,fm.fpioa.I2S2_OUT_D1) fm.register(35,fm.fpioa.I2S2_SCLK) fm.register(33,fm.fpioa.I2S2_WS) rx = I2S(I2S.DEVICE_0) rx.channel_config(rx.CHANNEL_0, rx.RECEIVER, align_mode = I2S.STANDARD_MODE) rx.set_sample_rate(16000) tx = I2S(I2S.DEVICE_2) tx.channel_config(tx.CHANNEL_1, tx.TRANSMITTER, align_mode = I2S.RIGHT_JUSTIFYING_MODE) tx.set_sample_rate(16000) while True: audio = rx.record(256) audio_data = audio.to_bytes() play_audio = Audio(audio_data) tx.play(play_audio) powered by GitbookFile Modify: 2020-09-11 12:05:50 "},"api_reference/machine/i2c.html":{"url":"api_reference/machine/i2c.html","title":"I2C","keywords":"","body":"machine.I2C I2C 总线协议，简单地使用两条线（SCL，SDA）可以控制多个从机（主机模式）。 支持主机模式和从机模式 7 位/10 位寻址模式 标准模式 快速模式 超快速模式 高速模式 3.4Mb/s 构造函数 class machine.I2C(id, mode=I2C.MODE_MASTER, scl=None, sda=None, freq=400000, timeout=1000, addr=0, addr_size=7, on_recieve=None, on_transmit=None, on_event=None) 通过指定的参数新建一个 I2C 对象 参数 id： I2C ID, [0~2] (I2C.I2C0~I2C.I2C2) mode： 模式， 主机(I2C.MODE_MASTER)和从机（I2C.MODE_SLAVE)模式 scl： SCL 引脚，直接传引脚编号即可，取值范围： [0,47]。 可以不设置，而是使用 fm 统一管理引脚映射。 sda： SDA 引脚，直接传引脚编号即可，取值范围： [0,47]。 可以不设置，而是使用 fm 统一管理引脚映射。 freq： I2C通信频率， 支持标准100Kb/s, 快速400Kb/s， 以及更高速率（硬件支持超快速模式1000Kb/s，以及高速模式3.4Mb/s） timeout： 超时时间，目前这个参数保留，设置无效 addr： 从机地址，如果是主机模式不用设置， 从机模式则代表从机（本机）地址 addr_size： 地址长度， 支持 7 位寻址和 10 位寻址， 取值7或者10 on_recieve： 从机模式的接收回调函数 on_transmit： 从机模式的发送回调函数 on_event： 从机模式的事件函数（开始事件和结束事件） 方法 init 类似构造函数 I2C.init(id, mode=Timer.MODE_MASTER, scl, sda, freq=400000, timeout=1000, addr=0, addr_size=7, on_recieve=None, on_transmit=None, on_event=None) 参数 与构造函数相同 返回值 无 scan 扫描I2C总线上的从机 I2C.scan() 参数 无 返回值 list 对象， 包含了所有扫描到的从机地址 readfrom 从总线读取数据 I2C.readfrom(addr, len, stop=True) 参数 addr: 从机地址 len： 数据长度 stop： 是否产生停止信号，保留，目前只能使用默认值Ture 返回值 读取到的数据，bytes 类型 readfrom_into 读取数据并放到制定变量中 I2C.readfrom_into(addr, buf, stop=True) 参数 addr: 从机地址 buf： bytearray类型， 定义了长度，读取到的数据存放在此 stop： 是否产生停止信号，保留，目前只能使用默认值Ture 返回值 无 writeto 发送数据到从机 I2C.writeto(addr, buf, stop=True) 参数 addr: 从机地址 buf： 需要发送的数据 stop： 是否产生停止信号，保留，目前只能使用默认值Ture 返回值 成功发送的字节数 readfrom_mem 读取从机寄存器 I2C.readfrom_mem(addr, memaddr, nbytes, mem_size=8) 参数 addr: 从机地址 memaddr： 从机寄存器地址 nbytes： 需要读取的长度 mem_size： 寄存器宽度， 默认为8位 返回值 返回bytes类型的读取到的数据 readfrom_mem_into 读取从机寄存器值到指定变量中 I2C.readfrom_mem_into(addr, memaddr, buf, mem_size=8) 参数 addr: 从机地址 memaddr： 从机寄存器地址 buf： bytearray类型， 定义了长度，读取到的数据存放在此 mem_size： 寄存器宽度， 默认为8位 返回值 无 writeto_mem 写数据到从机寄存器 I2C.writeto_mem(addr, memaddr, buf, mem_size=8) 参数 addr: 从机地址 memaddr： 从机寄存器地址 buf： 需要写的数据 mem_size： 寄存器宽度， 默认为8位 返回值 无 deinit/_del_ 注销I2C硬件，释放占用的资源，关闭I2C时钟 I2C.deinit() 参数 无 返回值 无 例子 i2c.deinit() 或者 del i2c 常量 I2C0: I2C 0 I2C1: I2C 1 I2C2: I2C 2 MODE_MASTER: 作为主机模式 MODE_SLAVE: 作为从机模式 I2C_EV_START: 事件类型，开始信号 I2C_EV_RESTART: 事件类型，重新开始信号 I2C_EV_STOP: 事件类型，结束信号 例程 例程 1： 扫描从机设备 from machine import I2C i2c = I2C(I2C.I2C0, freq=100000, scl=28, sda=29) devices = i2c.scan() print(devices) 例程 2： 读写 import time from machine import I2C i2c = I2C(I2C.I2C0, freq=100000, scl=28, sda=29) i2c.writeto(0x24,b'123') i2c.readfrom(0x24,5) 例程 3： 从机模式 from machine import I2C count = 0 def on_receive(data): print(\"on_receive:\",data) def on_transmit(): count = count+1 print(\"on_transmit, send:\",count) return count def on_event(event): print(\"on_event:\",event) i2c = I2C(I2C.I2C0, mode=I2C.MODE_SLAVE, scl=28, sda=29, addr=0x24, addr_size=7, on_receive=on_receive, on_transmit=on_transmit, on_event=on_event) 例程 4： OLED(ssd1306 128x64) import time from machine import I2C SSD1306_CMD = 0 SSD1306_DATA = 1 SSD1306_ADDR = 0x3c def oled_init(i2c): i2c.writeto_mem(SSD1306_ADDR, 0x00, 0xAE, mem_size=8) i2c.writeto_mem(SSD1306_ADDR, 0x00, 0x20, mem_size=8) i2c.writeto_mem(SSD1306_ADDR, 0x00, 0x10, mem_size=8) i2c.writeto_mem(SSD1306_ADDR, 0x00, 0xb0, mem_size=8) i2c.writeto_mem(SSD1306_ADDR, 0x00, 0xc8, mem_size=8) i2c.writeto_mem(SSD1306_ADDR, 0x00, 0x00, mem_size=8) i2c.writeto_mem(SSD1306_ADDR, 0x00, 0x10, mem_size=8) i2c.writeto_mem(SSD1306_ADDR, 0x00, 0x40, mem_size=8) i2c.writeto_mem(SSD1306_ADDR, 0x00, 0x81, mem_size=8) i2c.writeto_mem(SSD1306_ADDR, 0x00, 0xff, mem_size=8) i2c.writeto_mem(SSD1306_ADDR, 0x00, 0xa1, mem_size=8) i2c.writeto_mem(SSD1306_ADDR, 0x00, 0xa6, mem_size=8) i2c.writeto_mem(SSD1306_ADDR, 0x00, 0xa8, mem_size=8) i2c.writeto_mem(SSD1306_ADDR, 0x00, 0x3F, mem_size=8) i2c.writeto_mem(SSD1306_ADDR, 0x00, 0xa4, mem_size=8) i2c.writeto_mem(SSD1306_ADDR, 0x00, 0xd3, mem_size=8) i2c.writeto_mem(SSD1306_ADDR, 0x00, 0x00, mem_size=8) i2c.writeto_mem(SSD1306_ADDR, 0x00, 0xd5, mem_size=8) i2c.writeto_mem(SSD1306_ADDR, 0x00, 0xf0, mem_size=8) i2c.writeto_mem(SSD1306_ADDR, 0x00, 0xd9, mem_size=8) i2c.writeto_mem(SSD1306_ADDR, 0x00, 0x22, mem_size=8) i2c.writeto_mem(SSD1306_ADDR, 0x00, 0xda, mem_size=8) i2c.writeto_mem(SSD1306_ADDR, 0x00, 0x12, mem_size=8) i2c.writeto_mem(SSD1306_ADDR, 0x00, 0xdb, mem_size=8) i2c.writeto_mem(SSD1306_ADDR, 0x00, 0x20, mem_size=8) i2c.writeto_mem(SSD1306_ADDR, 0x00, 0x8d, mem_size=8) i2c.writeto_mem(SSD1306_ADDR, 0x00, 0x14, mem_size=8) i2c.writeto_mem(SSD1306_ADDR, 0x00, 0xaf, mem_size=8) def oled_on(i2c): i2c.writeto_mem(SSD1306_ADDR, 0x00, 0X8D, mem_size=8) i2c.writeto_mem(SSD1306_ADDR, 0x00, 0X14, mem_size=8) i2c.writeto_mem(SSD1306_ADDR, 0x00, 0XAF, mem_size=8) def oled_off(i2c): i2c.writeto_mem(SSD1306_ADDR, 0x00, 0X8D, mem_size=8) i2c.writeto_mem(SSD1306_ADDR, 0x00, 0X10, mem_size=8) i2c.writeto_mem(SSD1306_ADDR, 0x00, 0XAE, mem_size=8) def oled_fill(i2c, data): for i in range(0,8): i2c.writeto_mem(SSD1306_ADDR, 0x00, 0xb0+i, mem_size=8) i2c.writeto_mem(SSD1306_ADDR, 0x00, 0x10, mem_size=8) i2c.writeto_mem(SSD1306_ADDR, 0x00, 0x01, mem_size=8) for j in range(0,128): i2c.writeto_mem(SSD1306_ADDR, 0x40, data, mem_size=8) i2c = I2C(I2C.I2C0, mode=I2C.MODE_MASTER, freq=400000, scl=28, sda=29, addr_size=7) time.sleep(1) oled_init(i2c) oled_fill(i2c, 0xff) powered by GitbookFile Modify: 2020-09-11 12:05:50 "},"api_reference/machine/pwm.html":{"url":"api_reference/machine/pwm.html","title":"PWM","keywords":"","body":"machine.PWM PWM： 脉宽调制模块， 硬件支持的PWM， 可以指定任意引脚（0到47引脚） 每个 PWM 依赖于一个定时器， 即当定时器与 PWM 功能绑定后， 不能作为普通定时器使用了。 因为有 3 个定时器， 每个定时器有 4 个通道， 即最大可以同时产生 12 路 PWM 波形 构造函数 class machine.PWM(tim, freq, duty, pin, enable=True) 通过指定的参数新建一个 PWM 对象 参数 tim: 每个PWM依赖一个定时器来产生波形， 所以这里需要传一个定时器对象，这个定时器对象必须初始化时必须指定定时器 ID 和通道号 freq： PWM 波形频率 duty： PWM 占空比， 指高电平占整个周期的百分比，取值：[0,100] [pin]： PWM 输出引脚。 可以不设置，而是使用 fm 统一管理引脚映射。 enable： 是否立即开始产生波形，默认位True，及对象生成后立即开始在指定的引脚上产生 PWM 波形 方法 init 类似构造函数 PWM.init(tim, freq, duty, pin, enable=True) 参数 与构造函数相同 返回值 无 freq 获取或者设置 PWM 频率 PWM.freq(freq) 参数 freq： PWM 频率， 可选参数， 如果不传参数则步设置只返回当前频率值 返回值 当前设置的实际的 PWM 频率 duty 获取或者设置 PWM 占空比 PWM.duty(duty) 参数 duty： PWM 占空比 可选， 如果不传参数则步设置只返回当前占空比值 返回值 当前设置的 PWM 占空比值 enable 使能 PWM 输出， 使指定的引脚上立即产生波形 PWM.enable() 参数 无 返回值 无 disable 失能 PWM 输出， 指定的引脚不再产生波形 PWM.disable() 参数 无 返回值 无 deinit/_del_ 注销 PWM 硬件，释放占用的资源，关闭 PWM 时钟 PWM.deinit() 参数 无 返回值 无 例子 pwm.deinit() 或者 del pwm 常量 无 例程 例程 1 （呼吸灯） from machine import Timer,PWM import time from fpioa_manager import board_info tim = Timer(Timer.TIMER0, Timer.CHANNEL0, mode=Timer.MODE_PWM) ch = PWM(tim, freq=500000, duty=50, pin=board_info.LED_G) duty=0 dir = True while True: if dir: duty += 10 else: duty -= 10 if duty>100: duty = 100 dir = False elif duty 例程 2 import time import machine from fpioa_manager import board_info tim = machine.Timer(machine.Timer.TIMER0, machine.Timer.CHANNEL0, mode=machine.Timer.MODE_PWM) ch0 = machine.PWM(tim, freq=3000000, duty=20, pin=board_info.LED_G, enable=False) ch0.enable() time.sleep(3) ch0.freq(2000000) print(\"freq:\",ch0.freq()) ch0.duty(60) time.sleep(3) ch0.disable() powered by GitbookFile Modify: 2020-09-11 12:05:50 "},"api_reference/machine/spi.html":{"url":"api_reference/machine/spi.html","title":"SPI","keywords":"","body":"machine.SPI SPI（Serial Peripheral Interface） 是一个同步串行协议，由主机和从机组成。 标准4线模式由 SCK（SCLK）， CS（片选）， MOSI， MISO 4条线连接主从机 在 K210 上， SPI 有一下特征： 共有 4 个 SPI 设备， 其中 SPI0 、SPI1、 SPI3 只能工作在主机模式下， SPI2 只能工作在从机模式时下， 在 MaixPy 上， SPI3已经用来连接了 SPI Flash， 暂时保留， 以后如果有必要再考虑开放接口与 SPI Flash 分时复用 支持 1/2/4/8 线全双工模式， 在 MaixPy 中， 目前只支持标准（摩托罗拉）4线全双工模式（即 SCK， MOSI， MISO， CS 四个引脚） 最高传输速率 45M：1/2主频，约 200Mbps 支持 DMA 4个可配置任意引脚的硬件片选 构造函数 class machine.SPI(id, mode=SPI.MODE_MASTER, baudrate=500000, polarity=0, phase=0, bits=8, firstbit=SPI.MSB, sck, mosi, miso, cs0, cs1, cs2, cs3) 通过指定的参数新建一个 SPI 对象 参数 id： SPI ID， 取值范围[0,3]， 目前只支持 0 和 1， 并且只能是主机模式， 2 只能作为从机，目前未实现， 3 保留 mode： SPI 模式， MODE_MASTER 或者MODE_MASTER_2或者MODE_MASTER_4或者MODE_MASTER_8或者MODE_SLAVE， 目前只支持MODE_MASTER baudrate： SPI 波特率（频率） polarity： 极性， 取值为 0 或 1， 表示 SPI 在空闲时的极性， 0 代表低电平， 1 代表高电平 phase： 相， 取值位 0 或 1， 表示在时钟的第一个还是第二个跳变沿采集数据， 0 表示第一个， 1 表示第二个 bits： 数据宽度， 默认值为8， 取值范围[4,32] firstbit： 指定传输采用 MSB 还是 LSB 顺序传输， 默认 SPI.MSB sck: SCK（时钟）引脚， 可直接传引脚数值，取值范围：[0,47]。 可以不设置，而是使用 fm 统一管理引脚映射。 mosi: MOSI（主机输出） 引脚， 可直接传引脚数值，取值范围：[0,47]。 可以不设置，而是使用 fm 统一管理引脚映射。 miso: MISO（主机输入） 引脚， 可直接传引脚数值，取值范围：[0,47]。 可以不设置，而是使用 fm 统一管理引脚映射。 cs0: CS0（片选） 引脚， 可直接传引脚数值，取值范围：[0,47]。 可以不设置，而是使用 fm 统一管理引脚映射。 cs1: CS1（片选） 引脚， 可直接传引脚数值，取值范围：[0,47]。 可以不设置，而是使用 fm 统一管理引脚映射。 cs2: CS2（片选） 引脚， 可直接传引脚数值，取值范围：[0,47]。 可以不设置，而是使用 fm 统一管理引脚映射。 cs3: CS3（片选） 引脚， 可直接传引脚数值，取值范围：[0,47]。 可以不设置，而是使用 fm 统一管理引脚映射。 d0~d7： 数据引脚， 在非标准4线模式中使用，目前保留。 可以不设置，而是使用 fm 统一管理引脚映射。 方法 init 类似构造函数 SPI.init(id, mode=SPI.MODE_MASTER, baudrate=500000, polarity=0, phase=0, bits=8, firstbit=SPI.MSB, sck, mosi, miso, cs0) 参数 与构造函数相同 返回值 无 read 读取数据 SPI.read(nbytes, write=0x00, cs=SPI.CS0) 参数 nbytes： 需要读取的长度 cs： 选择片选引脚， 在初始化时已经为cs0~cs3设置了引脚，这里只需要选择SPI.CS0~SPI.CS3即可，默认为SPI.CS0 write： 因为是全双工，设置在读取时MOSI引脚的值，默认为0x00，即始终为低电平 返回值 bytes类型的数据 readinto 读取数据，并放到指定变量中 SPI.readinto(buf, write=0x00, cs=SPI.CS0) 参数 buf： bytearray 类型， 定义了长度，读取完成后数据保存在此 cs： 选择片选引脚， 在初始化时已经为cs0~cs3设置了引脚，这里只需要选择SPI.CS0~SPI.CS3即可，默认为SPI.CS0 write： 因为是全双工，设置在读取时MOSI引脚的值，默认为0x00，即始终为低电平 返回值 无 write 发送数据 SPI.write(buf, cs=SPI.CS0) 参数 buf： bytearray 类型， 定义了数据及长度 cs： 选择片选引脚， 在初始化时已经为cs0~cs3设置了引脚，这里只需要选择SPI.CS0~SPI.CS3即可，默认为SPI.CS0 返回值 无 write_readinto 发送数据，同时读取数据到变量，即全双工 SPI.write(write_buf, read_buf, cs=SPI.CS0) 参数 write_buf： bytearray 类型， 定义了需要发送的数据及长度 read_buf： bytearray 类型， 定义了接收数据存放的位置 cs： 选择片选引脚， 在初始化时已经为cs0~cs3设置了引脚，这里只需要选择SPI.CS0~SPI.CS3即可，默认为SPI.CS0 返回值 无 deinit/_del_ 注销 SPI，释放硬件，关闭 SPI 时钟 SPI.deinit() 参数 无 返回值 无 例子 spi.deinit() 或者 del spi 常量 SPI0: SPI 0 SPI1: SPI 1 SPI2: SPI 2 MODE_MASTER: 作为主机模式 MODE_MASTER_2: 作为主机模式 MODE_MASTER_4: 作为主机模式 MODE_MASTER_8: 作为主机模式 MODE_SLAVE: 作为从机模式 MSB： MSB， 即先发送高位或高字节 LSB： LSB， 即先发送低位或者低字节 CS0： 片选0 CS1： 片选1 CS2： 片选2 CS3： 片选3 例程 例程 1： 基本读写 from machine import SPI spi1 = SPI(SPI.SPI1, mode=SPI.MODE_MASTER, baudrate=10000000, polarity=0, phase=0, bits=8, firstbit=SPI.MSB, sck=28, mosi=29, miso=30, cs0=27) w = b'1234' r = bytearray(4) spi1.write(w) spi1.write(w, cs=SPI.CS0) spi1.write_readinto(w, r) spi1.read(5, write=0x00) spi1.readinto(r, write=0x00) powered by GitbookFile Modify: 2020-09-11 12:05:50 "},"api_reference/machine/timer.html":{"url":"api_reference/machine/timer.html","title":"Timer","keywords":"","body":"machine.Timer 硬件定时器，可以用来定时触发任务或者处理任务，设定时间到了后可以触发中断（调用回调函数），精度比软件定时器高。 需要注意的是，定时器在不同的硬件中可能会有不同的表现。MicroPython 的 Timer 类定义了在给定时间段内（或在一段延迟后执行一次回调）执行回调的基本操作，并允许特定的硬件上定义更多的非标准行为（因此不能移植到其他板）。 共有 3 个定时器， 每个定时器有 4 个通道可以使用 构造函数 class machine.Timer(id, channel, mode=Timer.MODE_ONE_SHOT, period=1000, unit=Timer.UNIT_MS, callback=None, arg=None, start=True, priority=1, div=0) 通过指定的参数新建一个 Timer 对象 参数 id: Timer ID, [0~2] (Timer.TIMER0~TIMER2) channel: Timer 通道, [Timer.CHANNEL0~Timer.CHANNEL3] mode: Timer 模式, MODE_ONE_SHOT 或者 MODE_PERIODIC 或者 MODE_PWM period: Timer 周期, 在启动定时器后 period 时间， 回调函数将会被调用，(0,~) unit: 设置周期的单位，默认位毫秒（ms），Timer.UNIT_S 或者 Timer.UNIT_MS 或者 Timer.UNIT_US 或者Timer.UNIT_NS callback: 定时器回调函数， 定义了两个参数， 一个是定时器对象Timer， 第二个是在定义对象是希望传的参数arg，更多请看arg参数解释 注意：回调函数是在中断中调用的，所以在回调函数中请不要占用太长时间以及做动态分配开关中断等动作 arg: 希望传给回调函数的参数，作为回调函数的第二个参数 start: 是否在对象构建成功后立即开始定时器， True：立即开始， False:不立即开启，需要调用start()函数来启动定时器 priority: 硬件定时器中断优先级， 与特定的CPU相关， 在K210中，取值范围是[1,7]， 值越小优先级越高 div: 硬件定时器分频器，取值范围[0,255]， 默认为0， clk_timer（定时器时钟频率） = clk_pll0（锁相环0频率）/2^(div+1) clk_timer*period(unit:s) 应该 =1 方法 init 类似构造函数 Timer.init(id, channel, mode=Timer.MODE_ONE_SHOT, period=1000, unit=Timer.UNIT_MS, callback=None, arg=None, start=True, priority=1, div=0) 参数 类似构造函数 返回值 无 callback_arg 获取设置的传给回调函数的参数，只能是 Timer 对象调用， 类 Timer 不能调用 callback 获取或者设置回调函数 Timer.callback(callback) 参数 callback： 设置的回调函数，可选参数， 如果不传参数，则只返回先有的回调函数 返回值 当前的回调函数 例子 def on_timer(timer): print(\"time up:\",timer) print(\"param:\",timer.callback_arg()) tim.callback(on_timer) print(on_timer, tim.callback()) period 获取或者设置定时周期 Timer.period(period) 参数 period： 可选参数，配置周期， 如果不传参数， 则只返回当前周期值 返回值 当前周期值 例子 tim.period(2000) print( tim.period() ) start 启动定时器 Timer.start() 参数 无 返回值 无 例子 tim.start() stop 停止定时器 Timer.stop() 参数 无 返回值 无 restart 重新开启定时器 Timer.restart() 参数 无 返回值 无 deinit/_del_ 注销定时器，并且注销硬件的占用，关闭硬件的时钟 Timer.deinit() 参数 无 返回值 无 例子 tim.deinit() 或者 del tim 常量 TIMER0: Timer0 id TIMER1: Timer1 id TIMER2: Timer2 id CHANNEL0: Timer 通道 0 CHANNEL1: Timer 通道 1 CHANNEL2: Timer 通道 2 CHANNEL3: Timer 通道 3 MODE_ONE_SHOT: Timer 只运行一次（回调一次） MODE_PERIODIC: Timer 始终运行（连续回调） MODE_PWM: 定时器不用来回调函数，用以产生PWM UNIT_S: 单位秒 (s) UNIT_MS: 单位毫秒 (ms) UNIT_US: 单位微秒 (us) UNIT_NS: 单位纳秒 (ns) 例程 例程 1 定时3秒后打印信息 from machine import Timer def on_timer(timer): print(\"time up:\",timer) print(\"param:\",timer.callback_arg()) tim = Timer(Timer.TIMER0, Timer.CHANNEL0, mode=Timer.MODE_ONE_SHOT, period=3000, callback=on_timer, arg=on_timer) print(\"period:\",tim.period()) 例程 2 每隔 1 秒打印消息， 停止 5 秒后再重启， 5 秒后关闭并注销定时器 import time from machine import Timer def on_timer(timer): print(\"time up:\",timer) print(\"param:\",timer.callback_arg()) tim = Timer(Timer.TIMER0, Timer.CHANNEL0, mode=Timer.MODE_PERIODIC, period=1, unit=Timer.UNIT_S, callback=on_timer, arg=on_timer, start=False, priority=1, div=0) print(\"period:\",tim.period()) tim.start() time.sleep(5) tim.stop() time.sleep(5) tim.restart() time.sleep(5) tim.stop() del tim powered by GitbookFile Modify: 2020-09-11 12:05:50 "},"api_reference/machine/uart.html":{"url":"api_reference/machine/uart.html","title":"UART","keywords":"","body":"machine.UART uart 模块主要用于驱动开发板上的异步串口，可以自由对 uart 进行配置。k210 一共有3个 uart，每个 uart 可以进行自由的引脚映射。 构造 引脚映射 在使用 uart 前，我们需要使用 fm 来对芯片引脚进行映射和管理。如下所示，将 PIN10 设置为 uart2 的发送引脚，PIN11 设置为 uart2 的接收引脚 fm.register(board_info.PIN10,fm.fpioa.UART2_TX) fm.register(board_info.PIN11,fm.fpioa.UART2_RX) 构造函数 uart = machine.UART(uart,baudrate,bits,parity,stop,timeout, read_buf_len) 通过指定的参数新建一个 UART 对象 参数 uart UART 号，使用指定的 UART，可以通过 machine.UART. 按tab键来补全 baudrate: UART 波特率 bits: UART 数据宽度，支持 5/6/7/8 (默认的 REPL 使用的串口（UARTHS）只支持 8 位模式)， 默认 8 parity: 奇偶校验位，支持 None, machine.UART.PARITY_ODD, machine.UART.PARITY_EVEN （默认的 REPL 使用的串口（UARTHS）只支持 None）， 默认 None stop: 停止位， 支持 1， 1.5, 2， 默认 1 timeout: 串口接收超时时间 read_buf_len： 串口接收缓冲，串口通过中断来接收数据，如果缓冲满了，将自动停止数据接收 返回值 UART对象 方法 init 用于初始化 uart，一般在构造对象时已经初始化，这里用在重新初始化 uart uart.init(baudrate,bits,parity,stop,timeout, read_buf_len) 参数 同构造函数，但不需要第一个UART号 返回值 无 read 用于读取串口缓冲中的数据 uart.read(num) 参数 num: 读取字节的数量，一般填入缓冲大小，如果缓冲中数据的数量没有 num 大，那么将只返回缓冲中剩余的数据 返回值 bytes类型的数据 readline 用于读取串口缓冲数据的一航 uart.readline(num) num: 读取行的数量 返回值 *bytes类型的数据 write 用于使用串口发送数据 uart.write(buf) 参数 buf: 需要发送到数据 返回值 写入的数据量 deinit 注销 UART 硬件，释放占用的资源 UART.deinit() 参数 无 返回值 无 repl_uart() 获取用于 REPL 的串口对象 返回值 用于 REPL 的串口对象， 默认初始化位 115200 8 N 1 例程 例程 1 在运行里程之前，请确认 PIN15 已经连接到 PIN10， PIN17 已经连接到 PIN9 运行程序后，可以在终端看到 baudrate:115200 bits:8 parity:0 stop:0 ---check Successfully 的打印信息 from fpioa_manager import fm from machine import UART fm.register(board_info.PIN15,fm.fpioa.UART1_TX) fm.register(board_info.PIN17,fm.fpioa.UART1_RX) fm.register(board_info.PIN9,fm.fpioa.UART2_TX) fm.register(board_info.PIN10,fm.fpioa.UART2_RX) uart_A = UART(UART.UART1, 115200, 8, None, 1, timeout=1000, read_buf_len=4096) uart_B = UART(UART.UART2, 115200, 8, None, 1, timeout=1000, read_buf_len=4096) write_str = 'hello world' for i in range(20): uart_A.write(write_str) read_data = uart_B.read() read_str = read_data.decode('utf-8') print(\"string = \",read_str) if read_str == write_str: print(\"baudrate:115200 bits:8 parity:None stop:1 ---check Successfully\") uart_A.deinit() uart_B.deinit() del uart_A del uart_B 例程 2 AT模块串口 fm.register(board_info.WIFI_RX,fm.fpioa.UART2_TX) fm.register(board_info.WIFI_TX,fm.fpioa.UART2_RX) uart = machine.UART(machine.UART.UART2,115200,timeout=1000, read_buf_len=4096) 例程 3 修改 REPL 串口波特率 from machine import UART repl = UART.repl_uart() repl.init(1500000, 8, None, 1, read_buf_len=2048) 例程 3 修改 REPL 串口 from machine import UART fm.register(board_info.PIN15,fm.fpioa.UART1_TX) fm.register(board_info.PIN17,fm.fpioa.UART1_RX) uart = machine.UART(UART.UART1, 115200) UART.set_repl_uart(uart) powered by GitbookFile Modify: 2020-09-11 12:05:50 "},"api_reference/machine_vision/lcd.html":{"url":"api_reference/machine_vision/lcd.html","title":"LCD","keywords":"","body":"lcd 屏幕显示驱动 函数 lcd.init(type=1, freq=15000000, color=lcd.BLACK) 初始化 LCD 屏幕显示 参数 type： LCD 的类型（保留给未来使用）: 0: None 1: lcd shield（默认值） type 是键值参数，必须在函数调用中通过写入 type= 来显式地调用 freq： LCD （实际上指 SPI 的通讯速率） 的频率 color： LCD 初始化的颜色， 可以是 16 位的 RGB565 颜色值，比如 0xFFFF； 或者 RGB888 元组， 比如 (236, 36, 36)， 默认 lcd.BLACK lcd.deinit() 注销 LCD 驱动，释放I/O引脚 lcd.width() 返回 LCD 的宽度（水平分辨率） lcd.height() 返回 LCD 的高度（垂直分辨率）。 lcd.type() 返回 LCD 的类型（保留给未来使用）： 0: None 1: lcd Shield lcd.freq(freq) 设置或者获取 LCD （SPI） 的频率 Paremeters freq: LCD (SPI) 的频率 Return LCD 的频率 lcd.set_backlight(state) 设置 LCD 的背光状态， 关闭背光会大大降低lcd扩展板的能耗 //TODO: 未实现 参数 state： 背光亮度， 取值 [0,100] lcd.get_backlight() 返回背光状态 返回值 背光亮度， 取值 [0,100] lcd.display(image, roi=Auto) 在液晶屏上显示一张 image（GRAYSCALE或RGB565）。 roi 是一个感兴趣区域的矩形元组(x, y, w, h)。若未指定，即为图像矩形 若 roi 宽度小于lcd宽度，则用垂直的黑色边框使 roi 居于屏幕中心（即用黑色填充未占用区域）。 若 roi 宽度大于lcd宽度，则 roi 居于屏幕中心，且不匹配像素不会显示（即液晶屏以窗口形态显示 roi 的中心）。 若 roi 高度小于lcd高度，则用垂直的黑色边框使 roi 居于屏幕中心（即用黑色填充未占用区域）。 若 roi 高度大于lcd高度，则 roi 居于屏幕中心，且不匹配像素不会显示（即液晶屏以窗口形态显示 roi 的中心）。 roi 是键值参数，必须在函数调用中通过写入 roi= 来显式地调用。 lcd.clear() 将液晶屏清空为黑色或者指定的颜色。 参数 color： LCD 初始化的颜色， 可以是 16 位的 RGB565 颜色值，比如 0xFFFF； 或者 RGB888 元组， 比如 (236, 36, 36) lcd.direction(dir) 在 v0.3.1 之后已经被舍弃， 请使用lcd.rotation 和 lcd.invert代替， 如非必要请勿使用， 接口仍会被保留用于调试使用 设置屏幕方向， 以及是否镜像等 参数 dir： 正常情况下推荐 lcd.YX_LRUD 和 lcd.YX_RLDU， 另外还有其它值，交换 XY 或者 LR 或者 DU即可 lcd.rotation(dir) 设置 LCD 屏幕方向 参数 dir: 取值范围 [0,3]， 从0到3依次顺时针旋转 返回值 当前方向，取值[0,3] lcd.mirror(invert) 设置 LCD 是否镜面显示 参数 invert： 是否镜面显示， True 或者 False 返回值 当前设置，是否镜面显示，返回True或者False 例程 例程 1： 显示英文 import lcd lcd.init() lcd.draw_string(100, 100, \"hello maixpy\", lcd.RED, lcd.BLACK) 例程 2： 显示图片 import lcd import image img = image.Image(\"/sd/pic.bmp\") lcd.display(img) 例程 3： 利用显示图片的方式显示英文 import lcd import image img = image.Image() img.draw_string(60, 100, \"hello maixpy\", scale=2) lcd.display(img) 例程 4： 实时显示摄像头捕捉到的图像 import sensor, lcd sensor.reset() sensor.set_pixformat(sensor.RGB565) sensor.set_framesize(sensor.QVGA) sensor.run(1) sensor.skip_frames() lcd.init() while(True): lcd.display(sensor.snapshot()) powered by GitbookFile Modify: 2020-09-11 12:05:50 "},"api_reference/application/lvgl.html":{"url":"api_reference/application/lvgl.html","title":"Lvgl","keywords":"","body":"lvgl LittlevGL 参考官方文档： lvgl blog page 例程 参考 github 的 MaixPy_Scripts powered by GitbookFile Modify: 2020-09-11 12:05:50 "},"api_reference/standard/usocket.html":{"url":"api_reference/standard/usocket.html","title":"usocket","keywords":"","body":"usocket – 套接字模块 该模块实现了相应CPython模块的子集，如下所述。有关更多信息，请参阅原始CPython文档: socket. 该模块提供对BSD套接字接口的访问 与CPython的区别 为了提高效率和一致性，MicroPython中的套接字对象直接实现了stream（类文件）接口。在CPython中，您需要使用makefile（）方法将套接字转换为类文件对象。 MicroPython仍支持此方法（但是无操作），因此在与CPython兼容的情况下，请务必使用它。 套接字地址格式 usocket模块的本机套接字地址格式是getaddrinfo函数返回的不透明数据类型，必须用它来解析文本地址（包括数字地址）： sockaddr = usocket.getaddrinfo('www.micropython.org', 80)[0][-1] # You must use getaddrinfo() even for numeric addresses sockaddr = usocket.getaddrinfo('127.0.0.1', 80)[0][-1] # Now you can use that address sock.connect(addr) 使用getaddrinfo是最有效的（在内存和处理能力方面），而且也是使用地址的可移植方式。 但是，socket模块（注意与此处描述的本机MicroPythonusocket模块的区别）提供了与CPython兼容的方式来使用元组指定地址，如下所述。请注意，取决于MicroPython端口，可以在内置或需要从micropython-lib安装套接字模块（如“MicroPython Unix端口”的情况），并且某些端口仍然只接受元组中的数字地址格式，并要求使用getaddrinfo函数来解析域名。 总的来说： 编写便携式应用程序时始终使用getaddrinfo。 如果您的端口支持快速黑客和交互式使用，则下面描述的元组地址可用作快捷方式。 socket模块的元组地址格式： IPv4：（ipv4_address，port），其中ipv4_address是带有点符号数字IPv4地址的字符串，例如， “8.8.8.8”，端口号和整数端口号在1-65535范围内。请注意，域名不被接受为ipv4_address，应首先使用usocket.getaddrinfo（）解析它们。 IPv6：（ipv6_address，port，flowinfo，scopeid），其中ipv6_address是带冒号数字IPv6地址的字符串，例如： “2001：db8 :: 1”，port是1-65535范围内的整数端口号。 flowinfo必须为0. scopeid是链路本地地址的接口范围标识符。请注意，域名不被接受为ipv6_address，应首先使用usocket.getaddrinfo（）解析它们。 IPv6支持的可用性取决于MicroPython端口。 方法 usocket.socket(af=AF_INET, type=SOCK_STREAM, proto=IPPROTO_TCP) 使用给定的地址系列，套接字类型和协议号创建一个新套接字。请注意，在大多数情况下不需要指定proto（不推荐使用，因为一些MicroPython端口可能会省略IPPROTO_ *常量）。相反，type参数将自动选择所需的协议： # Create STREAM TCP socket socket(AF_INET, SOCK_STREAM) # Create DGRAM UDP socket socket(AF_INET, SOCK_DGRAM) usocket.getaddrinfo(host, port, af=0, type=0, proto=0, flags=0) 将 host / port 参数转换为5元组序列，其中包含用于创建连接到该服务的套接字的所有必要参数。参数af，type和proto（与socket（）函数具有相同的含义）可用于过滤返回哪种地址。如果未指定参数或为零，则可以返回所有地址组合（需要在用户端进行过滤）。 生成的5元组列表具有以下结构： (family, type, proto, canonname, sockaddr) 以下示例显示如何连接到给定的URL： s = usocket.socket() # This assumes that if \"type\" is not specified, an address for # SOCK_STREAM will be returned, which may be not true s.connect(usocket.getaddrinfo('www.micropython.org', 80)[0][-1]) 建议使用过滤参数： s = usocket.socket() # Guaranteed to return an address which can be connect'ed to for # stream operation. s.connect(usocket.getaddrinfo('www.micropython.org', 80, 0, SOCK_STREAM)[0][-1]) 与CPython的区别 如果此函数出错，CPython会引发socket.gaierror异常（OSError子类）。 MicroPython没有socket.gaierror并直接引发OSError。请注意，getaddrinfo（）的错误号形成一个单独的命名空间，可能与uerrno模块中的错误号不匹配。为了区分getaddrinfo（）错误，它们用负数表示，而标准系统错误是正数（错误号可以使用来自异常对象的e.args [0]属性访问）。使用负值是临时细节，可能在将来发生变化。 usocket.inet_ntop(af, bin_addr) 将给定地址族af的二进制网络地址bin_addr转换为文本表示： >>> usocket.inet_ntop(usocket.AF_INET, b\"\\x7f\\0\\0\\1\") '127.0.0.1' usocket.inet_pton(af, txt_addr) 将给定地址族af的文本网络地址txt_addr转换为二进制表示： >>> usocket.inet_pton(usocket.AF_INET, \"1.2.3.4\") b'\\x01\\x02\\x03\\x04' 常量 usocket.AF_INET usocket.AF_INET6 解决家庭类型。可用性取决于特定的MicroPython端口。 usocket.SOCK_STREAM usocket.SOCK_DGRAM 套接字类型。 usocket.IPPROTO_UDP usocket.IPPROTO_TCP IP协议号。可用性取决于特定的MicroPython端口。注意，在调用usocket.socket（）时不需要指定它们，因为SOCK_STREAM套接字类型会自动选择IPPROTO_TCP和SOCK_DGRAM - IPPROTO_UDP。因此，这些常量的唯一实际用途是作为setsockopt（）的参数。 usocket.SOL_* 套接字选项级别（setsockopt（）的参数）。确切的库存取决于MicroPython端口。 usocket.SO_* 套接字选项（setsockopt（）的参数）。确切的库存取决于MicroPython端口。 类 socket 方法 socket.close() 标记套接字已关闭并释放所有资源。一旦发生这种情况，套接字对象上的所有未来操作都将失败。如果协议支持，远程端将接收EOF指示。 套接字在被垃圾收集时会自动关闭，但建议你在完成它们之后立即“关闭”它们。 socket.bind(address) 将套接字绑定到地址。套接字必须尚未绑定。 socket.listen([backlog]) 使服务器接受连接。如果指定了积压，则必须至少为0（如果低，则将其设置为0）;并指定在拒绝新连接之前系统将允许的未接受连接数。如果未指定，则选择默认的合理值。 socket.accept() 接受连接。套接字必须绑定到一个地址并侦听连接。返回值是一对（conn，address），其中conn是可用于在连接上发送和接收数据的新套接字对象，address是绑定到连接另一端的套接字的地址。 socket.connect(address) 连接到地址处的远程套接字。 socket.send(bytes) 将数据发送到套接字。套接字必须连接到远程套接字。返回发送的字节数，可能小于数据长度（“短写”）。 socket.sendall(bytes) 将所有数据发送到套接字。套接字必须连接到远程套接字。与send（）不同，此方法将尝试通过连续发送数据块来发送所有数据。 此方法在非阻塞套接字上的行为未定义。因此，在MicroPython上，建议使用write（）方法，它具有相同的“无短写入”策略来阻塞套接字，并将返回在非阻塞套接字上发送的字节数。 socket.recv(bufsize) 从套接字接收数据。返回值是表示接收数据的字节对象。一次接收的最大数据量由bufsize指定。 socket.sendto(bytes, address) 将数据发送到套接字。套接字不应连接到远程套接字，因为目标套接字由地址指定。 socket.recvfrom(bufsize) 从套接字接收数据。返回值是一对（字节，地址），其中bytes是表示接收数据的字节对象，address是发送数据的套接字的地址。 socket.setsockopt(level, optname, value) 设置给定套接字选项的值。所需的符号常量在套接字模块中定义（SO_ *等）。该值可以是整数或表示缓冲区的类字节对象。 socket.settimeout(value) 注意：并非每个端口都支持此方法，请参阅下文。 阻止套接字操作设置超时。 value参数可以是表示秒的非负浮点数，也可以是None。如果给出非零值，则如果在操作完成之前已经过了超时时间值，则后续的套接字操作将引发“OSError”异常。如果给出零，则套接字处于非阻塞模式。如果给出None，则套接字处于阻塞模式。 并非每个“MicroPython端口”都支持此方法。更便携和通用的解决方案是使用uselect.poll对象。这允许同时等待多个对象（而不仅仅是在套接字上，而是在支持轮询的通用stream对象上）。例： # Instead of: s.settimeout(1.0) # time in seconds s.read(10) # may timeout # Use: poller = uselect.poll() poller.register(s, uselect.POLLIN) res = poller.poll(1000) # time in milliseconds if not res: # s is still not ready for input, i.e. operation timed out 与CPython的区别 CPython在超时的情况下引发socket.timeout异常，这是一个OSError子类。 MicroPython直接引发了一个OSError。如果你使用除了OSError：来捕获异常，你的代码将在MicroPython和CPython中都有效。 socket.setblocking(flag) 设置套接字的阻塞或非阻塞模式：如果flag为false，则套接字设置为非阻塞，否则设置为阻塞模式。 这个方法是某些settimeout（）调用的简写： sock.setblocking(True) 相当于sock.settimeout(None) sock.setblocking(False) i相当于 sock.settimeout(0) socket.makefile(mode='rb', buffering=0) 返回与套接字关联的文件对象。确切的返回类型取决于给makefile（）的参数。支持仅限于二进制模式（'rb'，'wb'和'rwb'）。 CPython的参数：不支持编码，错误和换行符。 与CPython的区别 由于MicroPython不支持缓冲流，因此忽略缓冲参数的值，并将其视为0（无缓冲）。 与CPython的区别 关闭makefile（）返回的文件对象也将关闭原始套接字。 socket.read([size]) 从插槽中读取大小字节。返回一个字节对象。如果没有给出大小，它会读取插座中可用的所有数据，直到EOF;因此，在套接字关闭之前，该方法不会返回。此函数尝试读取所请求的数据（没有“短读取”）。但是，对于非阻塞套接字，这可能是不可能的，然后将返回更少的数据。 socket.readinto(buf[, nbytes]) 将字节读入buf。如果指定了nbytes，则最多读取多个字节。否则，最多读取len（buf）字节。就像read（）一样，此方法遵循“无短读”策略。 返回值：读取并存储到buf中的字节数。 socket.readline() 读一行，以换行符结尾。 返回值：读取的行。 socket.write(buf) 将字节缓冲区写入套接字。此函数将尝试将所有数据写入套接字（无“短写”）。但是，对于非阻塞套接字，这可能是不可能的，并且返回值将小于buf的长度。 返回值：写入的字节数。 exception usocket.error MicroPython没有此异常。 与CPython的区别 CPython曾经有一个socket.error异常现在已被弃用，它是OSError的别名。在MicroPython中，直接使用OSError。 例程 例程 1： 下载图片并显示 注意需要设置 WiFi SSID 和 密码 import socket import network import gc import os import lcd, image fm.register(board_info.WIFI_RX,fm.fpioa.UART2_TX) fm.register(board_info.WIFI_TX,fm.fpioa.UART2_RX) uart = machine.UART(machine.UART.UART2,115200,timeout=1000, read_buf_len=4096) nic=network.ESP8285(uart) nic.connect(\"Sipeed_2.4G\",\"------\") sock = socket.socket() addr = socket.getaddrinfo(\"dl.sipeed.com\", 80)[0][-1] sock.connect(addr) sock.send('''GET /MAIX/MaixPy/assets/Alice.bmp HTTP/1.1 Host: dl.sipeed.com cache-control: no-cache ''') img = b\"\" sock.settimeout(5) while True: data = sock.recv(4096) if len(data) == 0: break print(\"rcv:\", len(data)) img = img + data print(len(img)) img = img[img.find(b\"\\r\\n\\r\\n\")+4:] print(len(img)) print(\"save to /sd/Alice.bmp\") f = open(\"/sd/Alice.bmp\",\"wb\") f.write(img) f.close() print(\"save ok\") print(\"display\") img = image.Image(\"/sd/Alice.bmp\") lcd.init() lcd.display(img) 例程 2： 发送图片 import os import socket import network import gc fm.register(board_info.WIFI_RX,fm.fpioa.UART2_TX) fm.register(board_info.WIFI_TX,fm.fpioa.UART2_RX) uart = machine.UART(machine.UART.UART2,115200,timeout=1000, read_buf_len=4096) nic=network.ESP8285(uart) nic.connect(\"Sipeed_2.4G\",\"-------\") addr = (\"192.168.0.183\", 3456) sock = socket.socket() sock.connect(addr) sock.settimeout(5) f = open(\"/sd/Alice.bmp\",\"rb\") while True: img = f.read(2048) if not img or (len(img) == 0): break sock.send(img) f.close() sock.close() powered by GitbookFile Modify: 2020-09-11 12:05:50 "},"api_reference/machine/network.html":{"url":"api_reference/machine/network.html","title":"Http/https","keywords":"","body":"network 该模块用于初始化各种网卡驱动，网卡具有连接路由，断开路由，查看网卡连接信息，检查是否连接等功能。 使用WiFi请确保已经接上了天线 esp8285 在部分开发板上带了 一个 使用AT方式交互的网卡模块，比如esp8285，与k210通过串口连接 引脚8是使能脚，可以创建一个GPIO对象来控制它的高低电平来实现使能和失能，也可以用它复位（先低后高），复位后需要等待一小段时间才能操作， 可以查看例程wifi_ap_scan.py esp32 目前在MaixDuino开发板中有一个 esp32 模块通过 spi 与k210相连 同时也有单独的TF插卡式模块 ESP8285_Module network.ESP8285(uart) 构造一个ESP8285网卡对象，使用该方法需要传入一个uart对象，在MaixPy目前支持的dock和GO上，是使用AT指令模块作为WiFi。所以该uart对象是与AT模块通信的对象，可以查看uart模块例程 调用此方法会初始化ESP8285， 如果失败会抛出异常 参数 uart: 与AT模块通信的UART对象 返回值 ESP8285: 网卡对象 ESP8285 connect(ssid, key) 连接热点（AP/路由器） 参数 ssid: 热点的SSID key: 热点的密码 返回值 无， 如果发生错误会抛出异常 2.2. ifconfig 查看wifi连接信息，目前network不支持设置网卡配置 nic.ifconfig() 参数 无 返回值 tuple 类型， 元素都是字符串：(ip, netmask, gateway, dns_server, dhcp_server, mac, ssid)， 如果没有查询到或者无效，值为\"0\" isconnected 查看wifi是否连接 nic.isconnected() 参数 无 返回值 True: 已经连接 False: 断开连接 disconnect 断开wifi连接 参数 无 返回值 无 scan 扫描周围的热点信息 参数 无 返回值 一个 list对象， 每个元素包含了一个字符串， 字符串来自AT模块的响应，内容和esp8285的AT指令文档所描述的相同，如下： ',,,,,,,, ,,' ：加密⽅式 0：OPEN 1：WEP 2：WPA_PSK 3：WPA2_PSK 4：WPA_WPA2_PSK 5：WPA2_Enterprise（⽬前 AT 不⽀持连接这种加密 AP） ：字符串参数，AP 的 SSID ：信号强度 ：字符串参数，AP 的 MAC 地址 ：信道号 ：AP 频偏，单位：kHz。此数值除以 2.4，可得到 ppm 值 ：频偏校准值 : 0：CIPHER_NONE 1：CIPHER_WEP40 2：CIPHER_WEP104 3：CIPHER_TKIP 4：CIPHER_CCMP 5：CIPHER_TKIP_CCMP 6：CIPHER_UNKNOWN : 定义与 相同 : bit0 代表 b 模式; bit1 代表 g 模式; bit2 代表 n 模式 若对应 bit 为 1，表示该模式使能；若对应 bit 为 0，则该模式未使能。 ：0，WPS 未使能；1，WPS 使能 比如： info_strs = ['4,\"ChinaNet-lot0\",-79,\"c8:50:e9:e8:21:3e\",1,-42,0,4,3,7,1', '4,\"TOPSTEP2G4\",-7 0,\"f8:e7:1e:0d:0d:f8\",1,-57,0,4,4,7,0'] 这看起来可能会比较奇怪，因为每个AP的信息都是一串字符，信息里面还有整型和字符串，字符串用双引号括起来的，所以拿到这个字符串后需要再次处理后再使用，比如： def wifi_deal_ap_info(info): res = [] for ap_str in info: ap_str = ap_str.split(\",\") info_one = [] for node in ap_str: if node.startswith('\"'): info_one.append(node[1:-1]) else: info_one.append(int(node)) res.append(info_one) return res info_strs = ['4,\"ChinaNet-lot0\",-79,\"c8:50:e9:e8:21:3e\",1,-42,0,4,3,7,1', '4,\"TOPSTEP2G4\",-70,\"f8:e7:1e:0d:0d:f8\",1,-57,0,4,4,7,0'] info = wifi_deal_ap_info(info_strs) print(info) 输出是： [[4, 'ChinaNet-lot0', -79, 'c8:50:e9:e8:21:3e', 1, -42, 0, 4, 3, 7, 1], [4, 'TOPSTEP2G4', -70, 'f8:e7:1e:0d:0d:f8', 1, -57, 0, 4, 4, 7, 0]] 然后比如我们需要获得所有AP的SSID只需要使用 for ap_info in info: print(ap_info[1]) enable_ap(ssid, key, chl=5, ecn=3) 打开热点 参数 ssid: SSID key： 密码 chl： WiFi信号的通道号 ecn： 加密方法， 有OPEN``WPA2_PSK等，参考本页ESP8285的常量部分， 默认值是3， 也就是ESP8285.WPA2_PSK，比如nic = network.ESP8285(uart) nic.enable_ap(\"maixpy\", \"12345678\", 5, nic.OPEN) 或者nic.enable_ap(\"maixpy\", \"12345678\", 5, network.ESP8285.OPEN) disable_ap() 关闭热点 常量 OPEN 热点的加密方式为不需要密码 WPA_PSK 热点的加密方式为 WPA_PSK WPA2_PSK 热点的加密方式为 WPA2_PSK WPA_WPA2_PSK 热点的加密方式为 WPA_WPA2_PSK 例程 参考network目录下的例程 ESP32_Module network.ESP32_SPI(cs,rst,rdy,mosi,miso,sclk) 构造一个ESP32_SPI网卡对象，需要传入对应的GPIOHS FUNC 如果传入参数数量不对，会返回错误 参数 对应引脚功能的 fpioa_func 返回值 ESP32_SPI 网卡对象 ESP32_SPI adc 读取esp32模块的adc值 参数 无 返回值 tunple，5个通道的adc值顺序是\"PIN36\", \"PIN39\", \"PIN34\", \"PIN35\", \"PIN32\" 例程 demo_esp32_read_adc.py powered by GitbookFile Modify: 2020-09-11 12:05:50 "},"api_reference/Maix/freq.html":{"url":"api_reference/Maix/freq.html","title":"freq","keywords":"","body":"Maix.freq 频率模块，支持程序修改 cpu 和 kpu 频率 方法 freq.set(cpu, pll1, kpu_div) 设置 cpu 或者 kpu 频率，设置完后会自动重启生效 请注意在频率设置完毕后可能会导致某些外设性能改变 from Maix import freq freq.set(cpu = 400, kpu = 400) 配置文件将会保存在文件系统的/flash/freq.conf文件下，请勿修改这个文件，如果文件不存在则会自动创建 参数 不设置的参数会保持之前的值 注意： 如果cpu频率设置小于60MHz， 默认的REPL串口波特率会设置为9600 cpu： 想要设置的cpu频率，范围[26,600]（芯片最高800但对电压有要求，MaixPy支持的系列不支持最高到800，默认400, 不同的板子可能表现不同，为了稳定性不建议过高 pll1: pll1输出的频率，取值范围[26,1200]（芯片最高1800，MaixPy限制到1200），默认 400 kpu_div：kpu时钟频率分频，取值范围[1,16]，默认1。 kpu频率=pll1/kpu_div， 比如想设置kpu频率为400，则只需设置pll1为400， kpu_div为1即可。 注意kpu频率范围：[26,600] 返回值 如果频率没有变化，则返回空。 如果频率有变化，将会自动重启机器。在使用该接口之前请确认当前情况能能否重启 freq.get() 获取当前设置的频率参数 返回值 cpu频率和kpu的频率，一个元组的形式返回，比如(400,400) freq.get_cpu() 获取当前cpu的频率 返回值 cpu频率 freq.get_kpu() 获取当前设置的 kpu 频率 返回值 当前kpu频率 powered by GitbookFile Modify: 2020-09-11 12:05:50 "},"api_reference/standard/gc.html":{"url":"api_reference/standard/gc.html","title":"gc 内存回收","keywords":"","body":"gc – 内存回收 该模块实现了相应CPython模块的子集，如下所述。有关更多信息，请参阅原始CPython文档：gc. 函数 gc.enable() 启用自动垃圾回收。 gc.disable() 禁用自动垃圾回收。仍然可以分配堆内存，仍然可以使用 gc.collect() 手动启动垃圾收集。 gc.collect() 运行垃圾回收。 gc.mem_alloc() 返回分配的堆 RAM 的字节数。 Difference to CPython 此功能是 MicroPython 扩展。 gc.mem_free() 返回可用堆RAM的字节数，如果堆剩余数量未知，则返回-1。 与CPython的区别 此功能是MicroPython扩展。 gc.threshold([amount]) 设置或查询其他GC分配阈值。通常，仅当不能满足新分配时，即在内存不足（OOM）条件下才触发集合。如果调用此函数，除了OOM之外，每次分配了大量字节后都会触发一个集合（总共，因为上一次分配了这么多的字节）。 amount通常被指定为小于完整堆大小，意图在堆耗尽之前触发集合，并希望早期集合可以防止过多的内存碎片。这是一种启发式度量，其效果因应用程序而异，以及量参数的最佳值。 不带参数调用函数将返回阈值的当前值。值-1表示禁用的分配阈值。 与CPython的区别 此函数是MicroPython扩展。 CPython有一个类似的函数 - set_threshold()，但是由于不同的GC实现，它的签名和语义是不同的。 powered by GitbookFile Modify: 2020-09-11 12:05:50 "},"api_reference/machine_vision/sensor.html":{"url":"api_reference/machine_vision/sensor.html","title":"sensor","keywords":"","body":"sensor sensor 传感器模块(这里特指摄像头模块)，进行摄像头配置及图像抓取等，用于控制开发板摄像头完成摄像任务。 方法 初始化单目摄像头 重置并初始化单目摄像头 sensor.reset([, freq=24000000[, set_regs=True[, dual_buff=False]]]) 参数 freq: 设置摄像头时钟频率，频率越高帧率越高，但是画质可能更差。默认 24MHz， 如果摄像头有彩色斑点(ov7740)，可以适当调低比如 20MHz set_regs: 允许程序写摄像头寄存器，默认为 True。 如果需要自定义复位序列，可以设置为False，然后使用sensor.__write_reg(addr, value) 函数自定义写寄存器序列 dual_buff: 默认为False。允许使用双缓冲，会增高帧率，但是内存占用也会增加(大约为384KiB) 返回值 无 重置双目摄像头 重置并初始化双目摄像头 K210 只有一个 DVP 接口，同一时间只能控制一个 Sensor。但是我们可以借助 shudown 方法控制 PWDN 引脚以选择特定的 Sensor。 指定 Sensor 后其余操作不变。详见 例程 2 sensor.binocular_reset() 参数 无 返回值 无 设置帧大小 用于设置摄像头输出帧大小，k210最大支持VGA格式，大于VGA将无法获取图像 MaixPy开发板配置的屏幕是320*240分辨率，推荐设置为QVGA格式 sensor.set_framesize(framesize[, set_regs=True]) 参数 framesize: 帧大小 set_regs: 允许程序写摄像头寄存器，默认为 True。 如果需要自定义设置帧大小的序列，可以设置为False，然后使用sensor.__write_reg(addr, value) 函数自定义写寄存器序列 返回值 True : 设置成功 False: 设置错误 设置帧格式 用于设置摄像头输出格式 MaixPy开发板配置的屏幕使用的是RGB565，推荐设置为RGB565格式 sensor.set_pixformat(format[, set_regs=True]) 参数 format: 帧格式 set_regs: 允许程序写摄像头寄存器，默认为 True。 如果需要自定义设置像素格式的序列，可以设置为False，然后使用sensor.__write_reg(addr, value) 函数自定义写寄存器序列 可选的帧格式有GRAYSCALE, RGB565, YUV422 返回值 True : 设置成功 False: 设置错误 图像捕捉控制 图像捕捉功能控制 sensor.run(enable) 参数 enable: 1 表示开始抓取图像 0 表示停止抓取图像 返回值 True : 设置成功 False: 设置错误 拍摄图像 使用摄像头拍摄一张照片 sensor.snapshot() 参数 无 返回值 img: 返回的图像对象 摄像头控制 关闭摄像头/切换摄像头 sensor.shutdown(enable/select) 参数 单目摄像头 enable: True 表示开启摄像头 False 表示关闭摄像头 双目摄像头 select: 通过写入 0 或 1 来切换摄像头 返回值 无 跳帧 跳过指定帧数或者跳过指定时间内的图像，让相机图像在改变相机设置后稳定下来 sensor.skip_frames(n, [, time]) 参数 n: 跳过 n 帧图像 time: 跳过指定时间，单位为ms 若 n 和 time 皆未指定，该方法跳过300毫秒的帧；若二者皆指定，该方法会跳过 n 数量的帧，但将在 time 毫秒后返回 返回值 无 分辨率宽度 获取摄像头分辨率宽度 sensor.width() 参数 无 返回值 int类型的摄像头分辨率宽度 分辨率高度 获取摄像头分辨率高度 sensor.height() 参数 无 返回值 int类型的摄像头分辨率高度 获取帧缓冲 获取当前帧缓冲区 sensor.get_fb() 参数 无 返回值 image类型的对象 获取ID 获取当前摄像头ID sensor.get_id() 参数 无 返回值 int类型的ID 设置彩条测试模式 将摄像头设置为彩条测试模式 开启彩条测试模式后，摄像头会输出一彩条图像，常用来检测摄像机总线是否连接正确。 sensor.set_colorbar(enable) 参数 enable: 1 表示开启彩条测试模式 0 表示关闭彩条测试模式 返回值 无 设置对比度 设置摄像头对比度 sensor.set_contrast(contrast) 参数 constrast: 摄像头对比度，范围为[-2,+2] 返回值 True : 设置成功 False: 设置错误 设置亮度 设置摄像头亮度 sensor.set_brightness(brightness) 参数 constrast: 摄像头亮度，范围为[-2,+2] 返回值 True : 设置成功 False: 设置错误 设置饱和度 设置摄像头饱和度 sensor.set_saturation(saturation) 参数 constrast: 摄像头饱和度，范围为[-2,+2] 返回值 True : 设置成功 False: 设置错误 设置自动增益 设置摄像自动增益模式 sensor.set_auto_gain(enable,gain_db) 参数 enable: 1 表示开启自动增益 0 表示关闭自动增益 gain_db: 关闭自动增益时，设置的摄像头固定增益值，单位为dB 如果需要追踪颜色，需要关闭自动增益 返回值 无 获取增益值 获取摄像头增益值 sensor.get_gain_db() 参数 无 返回值 float类型的增益值 设置水平镜像 设置摄像头水平镜像 sensor.set_hmirror(enable) 参数 enable: 1 表示开启水平镜像 0 表示关闭水平镜像 返回值 无 设置摄像头垂直翻转 设置摄像头垂直翻转 sensor.set_vflip(enable) 参数 enable: 1 表示开启垂直翻转 0 表示关闭垂直翻转 返回值 无 写入寄存器 往摄像头寄存器写入指定值 sensor.__write_reg(address, value) 参数 address: 寄存器地址 value ： 写入值 返回值 无 请参阅摄像头数据手册以获取详细信息 读取寄存器 读取摄像头寄存器值 sensor.__read_reg(address) 参数 address: 寄存器地址 返回值 int类型的寄存器值 请参阅摄像头数据手册以获取详细信息 例程 例程 1 # 单目摄像头 import sensor import lcd lcd.init() sensor.reset() sensor.set_pixformat(sensor.RGB565) sensor.set_framesize(sensor.QVGA) sensor.run(1) while True: img = sensor.snapshot() lcd.display(img) 例程 2 # 双目摄像头 import sensor import image import lcd import time lcd.init() sensor.binocular_reset() sensor.shutdown(0) # 选中sensor 0 sensor.set_pixformat(sensor.RGB565) sensor.set_framesize(sensor.QVGA) sensor.shutdown(1) # 选中sensor 1 sensor.set_pixformat(sensor.RGB565) sensor.set_framesize(sensor.QVGA) sensor.run(1) while True: sensor.shutdown(0) # 选中sensor 0 img = sensor.snapshot() lcd.display(img) time.sleep_ms(100) sensor.shutdown(1) # 选中sensor 1 img = sensor.snapshot() lcd.display(img) time.sleep_ms(100) powered by GitbookFile Modify: 2020-09-11 12:05:50 "},"api_reference/Maix/audio.html":{"url":"api_reference/Maix/audio.html","title":"Audio","keywords":"","body":"audio 抽象的音频对象，该对象可以被当做参数传入也可以直接使用其方法来播放音频 模块函数 构造函数 构造 Audio 对象 audio.Audio(array=None, path=None, points=1024) 参数 该接口能传入一个参数，每个参数会决定不同的音频类型 array: bytearray类型的数据，可以将该数据转换为音频对象， 默认 None path: 打开的音频文件路径，目前仅支持 wav 格式， 默认 None, 注意需要标明关键字path，audio.Audio(\"/sd/1.wav\")这样是错的！！ audio.Audio(path = \"/sd/1.wav\") 才是正确的 points: 开辟有 points 个采样点数的音频缓冲，一个采样点大小为 32bit。为0的情况下将不开辟缓冲, 默认 1024 返回值 返回一个 Audio 对象 to_bytes: bytes转换函数 将音频对象中的音频数据转换为 bytearray 类型的对象 audio_data = test_audio.to_bytes() 参数 无 返回值 返回的音频数据 bytearray 对象 play_process: 播放预处理函数 用于预处理音频对象，在播放之前需要对音频文件进行解析，所以需要预处理。这里需要传入一个播放用的 I2S 设备 wav_info = test_audio.play_process(i2s_dev) 参数 i2s_dev: 用于播放的i2s设备 返回值 该 wav 文件的头部信息 ,list类型，分别是numchannels, samplerate, byterate, blockalign, bitspersample, datasize play: 播放函数 读取音频文件并且解析播放，一般配合循环来使用 参数 无 返回值 None： 格式不支持播放 0： 播放结束 1： 正在播放 finish： 音频后处理函数 完成音频播放，该函数必须在播放完毕后调用，回收底层分配的资源 参数 无 返回值 无 例程 播放 wav 音频 from fpioa_manager import * from Maix import I2S, GPIO import audio # disable wifi fm.register(8, fm.fpioa.GPIO0) wifi_en=GPIO(GPIO.GPIO0,GPIO.OUT) wifi_en.value(0) # register i2s(i2s0) pin fm.register(34,fm.fpioa.I2S0_OUT_D1) fm.register(35,fm.fpioa.I2S0_SCLK) fm.register(33,fm.fpioa.I2S0_WS) # init i2s(i2s0) wav_dev = I2S(I2S.DEVICE_0) # init audio player = audio.Audio(path = \"/sd/6.wav\") player.volume(40) # read audio info wav_info = player.play_process(wav_dev) print(\"wav file head information: \", wav_info) # config i2s according to audio info wav_dev.channel_config(wav_dev.CHANNEL_1, I2S.TRANSMITTER,resolution = I2S.RESOLUTION_16_BIT ,cycles = I2S.SCLK_CYCLES_32, align_mode = I2S.RIGHT_JUSTIFYING_MODE) wav_dev.set_sample_rate(wav_info[1]) # loop to play audio while True: ret = player.play() if ret == None: print(\"format error\") break elif ret==0: print(\"end\") break player.finish() powered by GitbookFile Modify: 2020-09-11 12:05:50 "},"api_reference/machine_vision/video.html":{"url":"api_reference/machine_vision/video.html","title":"video","keywords":"","body":"video 视频 支持播放和录制 avi 视频 全局函数 open(path, record=False, interval=100000, quality=50, width=320, height=240, audio=False, sample_rate=44100, channels=1) 打开一个文件来播放或者录制 参数 path： 文件路径， 比如 /sd/badapple.avi record： 是否进行录制， 如果选择 Ture， 则会进行录制视频，否则是播放视频。 默认 False interval： 录制的帧间隔， 单位是微秒， fps = 1000000/interval， 默认 100000， 即每秒10帧 quality： jpeg 压缩质量（%）， 默认50 width： 录制屏幕宽度， 默认 320 height： 录制屏幕高度， 默认 240 audio： 是否录制音频， 默认 False sample_rate： 录制音频采样率， 默认 44100 (44.1k) channels： 录制音频声道数， 默认 1， 即单声道 返回值 返回一个对象， 根据不同格式返回的对象不同。 目前只支持 avi 格式， 返回 由 avi 类创建的对象 类 avi 由 video.open() 函数返回 play() 播放视频， 每调用一次解析一次数据（音频或者视频） 返回值 0： 播放结束 1： 正在播放 2： 暂停（保留） 3： 当前解码的帧是视频帧 4： 当前解码的帧是音频帧 volume(volume) 设置音量 参数 volume： 音量值， 取值范围：[0,100] 返回值 设置的音量值， 取值范围 [0,100] record() 录制视频和音频， 每调用一次录制一帧，函数内部会限制速度，如果没有到录制设置的间隔，在到达设定的间隔之前会阻塞 返回值 录制的视频的当前帧的长度 例程 例程 1： 播放 avi 视频 首先保证视频是 320x240 大小， 视频压缩格式为 mjpeg， 音频压缩格式位 PCM。 可以在这里下载测试可以用的视频： badapple.avi import video,time from Maix import GPIO fm.register(34, fm.fpioa.I2S0_OUT_D1) fm.register(35, fm.fpioa.I2S0_SCLK) fm.register(33, fm.fpioa.I2S0_WS) fm.register(8, fm.fpioa.GPIO0) wifi_en=GPIO(GPIO.GPIO0,GPIO.OUT) wifi_en.value(0) v = video.open(\"/sd/badapple.avi\") print(v) v.volume(50) while True: if v.play() == 0: print(\"play end\") break v.__del__() 默认使用了 I2S0 来播放音频， 所以需要设置 I2S0 对应的引脚， 关闭WiFi是因为Dock板WiFi对音质的干扰 例程2： 录制 avi 视频 import video, sensor, image, lcd, time lcd.init() sensor.reset() sensor.set_pixformat(sensor.RGB565) sensor.set_framesize(sensor.QVGA) sensor.run(1) sensor.skip_frames(30) v = video.open(\"/sd/capture.avi\", record=1, interval=200000, quality=50) i = 0 tim = time.ticks_ms() while True: tim = time.ticks_ms() img = sensor.snapshot() lcd.display(img) img_len = v.record(img) # print(\"record\",time.ticks_ms() - tim) i += 1 if i > 100: break print(\"finish\") v.record_finish() lcd.clear() 可以取消打印屏蔽来看实际的录制间隔有没有达到设置的帧间隔（比如这里设置的200000us） 实际打印应该是 200ms， 如果实际帧间隔大于设置的值，则说明实际性能没有达到设置的要求，需要调大设置的帧间隔即减小帧率。 另外去掉显示和打印也可以一定程度上增加帧率。 powered by GitbookFile Modify: 2020-09-11 12:05:50 "},"api_reference/application/nes.html":{"url":"api_reference/application/nes.html","title":"NES 游戏模拟器","keywords":"","body":"NES 游戏模拟器 经典的 FC 红白机 游戏模拟器， 带我们回到小时候吧～～ 或者？ 让我们想办法让它自己玩自己？ 函数 init(rc_type=nes.KEYBOARD, cs, mosi, miso, clk, repeat=16, vol=5) 初始化 NES 模拟器 参数 tc_type： 遥控器类型， 键盘（nes.KEYBOARD）（注意是串口与电脑通信，而不是直接接USB键盘到开发板）或者手柄（nes.JOYSTICK）。 建议使用PS2手柄，体验会更好， 键盘通过串口工具输入可能不能同时按多个按键，当然也可以通过自己在PC写一个脚本来转发键值就能解决（去这里找找？） cs： 如果使用 SPI 接口的 PS2 手柄， 传入 cs 外设编号（注意不是引脚号，需要先映射引脚） mosi： 如果使用 SPI 接口的 PS2 手柄， 传入 mosi 外设编号（注意不是引脚号，需要先映射引脚） miso： 如果使用 SPI 接口的 PS2 手柄， 传入 miso 外设编号（注意不是引脚号，需要先映射引脚） clk： 如果使用 SPI 接口的 PS2 手柄， 传入 clk 外设编号（注意不是引脚号，需要先映射引脚） repeat： 这个参数只对使用键盘（/串口）时， 指按键的重复率 vol： 初始化时的音量， 后面可以通过按键调整 run(nes) 运行 NES 游戏 ROM 参数 nes： 游戏 ROM 路径， 比如 /sd/mario.nes 快捷键 键盘（/串口） 移动 ： W A S D A ： J B ： K start ： M 或者 Enter option： N 或者 \\ 退出 ： ESC 音量 - ： - 音量 + ： = 运行速度 - ： R 运行速度 + ： F 手柄 移动 ： 方向键 ^ V -> A ： □ B ： × start ： START select： SELECT 退出 ： 暂无 音量 - ： R2 音量 + ： R1 运行速度 - ： L1 运行速度 + ： L2 例 例 1： 键盘（串口） import nes, lcd lcd.init(freq=15000000) nes.init(nes.KEYBOARD) nes.run(\"/sd/mario.nes\") 例 2： PS2 手柄 import nes, lcd from fpioa_manager import fm fm.register(19, fm.fpioa.GPIOHS19) fm.register(18, fm.fpioa.GPIOHS18) fm.register(23, fm.fpioa.GPIOHS23) fm.register(21, fm.fpioa.GPIOHS21) lcd.init(freq=15000000) nes.init(nes.JOYSTICK, cs=fm.fpioa.GPIOHS19, clk=fm.fpioa.GPIOHS18, mosi=fm.fpioa.GPIOHS23, miso=fm.fpioa.GPIOHS21) nes.run(\"/sd/mario.nes\") powered by GitbookFile Modify: 2020-09-11 12:05:50 "},"application/image/sensor.html":{"url":"application/image/sensor.html","title":"sensor","keywords":"","body":"Sensor 感光元件 sensor模块,用于设置感光元件的参数。 使用例程: 实时预览摄像头 import sensor #引入感光元件的模块 sensor.reset()#初始化感光元件 sensor.set_pixformat(sensor.RGB565)#设置为彩色 sensor.set_framesize(sensor.QVGA)#设置图像的大小 sensor.skip_frames()#跳过n张照片，在更改设置后，跳过一些帧，等待感光元件变稳定。 while(True): img = sensor.snapshot()#拍摄一张照片，img为一个image对象 初始化 sensor.reset()# 初始化感光元件 #设置彩色／黑白 sensor.set_pixformat()# 设置像素模式。 sensor.GRAYSCALE# 灰度，每个像素8bit。 sensor.RGB565# 彩色，每个像素16bit。 设置图像大小 sensor.set_framesize()# 设置图像的大小 sensor.QQCIF# 88x72 sensor.QCIF# 176x144 sensor.CIF# 352x288 sensor.QQSIF# 88x60 sensor.QSIF# 176x120 sensor.SIF# 352x240 sensor.QQQQVGA# 40x30 sensor.QQQVGA# 80x60 sensor.QQVGA# 160x120 sensor.QVGA# 320x240 sensor.VGA# 640x480 跳过一些帧 sensor.skip_frames(n=10) 跳过n张照片，在更改设置后，跳过一些帧，等待感光元件变稳定。 获取一张图像 sensor.snapshot() 拍摄一张照片，返回一个image对象。 自动增益／白平衡／曝光 sensor.set_auto_gain() 自动增益开启(True)或者关闭(False)。在使用颜色追踪时，需要关闭自动增益。 sensor.set_auto_whitebal() 自动白平衡开启(True)或者关闭(False)。在使用颜色追踪时，需要关闭自动白平衡。 sensor.set_auto_exposure(enable[\\, exposure_us]) enable 打开(True)或关闭(False)自动曝光。默认打开。 如果 enable 为False， 则可以用 exposure_us 设置一个固定的曝光时间(以微秒为单位)。 设置窗口ROIsensor.set_windowing(roi) ROI：Region Of Interest，图像处理中的术语“感兴趣区”。就是在要处理的图像中提取出的要处理的区域。 sensor.set_framesize(sensor.VGA) # 高分辨率 sensor.set_windowing((240, 240)) #取中间的 240*240 区域 roi的格式是(x, y, w, h)。见使用统计信息 设置翻转 #水平方向翻转 sensor.set_hmirror(True) # 垂直方向翻转 sensor.set_vflip(True) powered by GitbookFile Modify: 2020-09-11 12:05:50 "},"application/image/basic_operation.html":{"url":"application/image/basic_operation.html","title":"basic_operation","keywords":"","body":"图像的基本运算 坐标 获取/设置像素点 我们可以通过 image.get_pixel(x, y) 方法来获取一个像素点的值。 image.get_pixel(x, y) 对于灰度图: 返回(x,y)坐标的灰度值. 对于彩色图: 返回(x,y)坐标的(r,g,b)的tuple. 同样，我们可以通过 image.set_pixel(x, y, pixel) 方法，来设置一个像素点的值。 image.set_pixel(x, y, pixel) 对于灰度图: 设置(x,y)坐标的灰度值。 对于彩色图: 设置(x,y)坐标的(r,g,b)的值。 举例： img = sensor.snapshot() img.get_pixel(10,10) img.set_pixcel(10,10,(255,0,0))#设置坐标(10,10)的像素点为红色(255,0,0) 获取图像的宽度和高度 image.width() 返回图像的宽度(像素) image.height() 返回图像的高度(像素) image.format() 灰度图会返回 sensor.GRAYSCALE，彩色图会返回 sensor.RGB565。 image.size() 返回图像的大小(byte) 图像的运算 image.invert() 取反，对于二值化的图像，0(黑)变成1(白)，1(白)变成0(黑)。 注： 图像可以是另一个image对象，或者是从 (bmp/pgm/ppm)文件读入的image对象。 两个图像都必须是相同的尺寸和类型（灰度图/彩色图）。 image.nand(image) 与另一个图片进行与非（NAND）运算。 image.nor(image) 与另一个图片进行或非（NOR）运算。 image.xor(image) 与另一个图片进行异或（XOR）运算。 image.xnor(image) 与另一个图片进行异或非（XNOR）运算。 image.difference(image) 从这张图片减去另一个图片。比如，对于每个通道的每个像素点，取相减绝对值操作。这个函数，经常用来做移动检测。 powered by GitbookFile Modify: 2020-09-11 12:05:50 "},"machine_learning/speech_recognizer.html":{"url":"machine_learning/speech_recognizer.html","title":"Speech Recognizer","keywords":"","body":"关键词语音识别 - Speech Recognizer 概述 关于 MaixPy 上的关键词语音识别 MaixPy 板子适配情况 MaixPy 例程 API 说明 注意事项 powered by GitbookFile Modify: 2020-09-11 12:05:50 "},"others/maixpy_faq.html":{"url":"others/maixpy_faq.html","title":"MaixPy 常见问题 FAQ","keywords":"","body":"MaixPy 常见问题 MaixPy 常见问题(FAQ) 一览 问题(点击相应问题可直达) 状态 备注 MaixPy 与 C 开发有什么异同，我该怎么选择 MaixPy IDE 无法成功连接开发板 文档网页打不开，速度慢 下载站文件下载速度慢，文件无法下载 Micro SD 卡读取不到 使用 SD 加载文件、模型不成功 为什么连接了 IDE 帧率降低了很多 为什么 IDE 上预览的摄像头图像很模糊 怎么提高摄像头帧率 IDE 帧缓冲区成像方向不正确，LCD 显示方向不正确 烧录 MaixPy 之后，MaixPy 出现无法启动 使用 JTAG 调试器一直无法接连 K210 MaixPy 与 C 开发有什么异同，我该怎么选择 MaixPy 是基于 Micropython 的脚本语言， 不需要编译，在运行时解析，编写起来更简单方便，只是运行时时实性不如 C 语言。 所以如果是快速验证、新手、只会 python、头发少等都可以用 MaixPy; 追求极限性能效率或者熟悉 C 都可以使用 C 语言开发 MaixPy IDE 无法成功连接开发板 现象: ​ 开发板到手之后，一直无法连接 MaixPy IDE 检查串口是否被占用 点击连接后，不用和终端工具同时使用，否则会出现串口占用无法打开 如果一直无法成功连接成功， 检查： 请检查是否开发板型号选择错误； 观察开发板屏幕是否有变化，如果没有反应可能是串口选择错误； 尝试升级到最新的 master 分支固件， 以及最新的 MaixPy IDE 软件 MaixPy 版本号低于 0.5.0_v0 不支持连接 MaixPy IDE 文档网页打不开，速度慢 如果遇到有些页面无法访问， 请检查一下网址（路径）是否正确， 可以回到首页 (maixpy.sipeed.com) 重新进入即可。 比如这个网址就是由于点击过快导致的： http://localhost:4000/zh/zh/get_started/how_to_read.html 正确的网址应该是： http://localhost:4000/zh/get_started/how_to_read.html 另外，可以换个网络线路试试，比如挂代理，或者换手机流量试试 下载站文件下载速度慢，文件无法下载 如果遇到在 dl.sipeed.com 下载站下载速度慢，可以使用国内的同步服务器 cn.dl.sipeed.com 下载，路径相同，每天同步一次； 部分文件提供了 CDN 下载链接，速度会比较快， 比如 IDE 在 readme.txt 中有说明 Micro SD 卡读取不到 Micro SD 读取不到现象及解决方法: 确认 SD 能否在电脑上正常使用，如果不能即 SD 已损坏， 电脑能够正常使用，读取 SD，但 MaixPy 开发板无法使用： SD 卡未格式化为 FAT/FAT32 格式，把 Micro SD 格式化为 FAT(或者 FAT32) 再尝试 电脑能够正常使用 SD 卡，也确认 SD 卡的磁盘格式为 FAT(或者 FAT32)，但 MaixPy 开发板依旧无法使用： 可能存在的原因：部分 SD 出厂时，sd 中没有磁盘分区表，或者磁盘分区表类型不是 MBR 解决的方法：使用第三方磁盘管理软件，将 sd 分区表类型转换为 MBR, 并且将 sd 格式格式化为 FAT(或者 FAT32) 这里使用 Diskgenius 来转换磁盘分区表格式 目前硬件只能支持 SPI 协议读取， 尽量购买正规的卡 比如：下图左边两张卡 MaixPy 的驱动不支持， 中间和右边的都支持， 但是中间的 class10 卡速度最快（最高测过 128GB可用） 另外测试过网上购买的几张闪迪、金士顿、三星的卡，其中发现有一张三星的卡无法使用 使用 SD 加载文件、模型不成功 现象：我们在使用过程中可能遇到加载模型提示错误， 可能存在的问题原因: sd 不兼容，挂载不成功 验证 sd 卡是否挂载方法: import os, sys print(sys.path) >>['', '.', '/flash']# 没有挂载 SD 卡 >>['', '/sd', '.', '/flash']# 挂载 SD 卡成功 为什么连接了 IDE 帧率降低了很多 K210 没有 USB 外设， 因此只能使用串口与 IDE 通信， 速度不如 USB 设备快，因此会影响帧率， 可以关闭 IDE 的摄像头预览 为什么 IDE 上预览的摄像头图像很模糊 K210 没有 USB 外设， 因此只能使用串口与 IDE 通信， 速度不如 USB 设备快， 因此对图片进行了压缩，如果需要看清晰的图像请在开发板的屏幕上看，或者保存成图片传到电脑查看 怎么提高摄像头帧率 换更好的摄像头，比如 ov7740 帧率会比 ov2640 高一点。 但前提是摄像头电路必须与开发板的电路兼容 增加摄像头时钟频率(sensor.reset(freq=))，但是注意不要太高，太高会让画面变差 可以自己编译源码，打开摄像头双缓冲选项（默认打开），并且 sensor.reset(dual_buff=True)，帧率会有所增加，但是相应地，耗费的内存也会增加（大约为 384KiB ） IDE 帧缓冲区成像方向不正确，LCD 显示方向不正确 由于 MaixPy 支持的硬件型号较多，在使用 MaixPy IDE 或者 LCD 显示的时候会出现显示的方向不正确,那么这时候我们就需要对图像进行旋转了; 在修正显示方向之前,我们需要确认是 Sensor 方向旋转(MaixPy IDE 右上角的图像即为 Sensor 直接输出的图像)了，还是 LCD 方向旋转了 修正方法: sensor 方向修正： # 设置摄像头水平镜像 # `enable`: 1 表示开启水平镜像 0 表示关闭水平镜像 sensor.set_hmirror(enable) # 设置摄像头垂直镜像 # `enable`: 1 表示开启垂直镜像 0 表示关闭垂直镜像 sensor.set_vflip(enable) lcd 方向修正： # 设置 `LCD` 屏幕方向 # 参数: `dir`: 取值范围 [0,3]， 从`0`到`3`依次顺时针旋转 # 返回值: 当前方向，取值[0,3] lcd.rotation(dir) # 设置 `LCD` 是否镜面显示 # 参数: `invert`： 是否镜面显示， `True` 或者 `False` # 返回值: 当前设置，是否镜面显示，返回`True`或者`False` lcd.mirror(invert) 烧录 MaixPy 之后，MaixPy 出现无法启动 现象：我们在使用过程中可能遇到烧录 MaixPy 之后，MaixPy 出现无法启动(表象为 无法点亮屏幕，白屏 等)， 问题原因: 出现这种现象很大一部分是内部文件系统中的配置文件读取出错，或者我们设置的系统配置值(如 gc heap 值过大)出错导致系统无法启动。 解决方法：擦除文件系统(擦除全部 flash) 下载擦除固件: erase.fpkg/flash_erase_16MB.bin 使用 JTAG 调试器一直无法接连 K210 现象：使用裸机开发 K210, JTAG 调试器一直无法接连 K210 可能的原因： OpenOCD 调试环境搭建有问题（细节这里不说明） 烧录过 ken_gen.bin 之后，将永久禁用 K210 的 JTAG 调试功能 下载，保存脚本到 MaixPy 内部flash 之后，板子无法更新固件，无法启动运行脚本 可能现象：下载，保存脚本到 MaixPy 内部flash 之后，板子无法更新固件，板子无法启动 问题可以从硬件和软件上面去定位: 可能的硬件原因： ​ TODO: 待更新 可能的软件原因： 程序中拉高了 GPIO16, 造成了自动下载点电路无法拉低 GPIO16,使 K210 进入 ISP 模式 kflash 无法烧录/更新 MaixPy 固件 kflash_gui 配置选项 开发板型号 开发板型号选错 烧录空间(SRAM/Flash) 烧录空间选错 波特率&下载速度模式 下载波特率过高 powered by GitbookFile Modify: 2020-09-11 12:05:50 "},"others/maixhub_faq.html":{"url":"others/maixhub_faq.html","title":"MaixHub 平台 FAQ","keywords":"","body":"powered by GitbookFile Modify: 2020-09-11 12:05:50 "},"deep_learning/":{"url":"deep_learning/","title":"深度学习及 KPU 基础知识","keywords":"","body":"深度学习及 KPU 基础知识 阅读完本章文档可以了解什么？ 了解深度学习一些基础内容 了解 K210 内部 KPU 的特性 了解 KPU 使用过程中可能会遇到的问题，以及问题的解决方法 概述 在本章中，将会为大家介绍深度学习和 K210 内部 KPU 的一些基础知识，以及大家在这部分容易遇到的问题。深度学习及其所涵盖的应用实例是一个非常庞大的领域，没有人能够用一篇文档就把它说得很清楚。希望这篇文档能够让大家对深度学习有一定的了解，产生超出本文档说明外的问题时，能够通过搜索引擎查询等手段解决问题。 关于深度学习 在介绍深度学习前，我们先来介绍神经网络。 ​ 什么是神经网络呢？是一种模仿动物神经网络行为特征，进行分布式并行信息处理的算法数学模型。 下面，让我们举个简单例子来说明它干了什么。 其实从某种程度来上说，我们在上小学时，就已经开始运用神经网络的相关思想来解决实际问题了。此时的你，可能满脸问号QAQ。不怕，且听我一一道来。现在，假设有一个方程 y = kx + b 。相信这个方程你一定见过无数次。其实我们可以把这个方程当作神经网络的\"模型\"，未知数\"k\"当作神经网络的权重，\"b\"当作神经网络的偏置。此时我们要训练这个神经网络模型，其实训练的过程，就是在数据集上求解全局最优权重和偏置的过程。此时，假设这个方程满足\"x=1,y=2\",\"x=2,y=4\"。这个满足条件便是上文说到的数据集，通过在人脑中，对这个网络的训练，我们可以得知整个网络的最优权重为2，最优偏置为0。此时，便完成了神经网络的训练。 不过值得提出的是，训练的最终目的，永远都是预测。古往今来，那么多神经网络消耗大量算力资源去寻找合适权重和偏置。都是为了能够寻找一个输入数据与输出数据之间的对应关系。一个优秀的神经网络，它的输入数据应该是随机的，不确定的(没有在数据集中被训练过的)。而输出数据则是准确的，可靠的。回到上文，我们训练了神经网络\"y = 2x + 0\"，此时数据集拥有的数据x为\"1\"和\"2\"。此时为了评估模型性能，我们输入非数据集数据\"3\"，此时，通过神经网络前向传播，得到了输出值\"6\"。至此，完成了神经网络模型的预测。 上文用了非常简单的demo来为大家阐述神经网络究竟在干啥，下面让我们一起看看真正的神经网络模型长啥样。 上图为大家展示了一个比较常见的全连接神经网络模型(Fully connected neural network)。对比这个网络结构与之前的\"y = 2x + 0\"网络，我们可以发现如下不同: 输入数据个数不确定(可以有n个输入) 输出数据个数不确定(可以有n个输出) 参数个数不确定(图中可以有n个全连接层，每个层所包含神经元可以有n个，从而导致参数个数为n) 模型的构造过程可以看作是参数个数的确定过程(当网络层结构确定后，参数个数也确定了)，模型的训练过程可以看作是在数据集上全局最优参数的确定过程。模型的预测过程可以看作是输入数据参数 = 预测结果的过程。(代表进行某种运算) 在对神经网络有了一定的了解后，接下来将会介绍深度学习。大家可以把深度学习当做是一种改良版的神经网络算法。它与其他几个名词之间的关系为:机器学习是人工智能的一个子集，深度学习和神经网络又是机器学习的一个子集。 神经网络和深度学习之间的区别，以及深度学习的优点等内容，由于篇幅有限，不能在此一一介绍，大家感兴趣的话，可以通过搜索引擎进行查询。 关于 KPU K210 SOC 内部搭载一颗 KPU(Neural Network Processor), KPU 即通用的神经网络处理器，它可以在低功耗的情况下实现卷积神经网络计算，时时获取被检测目标的大小、坐标和种类，对人脸或者物体进行检测和分类。 K210 搭载的 KPU 具备以下几个特点： 支持主流训练框架按照特定限制规则训练出来的定点化模型 对网络层数无直接限制，支持每层卷积神经网络参数单独配置，包括输入输出通道数目、输入输 出行宽列高 支持两种卷积内核 1x1 和 3x3 支持任意形式的激活函数 实时工作时最大支持神经网络参数大小为 5.5MiB 到 5.9MiB 非实时工作时最大支持网络参数大小为（Flash 容量-软件体积） KPU 的内部结构如下图所示。 Maixpy下 KPU 相关 API 及 Demo 可以点击此处查看。 KPU使用过程中的常见问题 1. KPU能够加载多大的模型？ 当k210运行 c 代码时，能够加载 6MB左右的模型。 当运行maixpy(mini)时，能够加载3MB左右的模型。 当运行maixpy(完整版)时，能够加载2MB左右的模型。 2. 什么模型能被KPU加载运行？ 被nncase转换后的kmodel能够被kpu加载运行。 nncase使用说明点击此处 nncase tflite ops支持点击此处 nncase 常见问题点击此处 3. KPU能通过哪些方式加载模型？ 加载TF卡中的模型 kpu.load(\"/sd/test.kmodel\") 加载Flash中的模型 kpu.load(offset) 此处的offset为模型在flash中的偏移地址，模型可以通过k-flash烧入k210内部flash中 4. 报错\"memory overflow\"怎么办？ 出现这个问题，一般是由于模型过大引起的。可以依次尝试如下解决方案: 更换maixpy mini版本固件 进行模型剪枝优化 放弃在maixpy固件下开发，而采用勘智的C SDK进行开发。 5. 报错\"load error,only support kmodel v3/v4\"怎么办？ 出现这个问题可以尝试如下解决方案: 如果为flash中加载模型，请确保flash offset填写正确，并保证和maixpy固件没有冲突。 如果是采用nncase 0.2.0进行转换的kmodel V4，请尝试采用nncase 0.1.0进行转换，从而生成kmodel V3。（截至2020/06/30，maixpy对kmodel v4的加载bug还未修复） 6. 我想实现不同模型的选择加载(例如按下按钮运行目标分类，再次按下按钮则运行目标检测)，应该怎么写程序？ 因为flash有限，固建议将所有k210模型放到TF卡内进行加载。因为内部RAM有限，所以当需要切换不同模型进行kpu.load(k210model)前，请先执行kpu.deinit(k210model)对SRAM中的模型进行释放。否则将会报错\"memory overflow\"。 powered by GitbookFile Modify: 2020-09-11 12:05:50 "},"maixhub/maixhub_platform.html":{"url":"maixhub/maixhub_platform.html","title":"模型下载使用","keywords":"","body":"Maixhub 模型训练平台使用说明 Maixhub 模型训练平台可以一键训练 AI 模型给 Maixpy 使用，用户只需提供简单的标注数据， 模型训练与转换都会在云端完成，任务完成后，用户会收到带有模型的邮件。 目前提供分类模型和目标检测模型的训练。 搜集完成数据集之后, 在训练之前请使用预处理软件生产 zip 格式的数据集文件 点击下载 DataAssitantV1.2(20200602).zip.zip>) 更新 现在也可以使用上述工具中的Data_Collection_Assitant(Classification).py, Data_Collection_Assitant(ObjectDection).py运行在 maixpy 开发板中一站式收集数据和预处理. 原初的模型训练平台使用流程: 当前的模型训练平台使用流程: 使用步骤 鉴于流程较长, 推荐参考上述当前的模型训练平台使用流程 准备数据集 数据集的采集 可使用视频 2 中所用的程序(即DataAssitantV1.2(20200602).zip)采集数据 可以使用智能手机、相机拍摄 可以从网络上搜索 数据集处理 首先将图片数据集按分类保存为单独的文件夹, 子目录的名字为最后生成 label 的名字。 注意: 分类文件夹数量要大于2个 例如: 数据集文件夹 |-Class_1 |- pic01.jpg |- pic02.jpg |- pic03.jpg |-Class_2 |- pic01.jpg |- pic02.jpg |- pic03.jpg |-Class_3 |- pic01.jpg |- pic02.jpg |- pic03.jpg 将所有分类文件夹打包为 zip 文件即可。 注意: 建议的图片分辨率 224*224, 上传之前可以使用工具批量转换一下 每个分类不要低于 40 张图片，否则无法开始训练 数据集压缩后大小不超过 20M 子目录名不能使用汉字 使用转换工具处理 工具下载地址:点击下载 DataAssitantV1.2(20200602).zip.zip>) 将预处理软件下载完成之后，解压即可使用,双击.exe 文件 选择数据集预处理模型 目标检测或目标分类 点击选择文件夹 点击开始处理即可, 处理模型为目标分类，直接把生成的 zip 文件上传到模型平台进行训练即可。 目标检测转换 使用工具转换之后，在使用 VoTT 标注生成 TFRecord 文件。 VoTT 下载地址 VoTT 帮助文档 安装完成后打开软件 然后左边这个export选项 选择 tensorflow records, 全部标注完后 点export 会在工程目录生成文件夹 将文件夹下面的文件全部打包成.zip 上传训练 训练模型 获取机器码 下载 key_gen 固件 key_gen_v1.2.zip 下载 kflash-gui kflash-gui 使用 kflash-gui 烧录 key_gen 固件 打开串口终端， 重启开发板， 可以看到打印出的机器码。 Please Send Bellow Data to Sipeed --> support@sipeed.com: 6f80dccbe29**********cc7e9d69f92 Generate key end 其中 6f80dccbe29**********cc7e9d69f92 就是对应开发板的机器码 警告： 由于需要进行模型加密，key_gen.bin 将永远关闭 JTAG 端口，并写入一次性 AES KEY，请确认后再进行烧录。 提交训练任务 打开模型训练平台 在填写邮箱处填写接受模型的邮箱 在填写机器码处填写机器码 点击上传数据集，点击上传文件选择准备好的 zip 数据集 点击开始训练，即可进入排队等待训练 训练结束后，可收到包含 kmodel 模型的邮件 使用模型 模型有两种使用方式， 可以使用 sd 卡或烧录 flash 的方式来运行模型脚本。 使用 sd 卡 烧录最新 Maixpy 固件 将邮件中的 zip 解压 将所有文件放到 sd 卡根目录 将 sd 卡插到开发板上， 重启开发板 烧录模型到 flash 模型内自带 maixpy 固件，不需要单独烧录 将邮件中的 zip 解压 打开 kflash-gui, 选择解压出的 kfpkg 文件 烧录即可 powered by GitbookFile Modify: 2020-09-11 12:05:50 "},"api_reference/":{"url":"api_reference/","title":"MaixPy API 使用手册","keywords":"","body":"powered by GitbookFile Modify: 2020-09-11 12:05:50 "},"api_reference/standard/":{"url":"api_reference/standard/","title":"MaixPy 标准库","keywords":"","body":"标准库 cmath gc math sys ubinascii ucollections uctypes uerrno uhashlib uheapq ujson uos ure uselect usocket ustruct utime uzlib powered by GitbookFile Modify: 2020-09-11 12:05:50 "},"api_reference/standard/cmath.html":{"url":"api_reference/standard/cmath.html","title":"cmath","keywords":"","body":"cmath – 复数的数学函数 该模块实现了相应CPython模块的子集，如下所述。有关更多信息，请参阅原始CPython文档: cmath. cmath 模块提供了一些处理复数的基本数学函数。 函数 cos cmath.cos(z) 返回z的余弦。 exp cmath.exp(z) 返回z的指数。 log cmath.log(z) 返回z的自然对数。分支切割沿负实轴。 log10 cmath.log10(z) 返回z的以10为底的对数。分支切割沿负实轴。 phase cmath.phase(z) 返回数字“z”的相位，范围（-pi，+ pi）。 polar cmath.polar(z) 作为元组返回z的极性形式。 rect cmath.rect(r, phi) 返回模数r和相位phi的复数。 sin cmath.sin(z) 返回z的正弦值。 sqrt cmath.sqrt(z) 返回z的平方根。 Constants cmath.e 自然对数的基础 cmath.pi 圆周长与直径的比值 powered by GitbookFile Modify: 2020-09-11 12:05:50 "},"api_reference/standard/math.html":{"url":"api_reference/standard/math.html","title":"math","keywords":"","body":"math – 数学函数 该模块实现了相应CPython模块的子集，如下所述。有关更多信息，请参阅原始CPython文档：math. math模块提供了一些处理浮点数的基本数学函数。 函数 math.acos(x) 返回x的反余弦值。 math.acosh(x) 返回x的反双曲余弦值。 math.asin(x) 返回x的反正弦。 math.asinh(x) 返回x的反双曲正弦值。 math.atan(x) 返回x的反正切。 math.atan2(y, x) 返回y /x的反正切的主值。 math.atanh(x) 返回x的反双曲正切。 math.ceil(x) 返回一个整数，“x”向正无穷大四舍五入。 math.copysign(x, y) 以y的符号返回x。 math.cos(x) 返回x的余弦。 math.cosh(x) 返回x的双曲余弦值 math.degrees(x) 返回弧度x转换为度数。 math.erf(x) 返回x的错误函数。 math.erfc(x) 返回x的互补误差函数。 math.exp(x) 返回x的指数。 math.expm1(x) 返回exp（x） - 1。 math.fabs(x) 返回x的绝对值。 math.floor(x) 返回一个整数，“x”向负无穷大舍入。 math.fmod(x, y) 返回x /y的余数。 math.frexp(x) 将浮点数分解为尾数和指数。返回的值是元组（m，e），使得x == m * 2 ** e完全正确。如果x == 0则函数返回（0.0,0），否则关系0.5 成立。 math.gamma(x) 返回x的伽玛函数。 math.isfinite(x) 如果x是有限的，则返回True。 math.isinf(x) 如果x是无限的，则返回True。 math.isnan(x) 如果x不是数字，则返回True math.ldexp(x, exp) 返回x *（2 ** exp）。 math.lgamma(x) 返回x的伽玛函数的自然对数。 math.log(x) 返回x的自然对数。 math.log10(x) 返回x的以10为底的对数。 math.log2(x) 返回x的base-2对数。 math.modf(x) 返回两个浮点数的元组，是“x”的分数和整数部分。两个返回值都与x具有相同的符号。 math.pow(x, y) 将x返回到'y`的幂。 math.radians(x) 返回度数x转换为弧度。 math.sin(x) 返回x的正弦值。 math.sinh(x) 返回x的双曲正弦值。 math.sqrt(x) 返回x的平方根。 math.tan(x) 返回x的正切值。 math.tanh(x) 返回x的双曲正切。 math.trunc(x) 返回一个整数，“x”向0舍入。 Constants math.e 自然对数的基础 math.pi 圆周长与直径的比值 powered by GitbookFile Modify: 2020-09-11 12:05:50 "},"api_reference/standard/sys.html":{"url":"api_reference/standard/sys.html","title":"sys","keywords":"","body":"sys – 系统特定功能 该模块实现了相应CPython模块的子集，如下所述。 有关更多信息，请参阅原始CPython文档：sys. 功能函数 sys.exit(retval=0) 使用给定的退出代码终止当前程序。 根据此，此函数引发“SystemExit”异常。 如果给出了一个参数，它的值作为SystemExit的参数给出。 sys.print_exception(exc, file=sys.stdout) 使用回溯到类文件对象文件（或默认情况下为sys.stdout）打印异常。 和 CPython 的不同 这是一个函数的简化版本，它出现在CPython的回溯模块中。 与traceback.print_exception（）不同，此函数只接受异常值而不是异常类型，异常值和回溯对象; file参数应该是位置的; 不支持其他参数。 可以在micropython-lib中找到与CPython兼容的回溯模块。 常量 sys.argv 当前程序启动时的可变参数列表。 sys.byteorder 系统的字节顺序（“小端”或“大端”`）。 sys.implementation 包含有关当前Python实现的信息的对象。 对于MicroPython，它具有以下属性： name - 字符串“micropython” version - 元组 (major, minor, micro), e.g. (1, 7, 0) 此对象是区分MicroPython与其他Python实现的推荐方法（请注意，它仍然可能不存在于非常小的端口中）。 和 CPython 的不同 CPython要求为此对象提供更多属性，但实际有用的最低要求是在MicroPython中实现的。 sys.maxsize 本机整数类型可以在当前平台上保存的最大值，或MicroPython整数类型可表示的最大值，如果它小于平台最大值（对于没有长int支持的MicroPython端口的情况）。 此属性对于检测平台的“位数”（32位与64位等）非常有用。 建议不要直接将此属性与某个值进行比较，而是计算其中的位数： bits = 0 v = sys.maxsize while v: bits += 1 v >>= 1 if bits > 32: # 64-bit (or more) platform ... else: # 32-bit (or less) platform # Note that on 32-bit platform, value of bits may be less than 32 # (e.g. 31) due to peculiarities described above, so use \"> 16\", # \"> 32\", \"> 64\" style of comparisons. sys.modules 加载模块的字典。 在某些端口上，它可能不包含内置模块。 sys.path 用于搜索导入模块的可变目录列表。 sys.platform 运行 MicroPython 的平台。 对于OS / RTOS端口，这通常是OS的标识符，例如，“LINUX”。 对于裸金属端口，它是电路板的标识符，例如 “pyboard”用于原始的 MicroPython 参考板。 因此，它可用于区分一块板与另一块板。 如果您需要检查您的程序是否在 MicroPython 上运行（与其他 Python 实现相比），请使用sys.implementation。 sys.stderr 标准错误 stream. sys.stdin 标准输入 stream. sys.stdout 标准输出 stream. sys.version 实现的 Python 版本， 返回一个字符串 sys.version_info 实现的 Python 版本， 返回一个由整数组成的元组 powered by GitbookFile Modify: 2020-09-11 12:05:50 "},"api_reference/standard/ubinascii.html":{"url":"api_reference/standard/ubinascii.html","title":"ubinascii","keywords":"","body":"ubinascii – 二进制/ ASCII转换 该模块实现了相应CPython模块的子集，如下所述。有关更多信息，请参阅原始CPython文档：binascii. 该模块以ASCII格式（两个方向）实现二进制数据与其各种编码之间的转换。 函数 ubinascii.hexlify(data[, sep]) 将二进制数据转换为十六进制表示。返回字节字符串。 与CPython的区别 如果提供了附加参数sep，则它将用作十六进制值之间的分隔符。 ubinascii.unhexlify(data) 将十六进制数据转换为二进制表示。返回字节字符串。 （即hexlify的倒数） ubinascii.a2b_base64(data) 解码base64编码的数据，忽略输入中的无效字符。符合 RFC 2045 s.6.8. 返回一个bytes对象。 ubinascii.b2a_base64(data) 以base64格式编码二进制数据，如 RFC 3548所述。返回编码数据，后跟换行符，作为bytes对象。 powered by GitbookFile Modify: 2020-09-11 12:05:50 "},"api_reference/standard/ucollections.html":{"url":"api_reference/standard/ucollections.html","title":"ucollections","keywords":"","body":"ucollections – 集合和容器类型 该模块实现了相应CPython模块的子集，如下所述。有关更多信息，请参阅原始CPython文档 collections. 此模块实现高级集合和容器类型以保存/累积各种对象。 类 ucollections.deque(iterable, maxlen[, flags]) Deques（双端队列）是一个类似列表的容器，支持O（1）追加并从双端队列的任一侧弹出。使用以下参数创建新的deques： iterable必须是空元组，并且新的deque被创建为空。 必须指定maxlen，并且双端队列将限制为此最大长度。一旦双端队列已满，添加的任何新项目将丢弃对方的项目。 添加项目时，可选标志可以为1以检查溢出。 除了支持bool和len之外，deque对象还有以下方法： deque.append(x) 将x添加到双端队列的右侧。如果启用了溢出检查并且没有剩余空间，则引发 IndexError。 deque.popleft() 从双端队列的左侧移除并返回一个项目。如果没有项目，则引发 IndexError。 ucollections.namedtuple(name, fields) 这是工厂函数，用于创建具有特定名称和字段集的新的namedtuple类型。 namedtuple是元组的子类，它不仅可以通过数字索引访问其字段，还可以使用符号字段名称访问属性访问语法。 Fields是指定字段名称的字符串序列。为了与CPython兼容，它也可以是一个以空格分隔的字段命名的字符串（但效率较低）。使用示例： from ucollections import namedtuple MyTuple = namedtuple(\"MyTuple\", (\"id\", \"name\")) t1 = MyTuple(1, \"foo\") t2 = MyTuple(2, \"bar\") print(t1.name) assert t2.name == t2[1] ucollections.OrderedDict(...) dict类型子类，它记住并保留添加的键的顺序。当迭代命令dict时，按照添加的顺序返回键/项： from ucollections import OrderedDict # To make benefit of ordered keys, OrderedDict should be initialized # from sequence of (key, value) pairs. d = OrderedDict([(\"z\", 1), (\"a\", 2)]) # More items can be added as usual d[\"w\"] = 5 d[\"b\"] = 3 for k, v in d.items(): print(k, v) Output: z 1 a 2 w 5 b 3 powered by GitbookFile Modify: 2020-09-11 12:05:50 "},"api_reference/standard/uctypes.html":{"url":"api_reference/standard/uctypes.html","title":"uctypes","keywords":"","body":"uctypes – 以结构化方式访问二进制数据 该模块为MicroPython实现“外部数据接口”。 它背后的想法类似于CPython的ctypes模块，但实际的API是不同的，流线型和小尺寸优化。 该模块的基本思想是定义具有与C语言允许的功能大致相同的数据的数据结构布局，然后使用熟悉的点语法访问它以引用子字段。 警告 uctypes模块允许访问机器的任意内存地址（包括I / O和控制寄存器）。 不小心使用它可能会导致崩溃，数据丢失，甚至硬件故障。 也可参考 ustruct模块 用于访问二进制数据结构的标准Python方法（不能很好地扩展到大型和复杂的结构）。 例程： import uctypes # Example 1: Subset of ELF file header # https://wikipedia.org/wiki/Executable_and_Linkable_Format#File_header ELF_HEADER = { \"EI_MAG\": (0x0 | uctypes.ARRAY, 4 | uctypes.UINT8), \"EI_DATA\": 0x5 | uctypes.UINT8, \"e_machine\": 0x12 | uctypes.UINT16, } # \"f\" is an ELF file opened in binary mode buf = f.read(uctypes.sizeof(ELF_HEADER, uctypes.LITTLE_ENDIAN)) header = uctypes.struct(uctypes.addressof(buf), ELF_HEADER, uctypes.LITTLE_ENDIAN) assert header.EI_MAG == b\"\\x7fELF\" assert header.EI_DATA == 1, \"Oops, wrong endianness. Could retry with uctypes.BIG_ENDIAN.\" print(\"machine:\", hex(header.e_machine)) # Example 2: In-memory data structure, with pointers COORD = { \"x\": 0 | uctypes.FLOAT32, \"y\": 4 | uctypes.FLOAT32, } STRUCT1 = { \"data1\": 0 | uctypes.UINT8, \"data2\": 4 | uctypes.UINT32, \"ptr\": (8 | uctypes.PTR, COORD), } # Suppose you have address of a structure of type STRUCT1 in \"addr\" # uctypes.NATIVE is optional (used by default) struct1 = uctypes.struct(addr, STRUCT1, uctypes.NATIVE) print(\"x:\", struct1.ptr[0].x) # Example 3: Access to CPU registers. Subset of STM32F4xx WWDG block WWDG_LAYOUT = { \"WWDG_CR\": (0, { # BFUINT32 here means size of the WWDG_CR register \"WDGA\": 7 定义结构布局 结构布局由“描述符”定义 - 一个Python字典，它将字段名称编码为键，以及将它们作为关联值访问它们所需的其他属性： { \"field1\": , \"field2\": , ... } 目前，uctypes需要明确规定每个字段的偏移量。 从结构开始以字节为单位给出偏移量。 以下是各种字段类型的编码示例： 标量类型: \"field_name\": offset | uctypes.UINT32 换句话说，该值是标量类型标识符，与结构起始处的字段偏移量（以字节为单位）进行或运算。 递归结构： \"sub\": (offset, { \"b0\": 0 | uctypes.UINT8, \"b1\": 1 | uctypes.UINT8, }) 即，值是2元组，其第一个元素是偏移量，第二个是结构描述符字典（注意：递归描述符中的偏移量与其定义的结构相关）。 当然，递归结构不仅可以通过文字字典指定，还可以通过按名称引用结构描述符字典（前面定义）来指定。 原始类型的数组： \"arr\": (offset | uctypes.ARRAY, size | uctypes.UINT8), 即，值是一个2元组，其第一个元素是ARRAY标志与偏移进行OR运算，第二个是标量元素类型ORed数组中的元素数。 *聚合类型数组： \"arr2\": (offset | uctypes.ARRAY, size, {\"b\": 0 | uctypes.UINT8}), 即，值是一个3元组，其第一个元素是ARRAY标志，与偏移相关，第二个是数组中的元素数，第三个是元素类型的描述符。 *指向原始类型的指针： \"ptr\": (offset | uctypes.PTR, uctypes.UINT8), 即，值是2元组，其第一个元素是PTR标志与偏移进行OR运算，第二个元素是标量元素类型。 *指向聚合类型的指针： \"ptr2\": (offset | uctypes.PTR, {\"b\": 0 | uctypes.UINT8}), 即，值是2元组，其第一个元素是PTR标志与偏移量进行OR运算，第二个元素是指向的类型的描述符。 *比特场： \"bitf0\": offset | uctypes.BFUINT16 | lsbit 即，value是一种包含给定位域的标量值（类型名称类似于标量类型，但前缀为“BF”），与包含位域的标量值的偏移进行OR运算，并进一步与位位置和位长度的值进行“或”运算。标量值内的位域，分别移位BF_POS和BF_LEN位。位域位置从标量的最低有效位（具有0的位置）开始计数，并且是字段的最右位的数量（换句话说，它是标量需要向右移位的位数）提取位域）。 在上面的例子中，首先在偏移0处提取UINT16值（当访问硬件寄存器时，这个细节可能很重要，需要特定的访问大小和对齐），然后是最右边的位是此UINT16的lsbit位的位域，以及length是bitsize bits，将被提取。例如，如果lsbit为0且bitsize为8，那么它将有效地访问UINT16的最低有效字节。 注意，位域操作独立于目标字节字节序，特别是上面的例子将在小端和大端结构中访问UINT16的最低有效字节。但它取决于最低有效位被编号为0.某些目标可能在其原生ABI中使用不同的编号，但是“uctypes”总是使用上述的标准化编号。 模块内容 class uctypes.struct(addr, descriptor, layout_type=NATIVE) 基于内存中的结构地址，描述符（编码为字典）和布局类型（参见下文）来实例化“外部数据结构”对象。 uctypes.LITTLE_ENDIAN little-endian压缩结构的布局类型。 （打包意味着每个字段占用描述符中定义的字节数，即对齐为1）。 uctypes.BIG_ENDIAN big-endian压缩结构的布局类型。 uctypes.NATIVE 本机结构的布局类型 - 数据字节顺序和对齐符合运行MicroPython的系统的ABI。 uctypes.sizeof(struct, layout_type=NATIVE) 以字节为单位返回数据结构的大小。 struct参数可以是结构类，也可以是特定的实例化结构对象（或其聚合字段）。 uctypes.addressof(obj) 返回对象的地址。 参数应该是字节，字节数组或其他支持缓冲区协议的对象（该缓冲区的地址实际上是返回的）。 uctypes.bytes_at(addr, size) 以给定的地址和大小捕获内存作为bytes对象。 由于bytes对象是不可变的，因此内存实际上是复制并复制到bytes对象中，因此如果内存内容稍后更改，则创建的对象将保留原始值。 uctypes.bytearray_at(addr, size) 将给定地址和大小的内存捕获为bytearray对象。 与上面的bytes_at（）函数不同，内存是通过引用捕获的，因此它也可以写入，并且您将在给定的内存地址访问当前值。 uctypes.UINT8 uctypes.INT8 uctypes.UINT16 uctypes.INT16 uctypes.UINT32 uctypes.INT32 uctypes.UINT64 uctypes.INT64 结构描述符的整数类型。 提供了8,16,32和64位类型的常量，包括有符号和无符号。 uctypes.FLOAT32 uctypes.FLOAT64 结构描述符的浮点类型。 uctypes.VOID VOID是UINT8的别名，用于方便地定义C的void指针：（uctypes.PTR，uctypes.VOID）。 uctypes.PTR uctypes.ARRAY 输入指针和数组的常量。 请注意，结构没有显式常量，它是隐式的：没有PTR或ARRAY标志的聚合类型是一种结构。 结构描述符和实例化结构对象 给定结构描述符字典及其布局类型，您可以使用uctypes.struct（）构造函数在给定的内存地址实例化特定的结构实例。 内存地址通常来自以下来源： *访问裸机系统上的硬件寄存器时的预定义地址。 在特定MCU / SoC的数据表中查找这些地址。 *作为调用某些FFI（外部函数接口）函数的返回值。 *来自uctypes.addressof（），当您想要将参数传递给FFI函数时，或者访问I / O的某些数据（例如，从文件或网络套接字读取的数据）。 结构对象 结构对象允许使用标准点表示法访问单个字段：`my_struct.substruct1.field1。如果字段是标量类型，获取它将产生与字段中包含的值对应的原始值（Python整数或浮点数）。 标量字段也可以分配给。 如果某个字段是一个数组，则可以使用标准的下标运算符[]访问其各个元素 - 同时读取和分配。 如果一个字段是一个指针，它可以使用[0]语法解除引用（对应于C *运算符，尽管[0]也适用于C）。 还支持使用其他整数值（但是为0）订阅指针，其语义与C中相同。 总而言之，访问结构字段通常遵循C语法，除了指针取消引用，当您需要使用[0]运算符而不是*时。 限制 访问非标量字段会导致分配中间对象以表示它们。这意味着应该特别注意布局在禁用内存分配时（例如从中断）需要访问的结构。建议如下： 避免访问嵌套结构。例如，代替mcu_registers.peripheral_a.register1，为每个外设定义单独的布局描述符，作为peripheral_a.register1进行访问。或者只缓存特定的外设：peripheral_a = mcu_registers.peripheral_a。如果寄存器由多个位域组成，则需要缓存对特定寄存器的引用：reg_a = mcu_registers.peripheral_a.reg_a。 避免使用其他非标量数据，如数组。例如，使用peripheral_a.register0而不是peripheral_a.register [0]。同样，另一种方法是缓存中间值，例如register0 = peripheral_a.register [0]。 uctypes模块支持的偏移范围是有限的。支持的确切范围被认为是实现细节，一般建议是将结构定义拆分为从几千字节到几十千字节的最大值。在大多数情况下，这是一种自然情况，例如，在一个结构中定义MCU的所有寄存器（扩展到32位地址空间）没有意义，而是通过外设块定义外设块。在某些极端情况下，您可能需要人工分割几个部分的结构（例如，如果在中间访问具有多兆字节数组的本机数据结构，尽管这将是非常合成的情况）。） powered by GitbookFile Modify: 2020-09-11 12:05:50 "},"api_reference/standard/uerrno.html":{"url":"api_reference/standard/uerrno.html","title":"uerrno","keywords":"","body":"uerrno — 系统错误代码 该模块实现了相应CPython模块的子集，如下所述。有关更多信息，请参阅原始CPython文档：errno。 该模块描述了 OSError 错误的错误标识。特定的代码库存取决于 Micropython 的移植， 错误会在特定的会出现错误的函数进行说明。 常量 EEXIST, EAGAIN, 等 基于 ANSI C / POSIX 标准的错误代码。所有错误代码均以 “E” 开头。如上所述，代码库存取决于 MicroPython 的移植。错误通常可以作为exc.args [0]访问，其中exc是OSError的一个实例。用法示例： try: uos.mkdir(\"my_dir\") except OSError as exc: if exc.args[0] == uerrno.EEXIST: print(\"Directory already exists\") uerrno.errorcode 字典将数字错误代码映射到带有符号错误代码的字符串（参见上文）： >>> print(uerrno.errorcode[uerrno.EEXIST]) EEXIST powered by GitbookFile Modify: 2020-09-11 12:05:50 "},"api_reference/standard/uhashlib.html":{"url":"api_reference/standard/uhashlib.html","title":"uhashlib","keywords":"","body":"uhashlib –哈希算法 该模块实现了相应CPython模块的子集，如下所述。有关更多信息，请参阅原始CPython文档：hashlib。 该模块实现二进制数据哈希算法。可用算法的确切清单取决于电路板。在可以实现的算法中： SHA256-SHA2系列的最新现代哈希算法。它适用于密码安全的目的。除非它具有特定的代码大小限制，否则建议将其包含在MicroPython内核中，并建议任何开发板都提供此功能。 在 K210 中有硬件加速，不是软件计算 构造函数 类 uhashlib.sha256([data]) 创建一个SHA256哈希对象，并有选择地向其中馈送数据。 方法 hash.update(data) 将更多的二进制数据输入哈希。 hash.digest() 返回通过哈希传递的所有数据的哈希，作为字节对象。调用此方法后，无法再将更多数据馈入哈希。 hash.hexdigest() 未实现此方法。使用 ubinascii.hexlify(hash.digest()) 可获得类似的效果。 powered by GitbookFile Modify: 2020-09-11 12:05:50 "},"api_reference/standard/uheapq.html":{"url":"api_reference/standard/uheapq.html","title":"uheapq","keywords":"","body":"uheapq – 堆队列算法 该模块实现了对应 CPython 模块的子集，如下所述。 有关更多信息，请参阅原始CPython文档：heapq。 该模块实现堆队列算法。 堆队列只是一个以某种方式存储其元素的列表。 函数 heappush uheapq.heappush(heap, item) 将元素放入堆。 heappop uheapq.heappop(heap) 弹出堆中的第一个元素，然后将其返回。 如果heap为空，则引发IndexError。 heapify uheapq.heapify(x) 将列表x转换为堆。 这是一个 in-place（划分交换排序）操作。 powered by GitbookFile Modify: 2020-09-11 12:05:50 "},"api_reference/standard/ujson.html":{"url":"api_reference/standard/ujson.html","title":"ujson","keywords":"","body":"ujson – JSON encoding and decoding 该模块实现了相应 CPython 模块的子集，如下所述。有关更多信息，请参阅原始 CPython 文档：json. 此模块允许在 Python 对象和 JSON 数据格式之间进行转换。 函数 dump ujson.dump(obj, stream) 将 obj 序列化化为 JSON 字符串，将其写入给定的流。 dumps ujson.dumps(obj) 返回表示为 JSON 字符串的 obj。 load ujson.load(stream) 解析给定的流，将其解释为 JSON 字符串并将数据反序列化为 Python 对象。返回结果对象。 解析继续，直到遇到文件结尾。如果未正确形成流中的数据，则会引发 ValueError。 loads ujson.loads(str) 解析JSON str并返回一个对象。如果字符串格式出错，则引发ValueError。 powered by GitbookFile Modify: 2020-09-11 12:05:50 "},"api_reference/standard/uos.html":{"url":"api_reference/standard/uos.html","title":"uos","keywords":"","body":"uos – 基本的“操作系统”服务 该模块实现了相应CPython模块的子集，如下所述。有关更多信息，请参阅原始CPython文档：os。 uos模块包含用于文件系统访问和挂载，终端重定向和复制以及uname和urandom等函数。 常用函数 uos.uname() 返回一个元组（可能是一个命名了的元组），其中包含有关底层机器和/或其操作系统的信息。元组按以下顺序有五个字段，每个字段都是一个字符串： sysname - 底层系统的名称 nodename - 节点名（/板子名称）（可以与sysname相同） release - 底层系统的版本 version - MicroPython版本和构建日期 machine - 底层硬件的标识符（例如，板，CPU） uos.urandom(n) 返回一个包含n个随机字节的字节对象。只要有可能，它就由硬件随机数生成器生成。 文件系统访问 uos.chdir(path) 更改当前目录。 uos.getcwd() 获取当前目录。 uos.ilistdir([dir]) 此函数返回一个迭代器，然后生成与列出的目录中的条目对应的元组。如果不传参数，它列出了当前目录，否则它列出了dir给出的目录。 元组具有形式（名称，类型，inode [，大小]）： name： 是一个字符串（如果dir是一个字节对象，则为字节），并且是条目的名称; type： 是一个整数，指定条目的类型，目录为 0x4000，常规文件为 0x8000; inode： 是对应于文件inode的整数，对于没有这种概念的文件系统可以是0。 某些平台可能会返回包含条目大小的4元组。对于文件条目，size是表示文件大小的整数，如果未知则为-1。目前条目的含义目前尚未定义。 uos.listdir([dir]) 如果没有参数，请列出当前目录。否则列出给定目录。 uos.mkdir(path) 创建一个新目录。 uos.remove(path) 删除文件。 uos.rmdir(path) 删除目录。 uos.rename（old_path，new_path） 重命名文件。 uos.stat(path) 获取文件或目录的状态。 uos.statvfs(path) 获取文件系统的状态。 按以下顺序返回包含文件系统信息的元组： f_bsize - 文件系统块大小 f_frsize - 片段大小 f_blocks - f_frsize单位中fs的大小 f_bfree - 空闲块数 f_bavail - 无特权用户的空闲块数 f_files - inode数量 f_ffree - 免费inode的数量 f_favail - 无特权用户的免费inode数 f_flag - 挂载标志 f_namemax - 最大文件名长度 与inode相关的参数：f_files，f_ffree，f_avail和f_flags参数可能返回'0`，因为它们在特定于硬件的实现中不可用。 uos.sync() 同步所有文件系统。 终端重定向和复制 uos.dupterm(stream_object，index = 0) 在给定的stream类对象上复制或切换MicroPython终端（REPL）。 stream_object参数必须实现readinto（）和write（）方法。流应处于非阻塞模式，如果没有可用于读取的数据，readinto（）应返回'None`。 调用此函数后，将在此流上重复所有终端输出，并且流上可用的任何输入都将传递到终端输入。 index参数应为非负整数，并指定设置的复制槽。给定端口可以实现多个槽（槽0将始终可用），并且在这种情况下，终端输入和输出在所有设置的槽上复制。 如果None作为stream_object传递，则在索引给出的槽上取消复制。 该函数返回给定槽中的前一个类似流的对象。 文件系统挂载 某些端口提供虚拟文件系统（VFS）以及在此VFS中安装多个“真实”文件系统的功能。文件系统对象可以安装在VFS的根目录中，也可以安装在根目录中的子目录中。这允许Python程序看到的文件系统的动态和灵活配置。具有此功能的端口提供mount（）和umount（）函数，以及可能由VFS类表示的各种文件系统实现。 uos.mount(fsobj，mount_point，*，readonly) 将文件系统对象fsobj挂载到mount_point字符串指定的VFS中的位置。 fsobj可以是一个具有mount（）方法或块设备的VFS对象。如果它是块设备，则会自动检测文件系统类型（如果未识别文件系统，则会引发异常）。 mount_point可以是'/'在根目录下挂载fsobj，或者'/ '挂载到根目录下的子目录中。 如果readonly为“True”，则文件系统以只读方式挂载。 在mount过程中，在文件系统对象上调用mount（）方法。 如果mount_point已经挂载，将引发OSError（EPERM）。 uos.umount(mount_point) 卸载文件系统。 mount_point可以是命名安装位置的字符串，也可以是先前安装的文件系统对象。在卸载过程中，在文件系统对象上调用方法umount（）。 如果找不到mount_point，会引发OSError（EINVAL）。 class uos.VfsFat(block_dev) 创建使用FAT文件系统格式的文件系统对象。 FAT文件系统的存储由block_dev提供。可以使用mount（）挂载由此构造函数创建的对象。 static mkfs(block_dev) 在block_dev上构建FAT文件系统。 文件系统格式化 在MaixPy中，我们提供了对flash进行文件系统格式化的操作。如果用户想要清空flash文件系统那么可以使用该接口 flash_format 来实现 uos.flash_format() 该接口不需要传入参数，直接使用将对开发板的 flash 进行格式化。请注意，格式化将清空所有文件，在使用前请确认 flash 中文件都是需要删除的 块设备 块设备是实现块协议的对象，块协议是由 AbstractBlockDev 类在下面描述的一组方法。该类的具体实现通常允许访问类似存储器的功能作为硬件（如闪存）。特定文件系统驱动程序可以使用块设备来存储其文件系统的数据。 class uos.AbstractBlockDev()...) 构造块设备对象。构造函数的参数取决于特定的块设备。 readblocks(block_num, buf) 从索引block_num给出的块开始，将块从设备读入buf（字节数组）。要读取的块数由buf的长度给出，该长度将是块大小的倍数。 writeblocks(block_num, buf) 从索引block_num给出的块开始，将buf（字节数组）中的块写入设备。要写入的块数由buf的长度给出，该长度将是块大小的倍数。 ioctl(op, arg) 控制块设备并查询其参数。要执行的操作由op给出，它是以下整数之一： 1 - 初始化设备（arg未使用） 2 - 关闭设备（arg未使用） 3 - 同步设备（arg未使用） 4 - 获取块数的计数，应该返回一个整数（arg未使用） 5 - 获取块中的字节数，应该返回一个整数，或者“None”，在这种情况下使用默认值512（arg未使用） 例程 例程1 以fat32举例，下面的类将实现一个块设备，它使用bytearray将其数据存储在RAM中： class RAMBlockDev: def __init__(self, block_size, num_blocks): self.block_size = block_size self.data = bytearray(block_size * num_blocks) def readblocks(self, block_num, buf): for i in range(len(buf)): buf[i] = self.data[block_num * self.block_size + i] def writeblocks(self, block_num, buf): for i in range(len(buf)): self.data[block_num * self.block_size + i] = buf[i] def ioctl(self, op, arg): if op == 4: # get number of blocks return len(self.data) // self.block_size if op == 5: # get block size return self.block_size 或者： import uos bdev = RAMBlockDev(512, 50) uos.VfsFat.mkfs(bdev) vfs = uos.VfsFat(bdev) uos.mount(vfs, '/ramdisk') 例程2 以spiffs举例，下面的类将实现一个块设备，它使用bytearray将其数据存储在RAM中： class RAMFlashDev: def __init__(self): self.fs_size = 256*1024 self.fs_data = bytearray(256*1024) self.erase_block = 32*1024 self.log_block_size = 64*1024 self.log_page_size = 4*1024 def read(self,buf,size,addr): for i in range(len(buf)): buf[i] = self.fs_data[addr+i] def write(self,buf,size,addr): for i in range(len(buf)): self.fs_data[addr+i] = buf[i] def erase(self,size,addr): for i in range(size): self.fs_data[addr+i] = 0xff blkdev = RAMFlashDev.RAMFlashDev() vfs = uos.VfsSpiffs(blkdev) vfs.mkfs(vfs) uos.mount(vfs,'/ramdisk') powered by GitbookFile Modify: 2020-09-11 12:05:50 "},"api_reference/standard/ure.html":{"url":"api_reference/standard/ure.html","title":"ure","keywords":"","body":"ure – 简单的正则表达式 该模块实现了相应CPython模块的子集，如下所述。 有关更多信息，请参阅原始CPython文档：re. 该模块实现了正则表达式操作。 支持的正则表达式语法是CPythonre模块的子集（实际上是POSIX扩展正则表达式的子集）。 支持的运算符和特殊序列 . : 匹配任何字符。 [...] : 匹配字符集。 支持单个字符和范围，包括否定集（例如[^ a-c]）。 ^ : 匹配字符串的开头。 $ : 匹配字符串的结尾。 ? : 匹配零个或前一个子模式之一。 * : 匹配前一个子模式的零个或多个。 + : 匹配前一个子模式中的一个或多个。 ?? : 非贪婪版的？，匹配零或一，偏好为零。 *? : *的非贪婪版本，匹配零或更多，优先选择最短匹配。 +? : 非贪婪的“+”版本，匹配一个或多个，优先匹配最短。 | : 匹配此运算符的左侧或右侧子模式。 (...) : 分组。 每个组都在捕获（它捕获的子字符串可以使用`match.group（）方法访问）。 \\d : 匹配数字。 相当于[0-9]。 \\D : 匹配非数字。 相当于[^ 0-9]。 \\s : \\S : 匹配空白。 相当于 [^ \\t-\\r]. \\w : 匹配“单词字符”（仅限ASCII）。 相当于 [A-Za-z0-9_]. \\W : 匹配非“单词字符”（仅限ASCII）。 相当于 [^A-Za-z0-9_]. \\ : 转义字符。 除了上面列出的那些之外，反斜杠后面的任何其他字符都是字面意思。 例如，\\*等同于文字*（不被视为*运算符）。 请注意，\\r，\\n，等不是专门处理的，并且相当于文字字母r，n等。因此，不建议使用原始Python字符串（r“”）用于正则表达式。 例如，r“\\r \\n”用作正则表达式时相当于“rn”。 要匹配CR后跟LF的字符，请使用\"\\r\\n\"。 不支持的表达式 重复计算 ({m,n}) 命名组 ((?P...)) 非捕获组 ((?:...)) 更高级的断言 (\\b, \\B) 像\\r，\\n这样的特殊字符转义 - 使用Python自己的转义 其它 例子： import ure # As ure doesn't support escapes itself, use of r\"\" strings is not # recommended. regex = ure.compile(\"[\\r\\n]\") regex.split(\"line1\\rline2\\nline3\\r\\n\") # Result: # ['line1', 'line2', 'line3', '', ''] 方法 ure.compile(regex_str[, flags]) 编译正则表达式， 返回regex 对象。 ure.match(regex_str, string) 编译regex_str并匹配字符串。 匹配始终从字符串中的起始位置开始。 ure.search(regex_str, string) 编译regex_str并在字符串中搜索它。 与match不同，这将搜索字符串以匹配正则表达式的第一个位置（如果正则表达式被锚定，它仍然可以是0）。 ure.sub(regex_str, replace, string, count=0, flags=0) 编译regex_str并在字符串中搜索它，用replace替换所有匹配项，并返回新字符串。 replace可以是字符串或函数。 如果它是一个字符串，那么\\和\\g形式的转义序列可用于扩展到相应的组（或不匹配组的空字符串）。 如果replace是一个函数，那么它必须采用一个参数（匹配）并且应该返回一个替换字符串。 如果指定了count并且非零，那么在进行许多替换之后，替换将停止。 flags参数被忽略。 注意：此函数的可用性取决于MicroPython port。 ure.DEBUG 标记值，显示有关已编译表达式的调试信息。 （可用性取决于MicroPython 移植实现。） Regex 对象 编译了的正则表达式。 使用ure.compile()创建此类的实例。 regex.match(string) regex.search(string) regex.sub(replace, string, count=0, flags=0) 类似于模块级函数match（），search（）和sub（）。 如果将相同的正则表达式应用于多个字符串，则使用方法会更高效。 regex.split(string, max_split=-1) 使用正则表达式拆分字符串。 如果给出 max_split，则指定要执行的最大拆分数。 返回字符串列表（如果指定了，则最多可以有 max_split + 1 个元素）。 Match 对象 匹配match（）和search（）方法返回的对象，并传递给sub（）中的替换函数。 match.group(index) 返回匹配（子）字符串。 整个匹配的索引为0，每个捕获组的索引为1和更高。 仅支持数字组。 match.groups() 返回包含匹配组的所有子串的元组。 注意：此方法的可用性取决于MicroPython 移植实现。 match.start([index]) match.end([index]) 返回匹配的子字符串组的开头或结尾的原始字符串中的索引。 index默认为整个组，否则将选择一个组。 注意：这些方法的可用性取决于MicroPython 移植实现。 match.span([index]) 返回2元组（match.start（index），match.end（index））。 注意：此方法的可用性取决于MicroPython 移植 是否实现。 powered by GitbookFile Modify: 2020-09-11 12:05:50 "},"api_reference/standard/uselect.html":{"url":"api_reference/standard/uselect.html","title":"uselect","keywords":"","body":"powered by GitbookFile Modify: 2020-09-11 12:05:50 "},"api_reference/standard/ustruct.html":{"url":"api_reference/standard/ustruct.html","title":"ustruct","keywords":"","body":"ustruct – 打包和解包原始数据类型 该模块实现了相应的CPython模块的子集，如下所述。有关更多信息，请参阅原始CPython文档： struct. 支持的大小/字节顺序前缀: @, , >, !. 支持的格式代码： b, B, h, H, i, I, l, L, q, Q, s, P, f, d （后者2取决于浮点支持）。 函数 calcsize ustruct.calcsize(fmt) 返回存储给定fmt所需的字节数。 pack ustruct.pack(fmt, v1, v2, ...) 根据格式字符串fmt打包值v1，v2，...。返回值是编码值的字节对象。 pack_into ustruct.pack_into(fmt, buffer, offset, v1, v2, ...) 根据格式字符串fmt将值v1，v2，...打包到从offset开始的缓冲区中。从缓冲区的末尾开始计数可能是负数。 unpack ustruct.unpack(fmt, data) 根据格式字符串fmt从data解包。返回值是解压缩值的元组。 unpack_from ustruct.unpack_from(fmt, data, offset=0) 根据格式字符串fmt从 offset 开始从data解包。 offset可能是负数，从缓冲区的末尾开始计数。返回值是解压缩值的元组。 powered by GitbookFile Modify: 2020-09-11 12:05:50 "},"api_reference/standard/utime.html":{"url":"api_reference/standard/utime.html","title":"utime","keywords":"","body":"utime – 时间相关的功能 该模块实现了相应CPython模块的子集，如下所述。有关更多信息，请参阅原始CPython文档： time. utime模块提供获取当前时间和日期，测量时间间隔和延迟的功能。 时间纪元: Unix移植版本使用标准为1970-01-01 00:00:00 UTC的POSIX系统时代。但是，嵌入式移植版本使用的是2000-01-01 00:00:00 UTC的纪元。 维护实际日历日期/时间: 这需要实时时钟（RTC）。在具有底层OS（包括一些RTOS）的系统上，RTC可能是隐含的。设置和维护实际日历时间是OS / RTOS的责任，并且在MicroPython之外完成，它只使用OS API来查询日期/时间。在裸机移植上，系统时间依赖于machine.RTC（）对象。可以使用machine.RTC（）。datetime（tuple）函数设置当前日历时间，并通过以下方式维护： 通过备用电池（可能是特定电路板的附加可选组件）。 使用联网时间协议（需要由移植/用户设置）。 每次上电时由用户手动设置（许多电路板在硬复位时保持RTC时间，但有些可能需要在这种情况下再次设置）。 如果未使用系统/ MicroPython RTC维护实际日历时间，则低于此要求参考当前绝对时间的函数可能与预期不符。 函数 utime.localtime([secs]) 将自纪元（见上文）以秒为单位的时间转换为8元组，其中包含:(年，月，日，小时，分钟，秒，工作日，晚期）如果未提供秒数或无，则为当前时间来自RTC使用。 年份包括世纪（例如2014年）。 月是1-12 mday是1-31 小时是0-23 分钟是0-59 秒是0-59 周一至周日的工作日为0-6 yearday是1-366 utime.mktime() 这是本地时间的反函数。它的参数是一个完整的8元组，表示按当地时间表示的时间。它返回一个整数，它是自2000年1月1日以来的秒数。 utime.sleep(seconds) 睡眠给定的秒数。有些电路板可能会接受秒作为浮点数来休眠几秒钟。请注意，其他板可能不接受浮点参数，因为与它们的兼容性使用 sleep_ms() 和 sleep_us() 函数。 utime.sleep_ms(ms) 给定毫秒数的延迟应为正或0。 utime.sleep_us(us) 给定微秒数的延迟应为正或0。 utime.ticks_ms() 返回一个带有任意参考点的递增毫秒计数器，它在某个值之后回绕。 环绕值未明确公开，但我们将其称为TICKS_MAX以简化讨论。值的周期为TICKS_PERIOD = TICKS_MAX + 1. TICKS_PERIOD保证为2的幂，但在不同硬件的移植之间可能不同。相同的句点值用于所有ticks_ms（），ticks_us（），ticks_cpu（）函数（为简单起见）。因此，这些函数将返回范围[0 .. TICKS_MAX]中的值，包括总TICKS_PERIOD值。请注意，仅使用非负值。在大多数情况下，您应该将这些函数返回的值视为不透明。可用的唯一操作是ticks_diff（）和ticks_add（）函数，如下所述。 注意：直接对这些值执行标准数学运算（+， - ）或关系运算符（，> =）将导致无效结果。执行数学运算然后将其结果作为参数传递给ticks_diff（）或ticks_add（）也将导致后者函数的无效结果。 utime.ticks_us() 就像上面的'ticks_ms（）`一样，但是在几微秒内。 utime.ticks_cpu() 类似于ticks_ms（）和ticks_us（），但系统中的分辨率最高。这通常是CPU时钟，这就是函数以这种方式命名的原因。但它不必是CPU时钟，而是可以使用系统中可用的一些其他定时源（例如，高分辨率定时器）。在'utime`模块级别没有指定此函数的确切时间单位（分辨率），但特定硬件的文档可能提供更具体的信息。此功能用于非常精细的基准测试或非常紧凑的实时循环。避免在便携式代码中使用它。 utime.ticks_add(ticks, delta) 偏移值按给定数字计算，可以是正数也可以是负数。给定一个ticks值，该函数允许在tick值的模块算术定义之后或之后计算ticks值delta ticks（参见上面的ticks_ms（））。 ticks参数必须是调用ticks_ms（），ticks_us（）或ticks_cpu（）函数（或从之前调用ticks_add（））的直接结果。但是，delta可以是任意整数或数字表达式。 ticks_add（）对于计算事件/任务的截止日期非常有用。 （注意：你必须使用ticks_diff（）函数来处理截止日期。） 例子: # Find out what ticks value there was 100ms ago print(ticks_add(time.ticks_ms(), -100)) # Calculate deadline for operation and test for it deadline = ticks_add(time.ticks_ms(), 200) while ticks_diff(deadline, time.ticks_ms()) > 0: do_a_little_of_something() # Find out TICKS_MAX used by this port print(ticks_add(0, -1)) utime.ticks_diff(ticks1, ticks2) 测量从ticks_ms（），ticks_us（）或ticks_cpu（）函数返回的值之间的差异，作为可以回绕的有符号值。 参数顺序与减法运算符相同，ticks_diff（ticks1，ticks2）与ticks1 - ticks2具有相同的含义。但是，ticks_ms（）等函数返回的值可能会回绕，因此直接使用减法会产生不正确的结果。这就是为什么需要ticks_diff（），它实现模块化（或更具体地说，环）算术，即使对于环绕值也能产生正确的结果（只要它们之间不太远，见下文）。该函数返回范围为[-TICKS_PERIOD / 2 .. TICKS_PERIOD / 2-1]的有符号值（这是二进制补码有符号二进制整数的典型范围定义）。如果结果是否定的，则意味着ticks1在时间上早于ticks2。否则，这意味着ticks1发生在ticks2之后。如果ticks1和ticks2彼此分开不超过TICKS_PERIOD / 2-1滴答，则仅保留**。如果不成立，将返回不正确的结果。具体来说，如果两个刻度值相隔TICKS_PERIOD / 2-1刻度，则该值将由该函数返回。但是，如果实时滴答的TICKS_PERIOD / 2已在它们之间传递，则该函数将返回-TICKS_PERIOD / 2，即结果值将回绕到可能值的负范围。 上述限制的非正式理由：假设您被锁在一个房间内，除了标准的12档时钟外无法监控时间的流逝。然后，如果你现在看表盘，不再看13个小时（例如，如果你长时间睡觉），那么一旦你再看一遍，你可能觉得只有1个小时过去了。为了避免这个错误，请定期查看时钟。您的应用程序也应该这样做。 “太长时间睡眠”这个比喻也直接映射到应用程序行为：不要让你的应用程序运行任何单个任务太长时间。分步运行任务，并在两者之间进行计时。 ticks_diff() 旨在适应各种使用模式，其中包括： 超时轮询。在这种情况下，事件的顺序是已知的，你只会处理ticks_diff（）的正面结果： # Wait for GPIO pin to be asserted, but at most 500us start = time.ticks_us() while pin.value() == 0: if time.ticks_diff(time.ticks_us(), start) > 500: raise TimeoutError 调度事件。 在这种情况下，如果事件过期，则ticks_diff（）结果可能为负： # This code snippet is not optimized now = time.ticks_ms() scheduled_time = task.scheduled_time() if ticks_diff(scheduled_time, now) > 0: print(\"Too early, let's nap\") sleep_ms(ticks_diff(scheduled_time, now)) task.run() elif ticks_diff(scheduled_time, now) == 0: print(\"Right at time!\") task.run() elif ticks_diff(scheduled_time, now) 注意：不要将time（）值传递给ticks_diff（），你应该对它们使用常规的数学运算。但请注意，time（）可能（也会）溢出。这被称为https://en.wikipedia.org/wiki/Year_2038_problem . utime.time() 返回自纪元以来的整数秒数，假设如上所述设置和维护基础RTC。如果未设置 RTC，则此函数返回自特定硬件移植参考时间点以来的秒数（对于没有电池供电的 RTC 的嵌入式电路板，通常自上电或复位后）。如果要开发便携式 MicroPython 应用程序，则不应依赖此函数来提供高于第二的精度。如果你需要更高的精度，使用ticks_ms（）和ticks_us（）函数，如果你需要日历时间，localtime（）没有参数是一个更好的选择。 与CPython的区别 在 CPython 中，此函数返回自 Unix 纪元（1970-01-01 00:00 UTC）以来的秒数，作为浮点数，通常具有微秒精度。 使用 MicroPython，只有 Unix 移植版本使用相同的纪元，如果浮点精度允许，则返回亚秒精度。 嵌入式硬件通常没有浮点精度来表示长时间范围和亚秒精度，因此它们使用具有第二精度的整数值。 某些嵌入式硬件也缺少电池供电的 RTC，因此返回自上次上电或其他相对硬件特定点（例如复位）以来的秒数。 time.ticks() 等同于 time.ticks_ms time.clock() 获取 clock 对象 返回值 clock 对象 clock 对象 由 time.clock() 返回 clock.tick() 记录开始时间（ms）， 与clock.fps()搭配使用可以计算fps 返回值 None clock.fps() 根据上一个调用clock.tick()到现在的时间计算出帧率（fps） 比如： import sensor import time clock = time.clock() sensor.reset() sensor.set_pixformat(sensor.RGB565) sensor.set_framesize(sensor.QVGA) while True: clock.tick() sensor.snapshot() print(\"fps = \",clock.fps()) clock.reset() 重置所有标记 clock.avg() 根据上一个调用clock.tick()到现在的时间计算出每帧消耗的时间 powered by GitbookFile Modify: 2020-09-11 12:05:50 "},"api_reference/standard/uzlib.html":{"url":"api_reference/standard/uzlib.html","title":"uzlib","keywords":"","body":"uzlib — zlib 解压缩 该模块实现了相应CPython模块的子集，如下所述。有关更多信息，请参阅原始CPython文档：zlib。 该模块允许解压使用 DEFLATE 算法压缩的二进制数据（通常用于zlib库和gzip存档器）。 压缩尚未实现。 函数 decompress 解压 uzlib.decompress(data, wbits=0, bufsize=0) 参数 wbits： 压缩期间使用的 DEFLATE 字典窗口大小（8-15，字典大小是该值的2的幂）。 另外，如果值为正，则假定数据为 zlib 流（使用 zlib 头）。 否则，如果它是负数，则假定它是原始 DEFLATE 流。 bufsize： 参数用于与CPython兼容， 可忽略。 返回值 将解压缩的数据作为bytes类型返回。 DecompIO 创建一个流包装器，允许对另一个流中的压缩数据进行透明解压缩。 这允许处理具有大于可用堆大小的数据的压缩流。 除了decompress（）中描述的值之外，wbits可以取值 24..31（16+8..15），这意味着输入流具有gzip头。 class uzlib.DecompIO(stream, wbits=0) 与 CPython 的不同 这个类是MicroPython扩展。它包含在临时基础上，可能会在以后的版本中进行大量更改或删除。 powered by GitbookFile Modify: 2020-09-11 12:05:50 "},"api_reference/machine/":{"url":"api_reference/machine/","title":"machine","keywords":"","body":"machine machine 库主要包含了与硬件相关的各种接口，如下： I2C SPI Timer PWM UART 方法 unique_id() 获取唯一 ID 返回值 32 字节的唯一ID 方法 reset() 重启 powered by GitbookFile Modify: 2020-09-11 12:05:50 "},"api_reference/Maix/":{"url":"api_reference/Maix/","title":"Maix","keywords":"","body":"Maix库 FPIOA GPIO KPU FFT I2S Audio freq utils powered by GitbookFile Modify: 2020-09-11 12:05:50 "},"api_reference/Maix/kpu.html":{"url":"api_reference/Maix/kpu.html","title":"KPU","keywords":"","body":"KPU KPU是通用的神经网络处理器，它可以在低功耗的情况下实现卷积神经网络计算，时时获取被检测目标的大小、坐标和种类，对人脸或者物体进行检测和分类。 KPU 具备以下几个特点： 支持主流训练框架按照特定限制规则训练出来的定点化模型 对网络层数无直接限制，支持每层卷积神经网络参数单独配置，包括输入输出通道数目、输入输 出行宽列高 支持两种卷积内核 1x1 和 3x3 支持任意形式的激活函数 实时工作时最大支持神经网络参数大小为 5.5MiB 到 5.9MiB 非实时工作时最大支持网络参数大小为（Flash 容量-软件体积） 模块方法 加载模型 从flash或者文件系统中加载模型 import KPU as kpu task = kpu.load(offset or file_path) 参数 offtset: 模型在 flash 中的偏移大小，如 0xd00000 表示模型烧录在13M起始的地方 file_path: 模型在文件系统中为文件名， 如 “/sd/xxx.kmodel” 返回 kpu_net: kpu 网络对象 初始化yolo2网络 为yolo2网络模型传入初始化参数 import KPU as kpu task = kpu.load(offset or file_path) anchor = (1.889, 2.5245, 2.9465, 3.94056, 3.99987, 5.3658, 5.155437, 6.92275, 6.718375, 9.01025) kpu.init_yolo2(task, 0.5, 0.3, 5, anchor) 参数 kpu_net: kpu 网络对象 threshold: 概率阈值 nms_value: box_iou 门限 anchor_num: 锚点数 anchor: 锚点参数与模型参数一致 反初始化 import KPU as kpu task = kpu.load(offset or file_path) kpu.deinit(task) 参数 kpu_net: kpu_load 返回的 kpu_net 对象 运行yolo2网络 import KPU as kpu import image task = kpu.load(offset or file_path) anchor = (1.889, 2.5245, 2.9465, 3.94056, 3.99987, 5.3658, 5.155437, 6.92275, 6.718375, 9.01025) kpu.init_yolo2(task, 0.5, 0.3, 5, anchor) img = image.Image() kpu.run_yolo2(task, img) #此处不对，请参考例程 参数 kpu_net: kpu_load 返回的 kpu_net 对象 image_t：从 sensor 采集到的图像 返回 list: kpu_yolo2_find 的列表 网络前向运算(forward) 计算已加载的网络模型到指定层数，输出目标层的特征图 import KPU as kpu task = kpu.load(offset or file_path) …… fmap=kpu.forward(task,img,3) 参数 kpu_net: kpu_net 对象 image_t: 从 sensor 采集到的图像 int: 指定计算到网络的第几层 返回 fmap: 特征图对象，内含当前层所有通道的特征图 fmap 特征图 取特征图的指定通道数据到image对象 img=kpu.fmap(fmap,1) 参数 fmap: 特征图 对象 int: 指定特征图的通道号 返回 img_t: 特征图对应通道生成的灰度图 fmap_free 释放特征图 释放特征图对象 kpu.fmap_free(fmap) 参数 fmap: 特征图 对象 返回 无 netinfo 获取模型的网络结构信息 info=kpu.netinfo(task) layer0=info[0] 参数 kpu_net: kpu_net 对象 返回 netinfo list：所有层的信息list, 包含信息为：index：当前层在网络中的层数 wi：输入宽度 hi：输入高度 wo：输出宽度 ho：输出高度 chi：输入通道数 cho：输出通道数 dw：是否为depth wise layer kernel_type：卷积核类型，0为1x1， 1为3x3 pool_type：池化类型，0不池化; 1：2x2 max pooling; 2:... para_size：当前层的卷积参数字节数 例程 运行人脸识别demo 模型下载地址：http://dl.sipeed.com/MAIX/MaixPy/model/face_model_at_0x300000.kfpkg import sensor import image import lcd import KPU as kpu lcd.init() sensor.reset() sensor.set_pixformat(sensor.RGB565) sensor.set_framesize(sensor.QVGA) sensor.run(1) task = kpu.load(0x300000) #使用kfpkg将 kmodel 与 maixpy 固件打包下载到 flash anchor = (1.889, 2.5245, 2.9465, 3.94056, 3.99987, 5.3658, 5.155437, 6.92275, 6.718375, 9.01025) a = kpu.init_yolo2(task, 0.5, 0.3, 5, anchor) while(True): img = sensor.snapshot() code = kpu.run_yolo2(task, img) if code: for i in code: print(i) a = img.draw_rectangle(i.rect()) a = lcd.display(img) a = kpu.deinit(task) 运行特征图 模型下载地址：http://dl.sipeed.com/MAIX/MaixPy/model/face_model_at_0x300000.kfpkg 该模型是8bit定点模型，约380KB大小，层信息为： 1 2 :160x120 3 4 5 6 :80x60 7 8 9 10 :40x30 11~16 :20x15 import sensor import image import lcd import KPU as kpu index=3 lcd.init() sensor.reset() sensor.set_pixformat(sensor.RGB565) sensor.set_framesize(sensor.QVGA) sensor.run(1) task=kpu.load(0x300000) img=image.Image() info=kpu.netinfo(task) layer=info[index] w=layer.wo() h=layer.ho() num=int(320*240/w/h) list=[None]*num x_step=int(320/w) y_step=int(240/h) img_lcd=image.Image() while True: img=sensor.snapshot() fmap=kpu.forward(task,img,index) for i in range(0,num): list[i]=kpu.fmap(fmap,i) for i in range(0,num): list[i].stretch(64,255) for i in range(0,num): a=img_lcd.draw_image(list[i],((i%x_step)*w,(int(i/x_step))*h)) lcd.display(img_lcd) kpu.fmap_free(fmap) powered by GitbookFile Modify: 2020-09-11 12:05:50 "},"api_reference/Maix/fft.html":{"url":"api_reference/Maix/fft.html","title":"FFT","keywords":"","body":"FFT运算 FFT快速傅里叶变换模块，对输入数据进行傅里叶变换并返回相应的频率幅值, FFT快速傅里叶运算可以将时域信号转换为频域信号 模块函数 运算函数 输入时域数据并进行傅里叶变换 import FFT res = FFT.run(data, points, shift) 参数 data: 输入的时域数据，bytearray 类型 points: FFT运算点数，仅支持64, 128，256和512点 shift: 偏移，默认为0 返回值 res: 返回计算后的频域数据，以 list 类型呈现，该列表有 points 个元组，每个元组有 2 个元素，第一个元素为实部，第二个为虚部 频率函数 FFT res = FFT.freq(points, sample_rate) 参数 points: 计算点数 sample_rate: 采样率 返回值 res : 返回一个列表，该列表存放的进行运算后后所有频率点的频率值 幅值函数 用于计算 FFT 运算后的各个频率点的幅值，目前用作测试，用户可以自己在python自行写幅值处理函数 amp = FFT.amplitude(FFT_res) 参数 FFT_res: 函数 run 运行后的结果 返回值 res : 返回一个列表，该列表存放了各个频率点的幅值 例程 采集声音并进行FFT运算，将运算后的数据在屏幕上显示为柱状图 例示代码： https://github.com/sipeed/MaixPy_scripts/blob/master/hardware/demo_fft_spectrum.py powered by GitbookFile Modify: 2020-09-11 12:05:50 "},"api_reference/Maix/utils.html":{"url":"api_reference/Maix/utils.html","title":"utils","keywords":"","body":"Maix.utils gc_heap_size([size]) 获取或者设置 GC 堆大小，如果报内存不够时可以考虑设置大一点 参数 无 或者 传入新的 GC 堆大小. 如果没有参数就只是获取堆大小； 如果有参数则设置堆大小，然后会自动重启 返回值 GC 堆大小 powered by GitbookFile Modify: 2020-09-11 12:05:50 "},"api_reference/builtin_py/":{"url":"api_reference/builtin_py/","title":"内置类","keywords":"","body":"内置类 内置类 库是对MaixPy底层的类进行封装的用户层接口，方便用户使用MaixPy，它包括以下： fpioa_manager board_info 需要注意的是， 这些类在开机启动的时候在 _boot.py 里面已经被导入了， 所以在串口终端可以直接使用， 但是， 如果是执行文件， 则需要手动写代码导入， 否则找不到类 from board import board_info from fpioa_manager import fm 或者 只导入 from fpioa_manager import fm, board_info powered by GitbookFile Modify: 2020-09-11 12:05:50 "},"api_reference/builtin_py/fm.html":{"url":"api_reference/builtin_py/fm.html","title":"fpioa_manager","keywords":"","body":"fpioa_manager fpioa_manager：简称fm，该模块用于注册芯片内部功能和引脚，帮助用户管理内部功能和引脚 fm 实际上是使用 Fpioa_Manager 类定义的一个对象， 使用 Micropython 编写并集成带固件中， 源码看 fpioa_manager.py 方法 注册函数 注册引脚和功能 fm.register(pin,function，[force=True]) 参数 该方法必须传入至少2个参数，不然将返回空值 pin: 功能映射引脚 function : 芯片功能 force: 强制分配，如果为True，则可以多次对同一个引脚注册;False则不允许同一引脚多次注册。默认为True是为了方便IDE多次运行程序使用 返回值 该方法具有2个返回值， 设置成功返回 1 设置失败返回 reg_pin,reg_func，表示的是已经被注册的引脚和功能 注销函数 注销引脚和功能 fm.unregister(pin,function) 参数 该方法可以传入1或2个参数，当传入1个参数时，需要添加参数关键字。如果为1个参数，其引脚和功能都将被注销 pin: 功能映射引脚 function : 芯片功能 返回值 设置成功返回 pin,function，表示被注销的引脚和功能 设置失败返回 0 例程 from fpioa_manager import fm, board_info fm.register(board_info.WIFI_RX,fm.fpioa.UART2_TX) fm.register(board_info.WIFI_RX,fm.fpioa.UART2_TX)#再注册一次 fm.register(board_info.WIFI_RX,fm.fpioa.SPI0_SS0, force=False)#注册同个引脚 fm.register(board_info.WIFI_RX,fm.fpioa.SPI0_SS0, force=False)#注册同个功能 fm.unregister(board_info.WIFI_RX,fm.fpioa.UART2_TX)#注销功能和引脚 fm.register(board_info.WIFI_RX,fm.fpioa.UART2_TX) fm.unregister(function = fm.fpioa.UART2_TX)#注销功能 fm.register(board_info.WIFI_RX,fm.fpioa.UART2_TX) fm.unregister(pin = board_info.WIFI_RX)#注销引脚 附录 以下引脚已经在 MaxiPy 开机启动时注册，请注意 SD卡 功能：SPI1_SCLK/SPI1_D0/SPI1_D1/GPIOHS29/SPI0_SS1 引脚：PIN25/PIN26/PIN27/PIN28/PIN29 LCD 功能：SPI0_SS3/SPI0_SCLK/GPIOHS30/GPIOHS31 引脚：PIN36/PIN37/PIN38/PIN39 sensor 功能：SCCB_SDA/SCCB_SCLK/CMOS_RST/CMOS_VSYNC/CMOS_PWDN/CMOS_HREF/CMOS_XCLK/CMOS_PCLK 引脚：PIN40/PIN41/PIN42/PIN43/PIN44/PIN45/PIN46/PIN47 REPL 功能：UARTHS_RX/UARTHS_TX 引脚：PIN4/PIN5 powered by GitbookFile Modify: 2020-09-11 12:05:50 "},"api_reference/builtin_py/board_info.html":{"url":"api_reference/builtin_py/board_info.html","title":"board_info","keywords":"","body":"board_info board_info：主要用于方便用户使用开发板引脚配置，其中内置了对人友好的命名及接口，可以使用户减少对电器连接原理图的依赖。 board_info 是内部定义的一个 Board_Info 全局变量， 使用 MicroPython 语法编写， 源码见 board.py 成员 board_info拥有许多个引脚索引和一个列表 pin_name列表 列表主要是用于类内部使用，用户不对其进行操作 引脚索引 引脚索引主要是将数字转换为人类友好的字符串，让用户方便编程 输入以下，请注意不要忽略 . 号，然后按下 tab键 进行补全，可以看到板级相关的引脚功能 board_info. 比如输入以下代码，将返回数字 8，代表的是开发板的第8号引脚，其电器连接是wifi模块的使能引脚 board_info.WIFI_EN 方法 查找方法 当用户不清楚引脚电器连接时，可以使用该方法查找 board_info.pin_map(pin_num) 参数 该方法不传入参数或者传入一个参数 pin_num: 引脚编号，范围[6,47] 当不传入参数时，将打印所有引脚的板级电气连接信息 传入参数时，仅打印指定引脚的板级电气连接信息 返回值 参数错误返回 False 未知错误返回 False 查找成功返回 信息 例程 例程 1 from board import board_info wifi_en_pin = board_info.WIFI_EN print(wifi_en_pin)#输出为8 board_info.pin_map()#打印所有 board_info.pin_map(8)#只打印8号引脚的信息 powered by GitbookFile Modify: 2020-09-11 12:05:50 "},"api_reference/machine_vision/":{"url":"api_reference/machine_vision/","title":"机器视觉","keywords":"","body":"机器视觉 主要包含了了与图像、显示相关的类，包括： lcd sensor image powered by GitbookFile Modify: 2020-09-11 12:05:50 "},"api_reference/machine_vision/image.html":{"url":"api_reference/machine_vision/image.html","title":"image","keywords":"","body":"image — 机器视觉 移植于 openmv， 与 openmv 功能相同 例程 例程 1： 找绿色 import sensor import image import lcd import time lcd.init() sensor.reset() sensor.set_pixformat(sensor.RGB565) sensor.set_framesize(sensor.QVGA) sensor.run(1) green_threshold = (0, 80, -70, -10, -0, 30) while True: img=sensor.snapshot() blobs = img.find_blobs([green_threshold]) if blobs: for b in blobs: tmp=img.draw_rectangle(b[0:4]) tmp=img.draw_cross(b[5], b[6]) c=img.get_pixel(b[5], b[6]) lcd.display(img) 例程 2： 显示 fps import sensor import image import lcd import time clock = time.clock() lcd.init() sensor.reset() sensor.set_pixformat(sensor.RGB565) sensor.set_framesize(sensor.QVGA) sensor.run(1) sensor.skip_frames(30) while True: clock.tick() img = sensor.snapshot() fps =clock.fps() img.draw_string(2,2, (\"%2.1ffps\" %(fps)), color=(0,128,0), scale=2) lcd.display(img) 例程 3： 扫描二维码 import sensor import image import lcd import time clock = time.clock() lcd.init() sensor.reset() sensor.set_pixformat(sensor.RGB565) sensor.set_framesize(sensor.QVGA) sensor.set_vflip(1) sensor.run(1) sensor.skip_frames(30) while True: clock.tick() img = sensor.snapshot() res = img.find_qrcodes() fps =clock.fps() if len(res) > 0: img.draw_string(2,2, res[0].payload(), color=(0,128,0), scale=2) print(res[0].payload()) lcd.display(img) 如果使用了镜头，画面会有扭曲，需要矫正画面 使用 lens_corr 函数来矫正， 比如 2.8mm， img.lens_corr(1.8) 函数 函数还可以在本页按 Ctrl+F 使用浏览器的搜索功能搜 image. 来标记函数 image.rgb_to_lab(rgb_tuple) 返回RGB888格式的元组 rgb_tuple (r, g, b)对应的LAB格式的元组(l, a, b)。 RGB888是指红、绿、蓝各8位（0-255）。在LAB中，L的取值范围为0-100，a/b 的取值范围为-128到127。 image.lab_to_rgb(lab_tuple) 返回LAB格式的元组 lab_tuple (l, a, b)对应的RGB888格式的元组(r, g, b)。 RGB888是指红、绿、蓝各8位（0-255）。在LAB中，L的取值范围为0-100，a/b 的取值范围为-128到127。 image.rgb_to_grayscale(rgb_tuple) 返回RGB888格式的元组 rgb_tuple (r, g, b)对应的灰度值。 RGB888是指红、绿、蓝各8位（0-255）。灰度值取值于0-255。 image.grayscale_to_rgb(g_value) 返回灰度值 g_value 对应的RGB888格式的元组(r, g, b)。 RGB888是指红、绿、蓝各8位（0-255）。灰度值取值于0-255。 image.load_decriptor(path) 从磁盘上加载一个描述符对象(descriptor object). path 是描述符文件保存的路径。 image.save_descriptor(path, descriptor) 保存描述符对象 descriptor 到磁盘。 path 是描述符文件保存的路径。 image.match_descriptor(descritor0, descriptor1[, threshold=70[, filter_outliers=False]]) 对于LBP描述符来说，这个函数返回的是一个体现两个描述符之间区别的整数。这一距离测度尤为必要。这个距离是对相似度的一个度量。这个测度值越接近0，LBPF特征点匹配得就越好。 对于ORB描述符来说，这个函数返回的是kptmatch对象。见上。 threshold 是用来为ORB键点过滤不明确匹配服务的。 一个较低的 threshold 值将紧扣关键点匹配算法。 threshold 值位于0-100 (int)。默认值为70。 filter_outliers 是用来为ORB键点过滤异常值服务的。 特征点允许用户提高 threshold 值。默认设置为False。 HaarCascade 类 – 特征描述符 Haar Cascade特征描述符用于 image.find_features() 方法。它没有供用户调用的方法。 构造函数 class image.HaarCascade(path[, stages=Auto]) 从一个Haar Cascade二进制文件\b（适合OpenMV Cam\b的格式）加载一个Haar Cascade。 如果您传递“frontalface”字符串 而非一条路径，这个构造函数将会把一个内置的正脸Haar Cascade载入内存。 此外，您也可以通过“eye”来把Haar Cascade载入内存。 最后，这个方法会返回载入的Haar Cascade对象，用来使用 image.find_features() 。 stages 默认值为Haar Cascade中的阶段数。然而，您可以指定一个较低的数值来加速运行特征检测器，当然这会带来较高的误报率。 您可以制作自己的Haar Cascades 来配合您的OpenMV Cam 使用。 首先，使用谷歌搜索“ Haar Cascade”，检测是否有人已经为您想要检测的对象制作了OpenCV Haar Cascade。 如果没有，那您需要自己动手制作（工作量巨大）。 关于如何制作自己的Haar Cascade，见此 关于如何把OpenCV Haar Cascades转化成您的OpenMV Cam可以读取的模式， 见此script 问：Haar Cascade 是什么？ 答：Haar Cascade是一系列用来确定一个对象是否存在于图像中的对比检查。 这一系列的对比检查分成了多个阶段，后一阶段的运行以先前阶段的完成为前提。 对比检查并不复杂，不过是像检查图像的中心垂直是否比边缘更轻微之类的过程。 大范围的检查在前期阶段首先进行，在后期进行更多更小的区域检查。 问：Haar Cascades 是如何制作而成的？ 答：Haar Cascades通过标有正负的图像对发生器算法进行训练。 比如，用数百张含有猫（已被标记为内含猫）的图片和数百张不含有猫形物的图片（已作出不同标记）来训练这个生成算法。 \b\b这个生成算法\b最后会产生一个用来检测猫的Haar Cascades。 Similarity 类 – 相似度对象 相似度对象由 image.get_similarity 返回. 构造函数 class image.similarity 请调用 image.get_similarity() 函数来创建此对象。 方法 similarity.mean() 返回8x8像素块结构相似性差异的均值。范围[-1/+1]，其中 -1完全不同，+1完全相同。 您也可以通过索引 [0] 取得这个值。 similarity.stdev() 返回8x8像素块结构相似性差异的标准偏差。 您也可以通过索引 [1] 取得这个值。 similarity.min() 返回8x8像素块结构相似性差异的最小值。其中 -1完全不同，+1完全相同。 您也可以通过索引 [2] 取得这个值。 通过查看此值，您可以快速确定两个图像之间的任何8x8像素块是否差别很大，即远远低于+1。 similarity.max() 返回8x8像素块结构相似性差异的最小值。其中 -1完全不同，+1完全相同。 您也可以通过索引 [3] 取得这个值。 通过查看此值，您可以快速确定两个图像之间的任何8x8像素块是否都相同。即比-1大很多。 Histogram 类 – 直方图对象 直方图对象是由 image.get_histogram 返回。 灰度直方图有一个包含多个二进制的通道。 所有二进制都进行标准化，使其总和为1。 RGB565有三个包含多个二进制的通道。所有二进制都进行标准化，使其总和为1。 构造函数 class image.histogram 请调用 image.get_histogram() 函数来创建此对象。 方法 histogram.bins() 返回灰度直方图的浮点数列表。 您也可以通过索引 [0] 取得这个值。 histogram.l_bins() 返回RGB565直方图LAB的L通道的浮点数列表。 您也可以通过索引 [0] 取得这个值。 histogram.a_bins() 返回RGB565直方图LAB的A通道的浮点数列表。 您也可以通过索引 [1] 取得这个值。 histogram.b_bins() 返回RGB565直方图LAB的B通道的浮点数列表。 您也可以通过索引 [2] 取得这个值。 histogram.get_percentile(percentile) 计算直方图频道的CDF，返回一个传递 percentile (0.0 - 1.0) (浮点数)中的直方图的值。 因此，若您传入0.1，该方法会告知您，当累加入累加器时，哪一个二进制会使累加器跨过0.1。 在没有异常效用破坏您的自适应色跟踪结果时，这对于确定颜色分布的最小值(0.1)和max(0.9)甚是有效。 histogram.get_threhsold() 使用Otsu’s 方法计算最佳阈值，将直方图分的每个通道为两半。 该方法返回一个 image.threshold 对象。 这个方法对确定最佳的 image.binary() 阈值特别有用。 histogram.get_statistics() 计算直方图中每个颜色通道的平均值、中值、众值、标准差、最小值、最大值、下四分值和上四分值， 并返回一个statistics对象。 您也可以使用 histogram.statistics() 和 histogram.get_stats() 作为这个方法的别名。 Percentile 类 – 百分比\b值对象 百分比值对象由 histogram.get_percentile 返回。 灰度百分比值有一个通道。不使用 l* 、 a 或 b_ 方法。 RGB565百分比值有三个通道。使用 l* 、 a 和 b_ 方法。 构造函数 class image.percentile 请调用 histogram.get_percentile() 函数来创建此对象。 方法 percentile.value() 返回灰度百分比值（取值区间为0-255）。 您也可以通过索引 [0] 取得这个值。 percentile.l_value() 返回RGB565 LAB 的L通道的百分比值（取值区间为0-100）。 您也可以通过索引 [0] 取得这个值。 percentile.a_value() 返回RGB565 LAB 的A通道的百分比值（取值区间为-128-127）。 您也可以通过索引 [1] 取得这个值。 percentile.b_value() 返回RGB565 LAB 的B通道的百分比值（取值区间为-128-127）。 您也可以通过索引 [2] 取得这个值。 Threhsold 类 – 阈值对象 阈值对象由 histogram.get_threshold 返回。 灰度图像有一个通道。没有 l*, a, 和 b_ 方法. RGB565 阈值有三个通道。使用 l*, a, 和 b_ 方法。 构造函数 class image.threshold 请调用 histogram.get_threshold() 函数来创建此对象。 方法 threhsold.value() 返回灰度图的阈值 (between 0 and 255)。 您也可以通过索引 [0] 取得这个值。 threhsold.l_value() 返回RGB565图LAB中的L阈值 (between 0 and 100). 您也可以通过索引 [0] 取得这个值。 threhsold.a_value() 返回RGB565图LAB中的A阈值 (between -128 and 127). 您也可以通过索引 [1] 取得这个值。 threhsold.b_value() 返回RGB565图LAB中的B阈值 (between -128 and 127). 您也可以通过索引 [2] 取得这个值。 class Statistics – 统计数据对象 统计数据对象是由 histogram.get_statistics 或 image.get_statistics 返回的。 灰度统计数据有一个通道，使用非 l* 、 a 或 b_ 方法。 RGB565百分比值有三个通道。使用 l* 、 a 和 b_ 方法。 构造函数 class image.statistics 请调用 histogram.get_statistics() 或 image.get_statistics() 函数来创建此对象。 方法 statistics.mean() 返回灰度均值(0-255) (int)。 您也可以通过索引 [0] 取得这个值。 statistics.median() 返回灰度中值(0-255) (int)。 您也可以通过索引 [1] 取得这个值。 statistics.mode() 返回灰度众值(0-255) (int)。 您也可以通过索引 [2] 取得这个值。 statistics.stdev() 返回灰度标准差(0-255) (int)。 您也可以通过索引 [3] 取得这个值。 statistics.min() 返回灰度最小值(0-255) (int)。 您也可以通过索引 [4] 取得这个值。 statistics.max() 返回灰度最大值(0-255) (int)。 您也可以通过索引 [5] 取得这个值。 statistics.lq() 返回灰度下四分值(0-255) (int)。 您也可以通过索引 [6] 取得这个值。 statistics.uq() 返回灰度上四分值(0-255) (int)。 您也可以通过索引 [7] 取得这个值。 statistics.l_mean() 返回RGB5656 LAB 中L的均值(0-255) (int)。 您也可以通过索引 [0] 取得这个值。 statistics.l_median() 返回RGB5656 LAB 中L的中值(0-255) (int)。 您也可以通过索引 [1] 取得这个值。 statistics.l_mode() 返回RGB5656 LAB 中L的众值(0-255) (int)。 您也可以通过索引 [2] 取得这个值。 statistics.l_stdev() 返回RGB5656 LAB 中L的标准偏差值(0-255) (int)。 您也可以通过索引 [3] 取得这个值。 statistics.l_min() 返回RGB5656 LAB 中L的最小值(0-255) (int)。 您也可以通过索引 [4] 取得这个值。 statistics.l_max() 返回RGB5656 LAB 中L的最大值(0-255) (int)。 您也可以通过索引 [5] 取得这个值。 statistics.l_lq() 返回RGB5656 LAB 中L的下四分值(0-255) (int)。 您也可以通过索引 [6] 取得这个值。 statistics.l_uq() 返回RGB5656 LAB 中L的上四分值(0-255) (int)。 您也可以通过索引 [7] 取得这个值。 statistics.a_mean() 返回RGB5656 LAB 中A的均值(0-255) (int)。 您也可以通过索引 [8] 取得这个值。 statistics.a_median() 返回RGB5656 LAB 中A的中值(0-255) (int)。 您也可以通过索引 [9] 取得这个值。 statistics.a_mode() 返回RGB5656 LAB 中A的众值(0-255) (int)。 您也可以通过索引 [10] 取得这个值。 statistics.a_stdev() 返回RGB5656 LAB 中A的标准偏差值(0-255) (int)。 您也可以通过索引 [11] 取得这个值。 statistics.a_min() 返回RGB5656 LAB 中A的最小值(0-255) (int)。 您也可以通过索引 [12] 取得这个值。 statistics.a_max() 返回RGB5656 LAB 中A的最大值(0-255) (int)。 您也可以通过索引 [13] 取得这个值。 statistics.a_lq() 返回RGB5656 LAB 中A的下四分值(0-255) (int)。 您也可以通过索引 [14] 取得这个值。 statistics.a_uq() 返回RGB5656 LAB 中A的上四分值(0-255) (int)。 您也可以通过索引 [15] 取得这个值。 statistics.b_mean() 返回RGB5656 LAB 中B的均值(0-255) (int)。 您也可以通过索引 [16] 取得这个值。 statistics.b_median() 返回RGB5656 LAB 中B的中值(0-255) (int)。 您也可以通过索引 [17] 取得这个值。 statistics.b_mode() 返回RGB5656 LAB 中B的众值(0-255) (int)。 您也可以通过索引 [18] 取得这个值。 statistics.b_stdev() 返回RGB5656 LAB 中B的标准差值(0-255) (int)。 您也可以通过索引 [19] 取得这个值。 statistics.b_min() 返回RGB5656 LAB 中B的最小值(0-255) (int)。 您也可以通过索引 [20] 取得这个值。 statistics.b_max() 返回RGB5656 LAB 中B的最大值(0-255) (int)。 您也可以通过索引 [21] 取得这个值。 statistics.b_lq() 返回RGB5656 LAB 中B的下四分值(0-255) (int)。 您也可以通过索引 [22] 取得这个值。 statistics.b_uq() 返回RGB5656 LAB 中B的上四分值(0-255) (int)。 您也可以通过索引 [23] 取得这个值。 Blob 类 – 色块对象 色块对象是由 image.find_blobs 返回的。 构造函数 class image.blob 请调用 image.find_blobs() 函数来创建此对象。 方法 blob.rect() 返回一个矩形元组(x, y, w, h) ，用于如色块边界框的 image.draw_rectangle 等 其他的 image 方法。 blob.x() 返回色块的边界框的x坐标(int)。 您也可以通过索引 [0] 取得这个值。 blob.y() 返回色块的边界框的y坐标(int)。 您也可以通过索引 [1] 取得这个值。 blob.w() 返回色块的边界框的w坐标(int)。 您也可以通过索引 [2] 取得这个值。 blob.h() 返回色块的边界框的h坐标(int)。 您也可以通过索引 [3] 取得这个值。 blob.pixels() 返回从属于色块(int)一部分的像素数量。 您也可以通过索引 [4] 取得这个值。 blob.cx() 返回色块(int)的中心x位置。 您也可以通过索引 [5] 取得这个值。 blob.cy() 返回色块(int)的中心x位置。 您也可以通过索引 [6] 取得这个值。 blob.rotation() 返回色块的旋转（单位：弧度）。如果色块类似铅笔或钢笔，那么这个值就是介于0-180之间的唯一值。 如果这个色块圆的，那么这个值就没有效用。如果这个色块完全不具有对称性，您只能由此得到0-360度的旋转。 您也可以通过索引 [7] 取得这个值。 blob.code() 返回一个16位的二进制数字，其中为每个颜色阈值设置一个位，这是色块的一部分。 例如，如果您通过 image.find_blobs 来寻找三个颜色阈值，这个色块可以设置为0/1/2位。 注意：除非以 merge=True 调用 image.find_blobs ，否则每个色块只能设置一位。 那么颜色阈值不同的多个色块就可以合并在一起了。 您也可以用这个方法以及多个阈值来实现颜色代码跟踪。 您也可以通过索引 [8] 取得这个值。 blob.count() 返回合并为这一色块的多个色块的数量。只有您以 merge=True 调用 image.find_blobs 时，这个数字才不是1。 您也可以通过索引 [9] 取得这个值。 blob.area() 返回色块周围的边框面积(w * h) blob.density() 返回这个色块的密度比。这是在色块边界框区域内的像素点的数量。 总的来说，较低的密度比意味着这个对象的锁定得不是很好。 Line类 – 直线对象 直线对象是由 image.find_lines , image.find_line_segments 或 image.get_regression 返回的。 构造函数 class image.line 请调用 image.find_lines(), image.find_line_segments(), 或 image.get_regression() 函数来创建此对象。 方法 line.line() 返回一个直线元组(x1, y1, x2, y2) ，用于如 image.draw_line 等其他的 image 方法。 line.x1() 返回直线的p1顶点 x坐标分量。 您也可以通过索引 [0] 取得这个值。 line.y1() 返回直线的p1 y分量。 您也可以通过索引 [1] 取得这个值。 line.x2() 返回直线的p2 x分量。 您也可以通过索引 [2] 取得这个值。 line.y2() 返回直线的p2 y分量。 您也可以通过索引 [3] 取得这个值。 line.length() 返回直线长度即 sqrt(((x2-x1)^2) + ((y2-y1)^2). 您也可以通过索引 [4] 取得这个值。 line.magnitude() 返回霍夫变换后的直线的长度。 您也可以通过索引 [5] 取得这个值。 line.theta() 返回霍夫变换后的直线的角度（0-179度）。 您也可以通过索引 [7] 取得这个值。 line.rho() 返回霍夫变换后的直线p值。 您也可以通过索引 [8] 取得这个值。 Circle类 –圆形对象 圆形对象是由 image.find_circles 返回的。 构造函数 class image.circle 请调用 image.find_circles() 函数来创建此对象。 方法 circle.x() 返回圆的x位置。 您也可以通过索引 [0] 取得这个值。 circle.y() 返回圆的y位置。 您也可以通过索引 [1] 取得这个值。 circle.r() 返回圆的半径。 您也可以通过索引 [2] 取得这个值。 circle.magnitude() 返回圆的大小。 您也可以通过索引 [3] 取得这个值。 Rect类 – 矩形对象 矩形对象是由 image.find_rects 返回的。 构造函数 class image.rect 请调用 image.find_rects() 函数来创建此对象。 方法 rect.corners() 返回一个由矩形对象的四个角组成的四个元组(x,y)的列表。四个角通常是按照从左上角开始沿顺时针顺序返回的。 rect.rect() 返回一个矩形元组(x, y, w, h)，用于如 矩形的边界框的 image.draw_rectangle 等其他的 image 方法。 rect.x() 返回矩形的左上角的x位置。 您也可以通过索引 [0] 取得这个值。 rect.y() 返回矩形的左上角的y位置。 您也可以通过索引 [1] 取得这个值。 rect.w() 返回矩形的宽度。 您也可以通过索引 [2] 取得这个值。 rect.h() 返回矩形的高度。 您也可以通过索引 [3] 取得这个值。 rect.magnitude() 返回矩形的大小。 您也可以通过索引 [4] 取得这个值。 QRCode类 – 二维码对象 二维码对象是由 image.find_qrcodes 返回的。 构造函数 class image.qrcode 请调用 image.find_qrcodes() 函数来创建此对象。 方法 qrcode.corners() 返回一个由该对象的四个角组成的四个元组(x,y)的列表。四个角通常是按照从左上角开始沿顺时针顺序返回的。 qrcode.rect() 返回一个矩形元组(x, y, w, h)，用于如二维码的边界框的 image.draw_rectangle 等其他的 image 方法。 qrcode.x() 返回二维码的边界框的x坐标(int)。 您也可以通过索引 [0] 取得这个值。 qrcode.y() 返回二维码的边界框的y坐标(int)。 您也可以通过索引 [1] 取得这个值。 qrcode.w() 返回二维码的边界框的w坐标(int)。 您也可以通过索引 [2] 取得这个值。 qrcode.h() 返回二维码的边界框的h坐标(int)。 您也可以通过索引 [3] 取得这个值。 qrcode.payload() 返回二维码有效载荷的字符串，例如URL 。 您也可以通过索引 [4] 取得这个值。 qrcode.version() 返回二维码的版本号(int)。 您也可以通过索引 [5] 取得这个值。 qrcode.ecc_level() 返回二维码的ECC水平(int)。 您也可以通过索引 [6] 取得这个值。 qrcode.mask() 返回二维码的掩码(int)。 您也可以通过索引 [7] 取得这个值。 qrcode.data_type() 返回二维码的数据类型。 您也可以通过索引 [8] 取得这个值。 qrcode.eci() 返回二维码的ECI。ECI储存了QR码中存储数据字节的编码。若您想要处理包含超过标准ASCII文本的二维码，您需要查看这一数值。 您也可以通过索引 [9] 取得这个值。 qrcode.is_numeric() 若二维码的数据类型为数字式，则返回True。 qrcode.is_alphanumeric() 若二维码的数据类型为文字数字式，则返回True。 qrcode.is_binary() 若二维码的数据类型为二进制式，则返回True。如果您认真处理所有类型的文本，则需要检查eci是否为True，以确定数据的文本编码。通常它只是标准的ASCII，但是它也可能是有两个字节字符的UTF8。 qrcode.is_kanji() 若二维码的数据类型为日本汉字，则返回True。设置为True后，您就需要自行解码字符串，因为日本汉字符号每个字符是10位，而MicroPython不支持解析这类文本。 AprilTag类 – AprilTag对象 AprilTag对象是由 image.find_apriltags 返回的。 构造函数 class image.apriltag 请调用 image.find_apriltags() 函数来创建此对象。 方法 apriltag.corners() 返回一个由该对象的四个角组成的四个元组(x,y)的列表。四个角通常是按照从左上角开始沿顺时针顺序返回的。 apriltag.rect() 返回一个矩形元组(x, y, w, h)，用于如AprilTag边界框的 image.draw_rectangle 等其他的 image 方法。 apriltag.x() 返回AprilTag边界框的x坐标(int)。 您也可以通过索引 [0] 取得这个值。 apriltag.y() 返回AprilTag边界框的y坐标(int)。 您也可以通过索引 [1] 取得这个值。 apriltag.w() 返回AprilTag边界框的w坐标(int)。 您也可以通过索引 [2] 取得这个值。 apriltag.h() 返回AprilTag边界框的h坐标(int)。 您也可以通过索引 [3] 取得这个值。 apriltag.id() 返回AprilTag的数字ID。 TAG16H5 -> 0 to 29 TAG25H7 -> 0 to 241 TAG25H9 -> 0 to 34 TAG36H10 -> 0 to 2319 TAG36H11 -> 0 to 586 ARTOOLKIT -> 0 to 511 您也可以通过索引 [4] 取得这个值。 apriltag.family() 返回AprilTag的数字家庭。 image.TAG16H5 image.TAG25H7 image.TAG25H9 image.TAG36H10 image.TAG36H11 image.ARTOOLKIT 您也可以通过索引 [5] 取得这个值。 apriltag.cx() 返回AprilTag的中心x位置(int)。 您也可以通过索引 [6] 取得这个值。 apriltag.cy() 返回AprilTag的中心y位置(int)。 您也可以通过索引 [7] 取得这个值。 apriltag.rotation() 返回以弧度计的AprilTag的旋度(int)。 您也可以通过索引 [8] 取得这个值。 apriltag.decision_margin() 返回AprilTag匹配的色饱和度（取值0.0 - 1.0），其中1.0为最佳。 您也可以通过索引 [9] 取得这个值。 apriltag.hamming() 返回AprilTag的可接受的数位误差数值。 TAG16H5 -> 最多可接受0位错误 TAG25H7 -> 最多可接受1位错误 TAG25H9 -> 最多可接受3位错误 TAG36H10 -> 最多可接受3位错误 TAG36H11 -> 最多可接受4位错误 ARTOOLKIT -> 最多可接受0位错误 您也可以通过索引 [10] 取得这个值。 apriltag.goodness() 返回AprilTag图像的色饱和度（取值0.0 - 1.0），其中1.0为最佳。 目前这一数值通常是0.0。未来我们可以启用一个称为“标签细化”的功能，以实现对更小的AprilTag的检测。然而，现在这个功能将帧速率降低到1 FPS以下。 您也可以通过索引 [11] 取得这个值。 apriltag.x_translation() 返回距离摄像机x方向的变换，距离的单位未知。 这个方法对于确定远离摄像机的AprilTag的位置很有用。但是，AprilTag的大小以及您使用的镜头等因素都会影响X单元归属的确定。为使用方便，我们推荐您使用查找表将该方法的输出转换为对您的应用程序有用的信息。 注意：此处的方向为从左至右。 您也可以通过索引 [12] 取得这个值。 apriltag.y_translation() 返回距离摄像机y方向的变换，距离的单位未知。 这个方法对于确定远离摄像机的AprilTag的位置很有用。但是，AprilTag的大小以及您使用的镜头等因素都会影响Y单元归属的确定。为使用方便，我们推荐您使用查找表将该方法的输出转换为对您的应用程序有用的信息。 注意：此处的方向为从上至下。 您也可以通过索引 [13] 取得这个值。 apriltag.z_translation() 返回距离摄像机z方向的变换，距离的单位未知。 T这个方法对于确定远离摄像机的AprilTag的位置很有用。但是，AprilTag的大小以及您使用的镜头等因素都会影响Z单元归属的确定。为使用方便，我们推荐您使用查找表将该方法的输出转换为对您的应用程序有用的信息。 注意：此处的方向为从前至后。 您也可以通过索引 [14] 取得这个值。 apriltag.x_rotation() 返回以弧度计的AprilTag在X平面上的旋度。例：目视AprilTag，从左至右移动摄像头。 您也可以通过索引 [15] 取得这个值。 apriltag.y_rotation() 返回以弧度计的AprilTag在Y平面上的旋度。例：目视AprilTag，从上至下移动摄像头。 您也可以通过索引 [16] 取得这个值。 apriltag.z_rotation() 返回以弧度计的AprilTag在Z平面上的旋度。例：目视AprilTag，旋转摄像头。 注意：这只是 apriltag.rotation() 的重命名版本。 您也可以通过索引 [17] 取得这个值。 DataMatrix类 – 数据矩阵对象 数据矩阵对象是由 image.find_datamatrices 返回的。 构造函数 class image.datamatrix 请调用 image.find_datamatrices() 函数来创建此对象。 方法 datamatrix.corners() 返回一个由该对象的四个角组成的四个元组(x,y)的列表。四个角通常是按照从左上角开始沿顺时针顺序返回的。 datamatrix.rect() 返回一个矩形元组(x, y, w, h)，用于如数据矩阵的边界框的 image.draw_rectangle 等其他的 image 方法。 datamatrix.x() 返回数据矩阵的边界框的x坐标(int)。 您也可以通过索引 [0] 取得这个值。 datamatrix.y() 返回数据矩阵的边界框的y坐标(int)。 您也可以通过索引 [1] 取得这个值。 datamatrix.w() 返回数据矩阵的边界框的w宽度。 您也可以通过索引 [2] 取得这个值。 datamatrix.h() 返回数据矩阵的边界框的h高度。 您也可以通过索引 [3] 取得这个值。 datamatrix.payload() 返回数据矩阵的有效载荷的字符串。例：字符串。 您也可以通过索引 [4] 取得这个值。 datamatrix.rotation() 返回以弧度计的数据矩阵的旋度(浮点数)。 您也可以通过索引 [5] 取得这个值。 datamatrix.rows() 返回数据矩阵的行数(int)。 您也可以通过索引 [6] 取得这个值。 datamatrix.columns() 返回数据矩阵的列数(int)。 您也可以通过索引 [7] 取得这个值。 datamatrix.capacity() 返回这一数据矩阵所能容纳的字符的数量。 您也可以通过索引 [8] 取得这个值。 datamatrix.padding() 返回这一数据矩阵中未使用的字符的数量。 您也可以通过索引 [9] 取得这个值。 BarCode类 – 条形码对象 条形码对象是由 image.find_barcodes 返回的。 构造函数 class image.barcode 请调用 image.find_barcodes() 函数来创建此对象。 方法 barcode.corners() 返回一个由该对象的四个角组成的四个元组(x,y)的列表。四个角通常是按照从左上角开始沿顺时针顺序返回的。 barcode.rect() 返回一个矩形元组(x, y, w, h)，用于如数据矩阵的边界框的 image.draw_rectangle 等其他的 image 方法。 barcode.x() 返回条形码的边界框的x坐标(int)。 您也可以通过索引 [0] 取得这个值。 barcode.y() 返回条形码的边界框的y坐标(int)。 您也可以通过索引 [1] 取得这个值。 barcode.w() 返回条形码的边界框的w宽度(int)。 您也可以通过索引 [2] 取得这个值。 barcode.h() 返回条形码的边界框的h高度(int)。 您也可以通过索引 [3] 取得这个值。 barcode.payload() 返回条形码的有效载荷的字符串。例：数量。 您也可以通过索引 [4] 取得这个值。 barcode.type() 返回条形码的列举类型 (int)。 您也可以通过索引 [5] 取得这个值。 image.EAN2 image.EAN5 image.EAN8 image.UPCE image.ISBN10 image.UPCA image.EAN13 image.ISBN13 image.I25 image.DATABAR image.DATABAR_EXP image.CODABAR image.CODE39 image.PDF417 - 未来启用 (e.g. 现在还不能正常使用). image.CODE93 image.CODE128 barcode.rotation() 返回以弧度计的条形码的旋度(浮点数)。 您也可以通过索引 [6] 取得这个值。 barcode.quality() 返回条形码在图像中被检测到的次数(int)。 扫描条形码时，每一条新的扫描线都能解码相同的条形码。每次进行这一过程，条形码的值都会随之增加。 您也可以通过索引 [7] 取得这个值。 Displacement类 – 位移对象 位移对象由 image.find_displacement 返回。 构造函数 class image.displacement 请调用 image.find_displacement() 函数来创建此对象。 方法 displacement.x_translation() 返回两个图像之间的x平移像素。 这是精确的子像素，所以它是一个浮点数。 您也可以通过索引 [0] 取得这个值。 displacement.y_translation() 返回两个图像之间的y平移像素。 这是精确的子像素，所以它是一个浮点数。 您也可以通过索引 [1] 取得这个值。 displacement.rotation() 返回两个图像之间的z平移像素。 这是精确的子像素，所以它是一个浮点数。 您也可以通过索引 [2] 取得这个值。 displacement.scale() 返回两个图像之间旋转的弧度。 您也可以通过索引 [3] 取得这个值。 displacement.response() 返回两幅图像之间位移匹配结果的质量。 范围 0-1。响应小于0.1的 displacement 对象可能是噪声。 您也可以通过索引 [4] 取得这个值。 Kptmatch类 – 特征点对象 特征点对象是由 image.match_descriptor 返回的。 构造函数 class image.kptmatch 请调用 image.match_descriptor() 函数来创建此对象。 方法 kptmatch.rect() 返回一个矩形元组(x, y, w, h)，用于如特征点的边界框的 image.draw_rectangle 等其他的 image 方法。 kptmatch.cx() 返回特征点的中心x位置(int)。 您也可以通过索引 [0] 取得这个值。 kptmatch.cy() 返回特征点的中心y位置(int)。 您也可以通过索引 [1] 取得这个值。 kptmatch.x() 返回特征点边界框的x坐标(int)。 您也可以通过索引 [2] 取得这个值。 kptmatch.y() 返回特征点边界框的y坐标(int)。 您也可以通过索引 [3] 取得这个值。 kptmatch.w() 返回特征点边界框的w宽度(int)。 您也可以通过索引 [4] 取得这个值。 kptmatch.h() 返回特征点边界框的h高度(int)。 您也可以通过索引 [5] 取得这个值。 kptmatch.count() 返回匹配的特征点的数量(int)。 您也可以通过索引 [6] 取得这个值。 kptmatch.theta() 返回估计的特征点的旋度(int)。 您也可以通过索引 [7] 取得这个值。 kptmatch.match() 返回匹配关键点的(x，y)元组列表。 您也可以通过索引 [8] 取得这个值。 ImageWriter类 – ImageWriter对象 ImageWriter 对象使得您可以快速地将未压缩的图像写入磁盘。 ＃　构造函数 class image.ImageWriter(path) 创建一个ImageWriter对象，您就可以以用于OpenMV Cams的简单文件格式将未压缩的图像写到磁盘上。然后未压缩的图像可以使用ImageReader重新读取。 方法 imagewriter.size() 返回正在写入的文件的大小。 imagewriter.add_frame(img) 将一张图像写入磁盘。由于图像未被压缩，因此执行迅速，但会占用大量磁盘空间。 imagewriter.close() 关闭图像流文件。您必须关闭文件，否则文件会损坏。 ImageReader 类– ImageReader对象 ImageReader对象使得您可以快速地从磁盘中读取未压缩的图像。 构造函数 class image.ImageReader(path) 创建一个ImageReader对象，用来回放由ImageWriter对象编写的图像数据。ImageWriter对象回放的帧会在与写入磁盘时相同的FPS下回放。 方法 imagereader.size() 返回正在读取的文件的大小。 imagereader.next_frame([copy_to_fb=True, loop=True]) 从ImageWriter写就的文件中返回图像对象。若 copy_to_fb 为True，图像对象将被直接加载到帧缓冲区中。否则图像对象将被放入堆中。注意：除非图像很小，否则堆可能没有足够的空间来存储图像对象。 若 loop 为True，流的最后一个图像读取之后，回放将重新开始。否则所有帧被读取后，这个方法将返回None。 注意： imagereader.next_frame 尝试在读取帧后通过暂停播放来限制回放速度，以与帧记录的速度相匹配。 否则，这个方法会以200+FPS的速度图像快读播放所有图像。 imagereader.close() 关闭正在读取的文件。您需要进行这一操作，以防imagereader 对象受损。但由于是只读文件，文件不会在未关闭时受损。 Image类 – 图像对象 图像对象是机器视觉操作的基本对象。 构造函数 class image.Image(path[, copy_to_fb=False]) 从 path 中的文件中创建一个新的图像对象。 支持bmp/pgm/ppm/jpg/jpeg格式的图像文件。 若 copy_to_fb 为True，图像会直接载入帧缓冲区，您就可以加载大幅图片了。若为False，图像会载入MicroPython的堆中，堆远比帧缓冲区小。 在OpenMV Cam M4中，若 copy_to_fb 为False，您应该尽量把图像大小控制在8KB以下。若为True，则图像最大可为160KB。 在OpenMV Cam M7中，若 copy_to_fb 为False，您应该尽量把图像大小控制在16KB以下。若为True，则图像最大可为320KB。 图像支持“[]”记法。 令 image[index] = 8/16-bit value ，以便分配图像像素或 image[index] ，并得到一个图像像素，若是用于RGB图像的16位RGB565值的灰度图像， 这一像素则为8位。 对于JPEG图像而言，“[]”使得您可以访问压缩的节数组形式的JPEG图像色块。由于JPEG图像是压缩的字节流形式，因而对数据组的读取和写入是不透明的。 图像还支持读缓冲区操作。您可以把图像当作节数组对象，将图像输入所有类型的MicroPython函数。若您想传送一个图像，可以将它传递给UART /SPI/ I2C写入函数，可实现自动传送。 方法 image.width() 返回以像素计的图像的宽度。 image.height() 返回以像素计的图像的高度。 image.format() 返回用于灰度图的 sensor.GRAYSCALE 、用于RGB图像的 sensor.RGB565 和用于JPEG图像的 sensor.JPEG 。 image.size() 返回以字节计的图像大小。 image.get_pixel(x, y[, rgbtuple]) 灰度图：返回(x, y)位置的灰度像素值。 RGB565l：返回(x, y)位置的RGB888像素元组(r, g, b)。 Bayer图像: 返回(x, y)位置的像素值。 不支持压缩图像。 image.get_pixel() 和 image.set_pixel()是允许你操作Bayer模式图像的唯一方法。 Bayer模式图像是文字图像。对于偶数行，其中图像中的像素是R/G/R/G/等。 对于奇数行，其中图像中的像素是G/B/G/B/等。 每个像素是8位。 image.set_pixel(x, y, pixel) 灰度图：将(x, y) 位置的像素设置为灰度值 pixel 。 RGB图像：将(x, y) 位置的像素设置为RGB888元组(r, g, b) pixel 。 不支持压缩图像。 image.get_pixel() 和 image.set_pixel()是允许你操作Bayer模式图像的唯一方法。 Bayer模式图像是文字图像。对于偶数行，其中图像中的像素是R/G/R/G/等。 对于奇数行，其中图像中的像素是G/B/G/B/等。 每个像素是8位。 image.mean_pool(x_div, y_div) 在图像中找到 x_div * y_div 正方形的平均值，并返回由每个正方形的平均值组成的修改图像。 此方法允许您在原来图像上快速缩小图像。 不支持压缩图像和bayer图像。 image.mean_pooled(x_div, y_div) 在图像中找到 x_div * y_div 正方形的平均值，并返回由每个正方形的平均值组成的新图像。 此方法允许您创建缩小的图像副本。 不支持压缩图像和bayer图像。 image.midpoint_pool(x_div, y_div[, bias=0.5]) 在图像中找到 x_div * y_div 正方形的中点值，并返回由每个正方形的中点值组成的修改图像。 bias 为0.0返回每个区域的最小值，而bias 为1.0返回每个区域的最大值。 此方法允许您在原来图像上快速缩小图像。 不支持压缩图像和bayer图像。 image.midpoint_pooled(x_div, y_div[, bias=0.5]) 在图像中找到 x_div * y_div 正方形的中点值，并返回由每个正方形的中点值组成的新图像。 bias 为0.0返回每个区域的最小值，而bias 为1.0返回每个区域的最大值。 此方法允许您创建缩小的图像副本。 不支持压缩图像和bayer图像。 image.to_grayscale([copy=False]) 将图像转换为灰度图像。 此方法也会修改基础图像像素，以字节为单位更改图像大小，因此只能在灰度图像或RGB565图像上进行。 否则 copy 必须为True才能在堆上创建新的修改图像。 返回图像对象，以便您可以使用 . 表示法调用另一个方法。 不支持压缩图像和bayer图像。 image.to_rgb565([copy=False]) 将图像转换为彩色图像。 此方法也会修改基础图像像素，以字节为单位更改图像大小，因此只能在RGB565图像上进行。 否则 copy 必须为True才能在堆上创建新的修改图像。 返回图像对象，以便您可以使用 . 表示法调用另一个方法。 不支持压缩图像和bayer图像。 image.to_rainbow([copy=False]) 将图像转换为彩虹图像。 此方法也会修改基础图像像素，以字节为单位更改图像大小，因此只能在RGB565图像上进行。 否则 copy 必须为True才能在堆上创建新的修改图像。 彩虹图像是彩色图像，对于图像中的每个8位掩模灰度照明值具有唯一的颜色值。 例如，它为热图像提供热图颜色。 返回图像对象，以便您可以使用 . 表示法调用另一个方法。 不支持压缩图像和bayer图像。 image.compress([quality=50]) JPEG对图像进行适当压缩。使用这种方法与 compressed 保存堆空间相比，使用更高quality的压缩率是以破坏原始图像为代价的。 quality 是压缩质量（0-100）（int）。 image.compress_for_ide([quality=50]) JPEG对图像进行适当压缩。使用这种方法与 compressed 保存堆空间相比，使用更高quality的压缩率是以破坏原始图像为代价的。 这个方法压缩图像，然后通过将每6比特编码为128 - 191之间的字节将JPEG数据格式化，转换为OpenMV IDE，以便显示。进行这一步是为防止JPEG数据被误认为是字节流中的其他文本数据。 您需要使用这一方法来格式化图像数据，以便在OpenMV IDE中通过“开放终端”创建的终端窗口中显示。 quality 是压缩质量（0-100）（int）。 image.compressed([quality=50]) 返回一个JPEG压缩图像—原始图像未经处理。但是，这个方法需要堆空间的大分配，所以图像压缩质量和图像分辨率必须很低。 quality 是压缩质量（0-100）（int）。 image.compressed_for_ide([quality=50]) 返回一个JPEG压缩图像—原始图像未经处理。但是，这个方法需要堆空间的大分配，所以图像压缩质量和图像分辨率必须很低。 这个方法压缩图像，然后通过将每6比特编码为128 - 191之间的字节将JPEG数据格式化，转换为OpenMV IDE，以便显示。进行这一步是为防止JPEG数据被误认为是字节流中的其他文本数据。 您需要使用这一方法来格式化图像数据，以便在OpenMV IDE中通过“开放终端”创建的终端窗口中显示。 quality 是压缩质量（0-100）（int）。 image.copy([roi[, copy_to_fb=False]]) 创建一个图像对象的副本。 Roi 是一个用以复制的矩形的感兴趣区域(x, y, w, h)。如果未指定，ROI即复制整个图像的图像矩形。但这不适用于JPEG图像。 请记住图像副本储存在MicroPython 堆中而不是帧缓冲区。同样，您需要将图像副本大小控制在8KB以下（OpenMV）或16KB以下（OpenMV Cam M7） 如果您想使用一个复制操作来使用所有的堆空间，这个函数会出现异常。过大的图像极易触发异常。 如果 copy_to_fb 为True，则该方法将帧缓冲替换为图像。 帧缓冲区具有比堆大得多的空间，并且可以容纳大图像。 image.save(path[, roi[, quality=50]]) 将图像的副本保存到 path 中的文件系统。 支持bmp/pgm/ppm/jpg/jpeg格式的图像文件。注意：您无法将jpeg格式的压缩图像保存成未压缩的格式。 roi 是一个用以复制的矩形的感兴趣区域(x, y, w, h)。如果未指定，ROI即复制整个图像的图像矩形。但这不适用于JPEG图像。 quality 指在图像尚未被压缩时将图像保存为JPEG格式的JPEG压缩质量。 image.clear() 将图像中的所有像素设置为零（非常快）。 返回图像对象，以便您可以使用 . 表示法调用另一个方法。 不支持压缩图像。 image.draw_line(x0, y0, x1, y1[, color[, thickness=1]]) 在图像上绘制一条从(x0，y0)到(x1，y1)的线。 您可以单独传递x0，y0，x1，y1，也可以传递给元组(x0，y0，x1，y1)。 color 是用于灰度或RGB565图像的RGB888元组。默认为白色。但是，您也可以传递灰度图像的基础像素值(0-255)或RGB565图像的字节反转RGB565值。 thickness 控制线的粗细像素。 返回图像对象，以便您可以使用 . 表示法调用另一个方法。 不支持压缩图像和bayer图像。 image.draw_rectangle(x, y, w, h[, color[, thickness=1[, fill=False]]]) 在图像上绘制一个矩形。 您可以单独传递x，y，w，h或作为元组(x，y，w，h)传递。 color 是用于灰度或RGB565图像的RGB888元组。默认为白色。但是，您也可以传递灰度图像的基础像素值(0-255)或RGB565图像的字节反转RGB565值。 thickness 控制线的粗细像素。 将 fill 设置为True以填充矩形。 返回图像对象，以便您可以使用 . 表示法调用另一个方法。 不支持压缩图像和bayer图像。 image.draw_circle(x, y, radius[, color[, thickness=1[, fill=False]]]) 在图像上绘制一个圆形。 您可以单独传递x，y，半径 或 作为元组(x，y，radius)传递。 color 是用于灰度或RGB565图像的RGB888元组。默认为白色。但是，您也可以传递灰度图像的基础像素值(0-255)或RGB565图像的字节反转RGB565值。 thickness 控制线的粗细像素。 将 fill 设置为True以填充圆形。 返回图像对象，以便您可以使用 . 表示法调用另一个方法。 不支持压缩图像和bayer图像。 image.draw_string(x, y, text[, color[, scale=1[, x_spacing=0[, y_spacing=0[, mono_space=True]]]]]) 从图像中的(x, y)位置开始绘制8x10文本。您可以单独传递x，y，也可以作为元组(x，y)传递。 text 是写入图像的字符串。 \\n, \\r, 和 \\r\\n 结束符将光标移至下一行。 color 是用于灰度或RGB565图像的RGB888元组。默认为白色。但是，您也可以传递灰度图像的基础像素值(0-255)或RGB565图像的字节反转RGB565值。 可以增加 scale 以增加图像上文本的大小。 仅整数值（例如，1/2/3 /等）。 x_spacing 允许你在字符之间添加（如果是正数）或减去（如果是负数）x像素，设置字符间距。 y_spacing 允许你在字符之间添加（如果是正数）或减去（如果是负数）y像素，设置行间距。 mono_space 默认为True，强制文本间距固定。对于大文本，这看起来很糟糕。设置False以获得非固定宽度的字符间距，看起来好多了。 返回图像对象，以便您可以使用 . 表示法调用另一个方法。 不支持压缩图像和bayer图像。 image.draw_cross(x, y[, color[, size=5[, thickness=1]]]) 在图像上绘制一个十字。 您可以单独传递x，y或作为元组(x，y)传递。 color 是用于灰度或RGB565图像的RGB888元组。默认为白色。但是，您也可以传递灰度图像的基础像素值(0-255)或RGB565图像的字节反转RGB565值。 size 控制十字线的延伸长度。 thickness 控制边缘的像素厚度。 返回图像对象，以便您可以使用 . 表示法调用另一个方法。 不支持压缩图像和bayer图像。 image.draw_arrow(x0, y0, x1, y1[, color[, thickness=1]]) 在图像上绘制一条从(x0，y0)到(x1，y1)的箭头。 您可以单独传递x0，y0，x1，y1，也可以传递给元组(x0，y0，x1，y1)。 color 是用于灰度或RGB565图像的RGB888元组。默认为白色。但是，您也可以传递灰度图像的基础像素值(0-255)或RGB565图像的字节反转RGB565值。 thickness 控制线的粗细像素。 返回图像对象，以便您可以使用 . 表示法调用另一个方法。 不支持压缩图像和bayer图像。 image.draw_image(image, x, y[, x_scale=1.0[, y_scale=1.0[, mask=None]]]) 绘制一个 image ，其左上角从位置x，y开始。 您可以单独传递x，y，也可以传递给元组(x，y)。 x_scale 控制图像在x方向(浮点数)缩放的程度。 y_scale 控制图像在y方向(浮点数)缩放的程度。 mask 是另一个用作绘图操作的像素级掩码的图像。掩码应该是一个只有黑色或白色像素的图像，并且应该与你正在绘制的 image 大小相同。 您可以使用mask掩码进行绘制操作。 返回图像对象，以便您可以使用 . 表示法调用另一个方法。 不支持压缩图像和bayer图像。 image.draw_keypoints(keypoints[, color[, size=10[, thickness=1[, fill=False]]]]) 在图像上画出一个特征点对象的各个点。 color 是用于灰度或RGB565图像的RGB888元组。默认为白色。但是，您也可以传递灰度图像的基础像素值(0-255)或RGB565图像的字节反转RGB565值。 size 控制特征点的大小。 thickness 控制线的粗细像素。 将 fill 设置为True以填充特征点。 返回图像对象，以便您可以使用 . 表示法调用另一个方法。 不支持压缩图像和bayer图像。 image.flood_fill(x, y[, seed_threshold=0.05[, floating_threshold=0.05[, color[, invert=False[, clear_background=False[, mask=None]]]]]]) 从位置x，y开始填充图像的区域。 您可以单独传递x，y，也可以传递给元组(x，y)。 seed_threshold 控制填充区域中的像素与原始起始像素的差异。 floating_threshold 控制填充区域中的像素与任何相邻像素的差异。 color 是用于灰度或RGB565图像的RGB888元组。默认为白色。但是，您也可以传递灰度图像的基础像素值(0-255)或RGB565图像的字节反转RGB565值。 将 invert 传递为True，以重新填充flood_fill连接区域外的所有内容。 将 clear_background 传递为True，将其余的flood_fill没有重新着色的像素归零。 mask 是另一个用作绘图操作的像素级掩码的图像。掩码应该是一个只有黑色或白色像素的图像，并且应该与你正在绘制的 image 大小相同。 仅掩膜中设置的像素会在flood_fill时被评估。 返回图像对象，以便您可以使用 . 表示法调用另一个方法。 不支持压缩图像和bayer图像。 此方法在OpenMV Cam M4 上不可用。 image.binary(thresholds[, invert=False[, zero=False[, mask=None]]]) 根据像素是否在阈值列表 thresholds 中的阈值内，将图像中的所有像素设置为黑色或白色。 thresholds 必须是元组列表。 [(lo, hi), (lo, hi), ..., (lo, hi)] 定义你想追踪的颜色范围。 对于灰度图像，每个元组需要包含两个值 - 最小灰度值和最大灰度值。 仅考虑落在这些阈值之间的像素区域。 对于RGB565图像，每个元组需要有六个值(l_lo，l_hi，a_lo，a_hi，b_lo，b_hi) - 分别是LAB L，A和B通道的最小值和最大值。 为方便使用，此功能将自动修复交换的最小值和最大值。 此外，如果元组大于六个值，则忽略其余值。相反，如果元组太短，则假定其余阈值处于最大范围。 注解 获取所跟踪对象的阈值，只需在 IDE 帧缓冲区中选择（单击并拖动）跟踪对象。 直方图会相应地更新到所在区域。然后只需写下颜色分布在每个直方图通道中起始与下降位置。 这些将是 thresholds 的低值和高值。 由于上下四分位数据相差微小，故手动确定阈值为佳。 您还可以通过进入OpenMV IDE中的 工具 ->机器视觉 ->阈值编辑器 并从GUI窗口中拖动滑块来确定颜色阈值。 invert 反转阈值操作，像素在已知颜色范围之外进行匹配，而非在已知颜色范围内。 设置 zero 为True来使阈值像素为零，并使不在阈值列表中的像素保持不变。 mask 是另一个用作绘图操作的像素级掩码的图像。掩码应该是一个只有黑色或白色像素的图像，并且应该与你正在绘制的 image 大小相同。 仅掩码中设置的像素被修改。 返回图像对象，以便您可以使用 . 表示法调用另一个方法。 不支持压缩图像和bayer图像。 image.invert() 将二进制图像0（黑色）变为1（白色），1（白色）变为0（黑色），非常快速地翻转二进制图像中的所有像素值。 返回图像对象，以便您可以使用 . 表示法调用另一个方法。 不支持压缩图像和Bayer图像。 image.b_and(image[, mask=None]) 用另一图像与这一图像进行逻辑与运算。 image 可以是图像对象，未压缩图像文件的路径(bmp/pgm/ppm)，也可以是标量值。 如果标量值，该值可以是RGB888元组或基础像素值(例如，灰度图像的8位灰度级或RGB图像的字节反转RGB565值)。 mask 是另一个用作绘图操作的像素级掩码的图像。掩码应该是一个只有黑色或白色像素的图像，并且应该与你正在绘制的 image 大小相同。 仅掩码中设置的像素被修改。 返回图像对象，以便您可以使用 . 表示法调用另一个方法。 不支持压缩图像和bayer图像。 image.b_nand(image[, mask=None]) 用另一图像与这一图像进行逻辑与非运算。 image 可以是图像对象，未压缩图像文件的路径(bmp/pgm/ppm)，也可以是标量值。 如果标量值，该值可以是RGB888元组或基础像素值(例如，灰度图像的8位灰度级或RGB图像的字节反转RGB565值)。 mask 是另一个用作绘图操作的像素级掩码的图像。掩码应该是一个只有黑色或白色像素的图像，并且应该与你正在绘制的 image 大小相同。 仅掩码中设置的像素被修改。 返回图像对象，以便您可以使用 . 表示法调用另一个方法。 不支持压缩图像和bayer图像。 image.b_or(image[, mask=None]) 用另一图像与这一图像进行逻辑或运算。 image 可以是图像对象，未压缩图像文件的路径(bmp/pgm/ppm)，也可以是标量值。 如果标量值，该值可以是RGB888元组或基础像素值(例如，灰度图像的8位灰度级或RGB图像的字节反转RGB565值)。 mask 是另一个用作绘图操作的像素级掩码的图像。掩码应该是一个只有黑色或白色像素的图像，并且应该与你正在绘制的 image 大小相同。 仅掩码中设置的像素被修改。 返回图像对象，以便您可以使用 . 表示法调用另一个方法。 不支持压缩图像和bayer图像。 image.b_nor(image[, mask=None]) 用另一图像与这一图像进行逻辑或非运算。 image 可以是图像对象，未压缩图像文件的路径(bmp/pgm/ppm)，也可以是标量值。 如果标量值，该值可以是RGB888元组或基础像素值(例如，灰度图像的8位灰度级或RGB图像的字节反转RGB565值)。 mask 是另一个用作绘图操作的像素级掩码的图像。掩码应该是一个只有黑色或白色像素的图像，并且应该与你正在绘制的 image 大小相同。 仅掩码中设置的像素被修改。 返回图像对象，以便您可以使用 . 表示法调用另一个方法。 不支持压缩图像和bayer图像。 image.b_xor(image[, mask=None]) 用另一图像与这一图像进行逻辑异或运算。 image 可以是图像对象，未压缩图像文件的路径(bmp/pgm/ppm)，也可以是标量值。 如果标量值，该值可以是RGB888元组或基础像素值(例如，灰度图像的8位灰度级或RGB图像的字节反转RGB565值)。 mask 是另一个用作绘图操作的像素级掩码的图像。掩码应该是一个只有黑色或白色像素的图像，并且应该与你正在绘制的 image 大小相同。 仅掩码中设置的像素被修改。 返回图像对象，以便您可以使用 . 表示法调用另一个方法。 不支持压缩图像和bayer图像。 image.b_xnor(image[, mask=None]) 用另一图像与这一图像进行逻辑同或运算。 image 可以是图像对象，未压缩图像文件的路径(bmp/pgm/ppm)，也可以是标量值。 如果标量值，该值可以是RGB888元组或基础像素值(例如，灰度图像的8位灰度级或RGB图像的字节反转RGB565值)。 mask 是另一个用作绘图操作的像素级掩码的图像。掩码应该是一个只有黑色或白色像素的图像，并且应该与你正在绘制的 image 大小相同。 仅掩码中设置的像素被修改。 返回图像对象，以便您可以使用 . 表示法调用另一个方法。 不支持压缩图像和bayer图像。 image.erode(size[, threshold[, mask=None]]) 从分割区域的边缘删除像素。 这一方法通过卷积图像上((size2)+1)x((size2)+1)像素的核来实现，如果相邻像素集的总和小于 threshold ，则对内核的中心像素进行归零。 若 threshold 未设定，这个方法的功能如标准腐蚀方法一样。若threshold设定，您就可以指定腐蚀的特定像素，例如：设置低于2个的像素周围阈值为2。 mask 是另一个用作绘图操作的像素级掩码的图像。掩码应该是一个只有黑色或白色像素的图像，并且应该与你正在绘制的 image 大小相同。 仅掩码中设置的像素被修改。 返回图像对象，以便您可以使用 . 表示法调用另一个方法。 不支持压缩图像和bayer图像。 image.dilate(size[, threshold[, mask=None]]) 将像素添加到分割区域的边缘中。 这一方法通过卷积图像上((size2)+1)x((size2)+1)像素的核来实现，如果相邻像素集的总和大于 threshold ，则将内核的中心像素进行设置。 若 threshold 未设定，这个方法的功能如标准腐蚀方法一样。若threshold设定，您就可以指定腐蚀的特定像素，例如：设置低于2个的像素周围阈值为2。 mask 是另一个用作绘图操作的像素级掩码的图像。掩码应该是一个只有黑色或白色像素的图像，并且应该与你正在绘制的 image 大小相同。 仅掩码中设置的像素被修改。 返回图像对象，以便您可以使用 . 表示法调用另一个方法。 不支持压缩图像和bayer图像。 image.open(size[, threshold[, mask=None]]) 按顺序对图像执行腐蚀和膨胀。有关更多信息，请参阅 image.erode() 和 image.dilate() 。 mask 是另一个用作绘图操作的像素级掩码的图像。掩码应该是一个只有黑色或白色像素的图像，并且应该与你正在绘制的 image 大小相同。 仅掩码中设置的像素被修改。 返回图像对象，以便您可以使用 . 表示法调用另一个方法。 不支持压缩图像和bayer图像。 image.close(size[, threshold[, mask=None]]) 按顺序对图像执行膨胀和腐蚀。有关更多信息，请参阅 image.erode() 和 image.dilate() 。 mask 是另一个用作绘图操作的像素级掩码的图像。掩码应该是一个只有黑色或白色像素的图像，并且应该与你正在绘制的 image 大小相同。 仅掩码中设置的像素被修改。 返回图像对象，以便您可以使用 . 表示法调用另一个方法。 不支持压缩图像和bayer图像。 image.top_hat(size[, threshold[, mask=None]]) 返回原图像和执行 image.open() 函数后图像的差异。 mask 是另一个用作绘图操作的像素级掩码的图像。掩码应该是一个只有黑色或白色像素的图像，并且应该与你正在绘制的 image 大小相同。 仅掩码中设置的像素被修改。 不支持压缩图像和bayer图像。 image.black_hat(size[, threshold[, mask=None]]) 返回原图像和执行 image.close() 函数后图像的差异。 mask 是另一个用作绘图操作的像素级掩码的图像。掩码应该是一个只有黑色或白色像素的图像，并且应该与你正在绘制的 image 大小相同。 仅掩码中设置的像素被修改。 不支持压缩图像和bayer图像。 image.negate() 非常快速地翻转（数字反转）图像中的所有像素值。对每个颜色通道的像素值进行数值转换。例： (255 - pixel). 返回图像对象，以便您可以使用 . 表示法调用另一个方法。 不支持压缩图像和bayer图像。 image.replace(image[, hmirror=False[, vflip=False[, mask=None]]]) image 可以是图像对象，未压缩图像文件的路径(bmp/pgm/ppm)，也可以是标量值。 如果标量值，该值可以是RGB888元组或基础像素值(例如，灰度图像的8位灰度级或RGB图像的字节反转RGB565值)。 将 hmirror 设置为True以水平镜像替换图像。 将 vflip 设置为True以垂直翻转替换图像。 mask 是另一个用作绘图操作的像素级掩码的图像。掩码应该是一个只有黑色或白色像素的图像，并且应该与你正在绘制的 image 大小相同。 仅掩码中设置的像素被修改。 返回图像对象，以便您可以使用 . 表示法调用另一个方法。 不支持压缩图像和bayer图像。 image.add(image[, mask=None]) 将两个图像彼此按像素相加。 image 可以是图像对象，未压缩图像文件的路径(bmp/pgm/ppm)，也可以是标量值。 如果标量值，该值可以是RGB888元组或基础像素值(例如，灰度图像的8位灰度级或RGB图像的字节反转RGB565值)。 mask 是另一个用作绘图操作的像素级掩码的图像。掩码应该是一个只有黑色或白色像素的图像，并且应该与你正在绘制的 image 大小相同。 仅掩码中设置的像素被修改。 返回图像对象，以便您可以使用 . 表示法调用另一个方法。 不支持压缩图像和bayer图像。 image.sub(image[, reverse=False[, mask=None]]) 将两个图像彼此按像素相减。 image 可以是图像对象，未压缩图像文件的路径(bmp/pgm/ppm)，也可以是标量值。 如果标量值，该值可以是RGB888元组或基础像素值(例如，灰度图像的8位灰度级或RGB图像的字节反转RGB565值)。 将 reverse 设置为True可以将减法操作从 this_image-image 反转为 image-this_image 。 mask 是另一个用作绘图操作的像素级掩码的图像。掩码应该是一个只有黑色或白色像素的图像，并且应该与你正在绘制的 image 大小相同。 仅掩码中设置的像素被修改。 返回图像对象，以便您可以使用 . 表示法调用另一个方法。 不支持压缩图像和bayer图像。 image.mul(image[, invert=False[, mask=None]]) 将两个图像彼此按像素相乘。 image 可以是图像对象，未压缩图像文件的路径(bmp/pgm/ppm)，也可以是标量值。 如果标量值，该值可以是RGB888元组或基础像素值(例如，灰度图像的8位灰度级或RGB图像的字节反转RGB565值)。 将 invert 设置为True可将乘法运算从 ab 改为 1/((1/a)(1/b))。 特别是，这使图像变亮而不是使图像变暗(例如，乘法与刻录操作)。 mask 是另一个用作绘图操作的像素级掩码的图像。掩码应该是一个只有黑色或白色像素的图像，并且应该与你正在绘制的 image 大小相同。 仅掩码中设置的像素被修改。 返回图像对象，以便您可以使用 . 表示法调用另一个方法。 不支持压缩图像和bayer图像。 image.div(image[, invert=False[, mask=None]]) 将此图像除以另一个图像。 image 可以是图像对象，未压缩图像文件的路径(bmp/pgm/ppm)，也可以是标量值。 如果标量值，该值可以是RGB888元组或基础像素值(例如，灰度图像的8位灰度级或RGB图像的字节反转RGB565值)。 将 invert 设置为True可将除法方向从 a/b 改为 b/a。 mask 是另一个用作绘图操作的像素级掩码的图像。掩码应该是一个只有黑色或白色像素的图像，并且应该与你正在绘制的 image 大小相同。 仅掩码中设置的像素被修改。 返回图像对象，以便您可以使用 . 表示法调用另一个方法。 不支持压缩图像和bayer图像。 image.min(image[, mask=None]) 在像素级 用此图像和另一个图像之间的最小像素值替换此图像中的像素。 image 可以是图像对象，未压缩图像文件的路径(bmp/pgm/ppm)，也可以是标量值。 如果标量值，该值可以是RGB888元组或基础像素值(例如，灰度图像的8位灰度级或RGB图像的字节反转RGB565值)。 mask 是另一个用作绘图操作的像素级掩码的图像。掩码应该是一个只有黑色或白色像素的图像，并且应该与你正在绘制的 image 大小相同。 仅掩码中设置的像素被修改。 返回图像对象，以便您可以使用 . 表示法调用另一个方法。 不支持压缩图像和bayer图像。 这个方法在OpenMV4上不可用. image.max(image[, mask=None]) 在像素级 用此图像和另一个图像之间的最大像素值替换此图像中的像素。 image 可以是图像对象，未压缩图像文件的路径(bmp/pgm/ppm)，也可以是标量值。 如果标量值，该值可以是RGB888元组或基础像素值(例如，灰度图像的8位灰度级或RGB图像的字节反转RGB565值)。 mask 是另一个用作绘图操作的像素级掩码的图像。掩码应该是一个只有黑色或白色像素的图像，并且应该与你正在绘制的 image 大小相同。 仅掩码中设置的像素被修改。 返回图像对象，以便您可以使用 . 表示法调用另一个方法。 不支持压缩图像和bayer图像。 image.difference(image[, mask=None]) 将两个图像彼此按像素取绝对值。例：对于每个颜色通道而言，将每个像素��换为ABS(this.pixel-image.pixel)。 image 可以是图像对象，未压缩图像文件的路径(bmp/pgm/ppm)，也可以是标量值。 如果标量值，该值可以是RGB888元组或基础像素值(例如，灰度图像的8位灰度级或RGB图像的字节反转RGB565值)。 mask 是另一个用作绘图操作的像素级掩码的图像。掩码应该是一个只有黑色或白色像素的图像，并且应该与你正在绘制的 image 大小相同。 仅掩码中设置的像素被修改。 返回图像对象，以便您可以使用 . 表示法调用另一个方法。 不支持压缩图像和bayer图像。 image.blend(image[, alpha=128[, mask=None]]) 将另外一张图像 image 与这一图像融合。 image 可以是图像对象，未压缩图像文件的路径(bmp/pgm/ppm)，也可以是标量值。 如果标量值，该值可以是RGB888元组或基础像素值(例如，灰度图像的8位灰度级或RGB图像的字节反转RGB565值)。 alpha 控制要混合到这个图像中的其他图像的多少. alpha 应该是0到256之间的整数值。接近零的值会将更多其他图像混合到此图像中，接近256则相反。 mask 是另一个用作绘图操作的像素级掩码的图像。掩码应该是一个只有黑色或白色像素的图像，并且应该与你正在绘制的 image 大小相同。 仅掩码中设置的像素被修改。 返回图像对象，以便您可以使用 . 表示法调用另一个方法。 不支持压缩图像和bayer图像。 image.histeq([adaptive=False[, clip_limit=-1[, mask=None]]]) 在图像上运行直方图均衡算法。 直方图均衡化使图像中的对比度和亮度标准化。 如果 adaptive 传递为True，那么将在图像上运行自适应直方图均衡方法，这通常比非自适应直方图限定更好，但运行时间更长。 clip_limit 提供了一种限制自适应直方图均衡的对比度的方法。 使用较小的值(例如10)可以生成良好的直方图均衡对比度受限图像。 mask 是另一个用作绘图操作的像素级掩码的图像。掩码应该是一个只有黑色或白色像素的图像，并且应该与你正在绘制的 image 大小相同。 仅掩码中设置的像素被修改。 返回图像对象，以便您可以使用 . 表示法调用另一个方法。 不支持压缩图像和bayer图像。 image.mean(size, [threshold=False, [offset=0, [invert=False, [mask=None]]]]]) 使用盒式滤波器的标准均值模糊滤波。 Size 是内核的大小。取1 (3x3 内核)、2 (5x5 内核)或更高值。 如果你想在滤波器的输出上自适应地设置阈值，你可以传递 threshold=True 参数来启动图像的自适应阈值处理， 他根据环境像素的亮度（核函数周围的像素的亮度有关），将像素设置为1或者0。 负数 offset 值将更多像素设置为1，而正值仅将最强对比度设置为1。 设置 invert 以反转二进制图像的结果输出。 mask 是另一个用作绘图操作的像素级掩码的图像。掩码应该是一个只有黑色或白色像素的图像，并且应该与你正在绘制的 image 大小相同。 仅掩码中设置的像素被修改。 返回图像对象，以便您可以使用 . 表示法调用另一个方法。 不支持压缩图像和bayer图像。 median(size, percentile=0.5, threshold=False, offset=0, invert=False, mask]) 在图像上运行中值滤波。在保留边缘的条件下，中值滤波是用来平滑表面的最佳滤波，但是运行速度极慢。 Size 是内核的大小。取1 (3x3 内核)、2 (5x5 内核)或更高值。 percentile 控制内核中所使用值的百分位数。默认情况下，每个像素都使用相邻的第五十个百分位数（中心）替换。使用最小滤波时，您可将此值设置为0，使用下四分位数滤波时设置为0.25，使用上四分位数滤波时设置为0.75，使用最大滤波时设置为1。 如果你想在滤波器的输出上自适应地设置阈值，你可以传递 threshold=True 参数来启动图像的自适应阈值处理， 他根据环境像素的亮度（核函数周围的像素的亮度有关），将像素设置为1或者0。 负数 offset 值将更多像素设置为1，而正值仅将最强对比度设置为1。 设置 invert 以反转二进制图像的结果输出。 mask 是另一个用作绘图操作的像素级掩码的图像。掩码应该是一个只有黑色或白色像素的图像，并且应该与你正在绘制的 image 大小相同。 仅掩码中设置的像素被修改。 返回图像对象，以便您可以使用 . 表示法调用另一个方法。 不支持压缩图像和bayer图像。 此方法在OpenMV Cam M4 上不可用。 image.mode(size[, threshold=False, offset=0, invert=False, mask]) 在图像上运行众数滤波，用相邻像素的模式替换每个像素。这一方法在灰度图上运行效果良好。但由于这一操作的非线性特性，会在RGB图像边缘上产生许多伪像。 Size 是内核的大小。取1 (3x3 内核)、2 (5x5 内核)。 如果你想在滤波器的输出上自适应地设置阈值，你可以传递 threshold=True 参数来启动图像的自适应阈值处理， 他根据环境像素的亮度（核函数周围的像素的亮度有关），将像素设置为1或者0。 负数 offset 值将更多像素设置为1，而正值仅将最强对比度设置为1。 设置 invert 以反转二进制图像的结果输出。 mask 是另一个用作绘图操作的像素级掩码的图像。掩码应该是一个只有黑色或白色像素的图像，并且应该与你正在绘制的 image 大小相同。 仅掩码中设置的像素被修改。 返回图像对象，以便您可以使用 . 表示法调用另一个方法。 不支持压缩图像和bayer图像。 此方法在OpenMV Cam M4 上不可用。 image.midpoint(size[, bias=0.5, threshold=False, offset=0, invert=False, mask]) 在图像上运行中点滤波。此滤波器找到图像中每个像素邻域的中点((max-min)/2)。 size 是内核的大小。取1 (3x3 内核)、2 (5x5 内核)或更高值。 bias 控制图像混合的最小/最大程度。0只适用于最小滤波，1仅用于最大滤波。您可以通过 bias 对图像进行最小/最大化过滤。 如果你想在滤波器的输出上自适应地设置阈值，你可以传递 threshold=True 参数来启动图像的自适应阈值处理， 他根据环境像素的亮度（核函数周围的像素的亮度有关），将像素设置为1或者0。 负数 offset 值将更多像素设置为1，而正值仅将最强对比度设置为1。 设置 invert 以反转二进制图像的结果输出。 mask 是另一个用作绘图操作的像素级掩码的图像。掩码应该是一个只有黑色或白色像素的图像，并且应该与你正在绘制的 image 大小相同。 仅掩码中设置的像素被修改。 返回图像对象，以便您可以使用 . 表示法调用另一个方法。 不支持压缩图像和bayer图像。 此方法在OpenMV Cam M4 上不可用。 image.morph(size, kernel, mul=Auto, add=0) 通过过滤器内核对图像进行卷积。这允许您对图像执行通用卷积。 size 将内核的大小控制为((size2)+1)x((size2)+1)像素。 kernel 用来卷积图像的内核，可为一个元组或一个取值[-128:127]的列表。 mul 是用以与卷积像素结果相乘的数字。若不设置，则默认一个值，该值将防止卷积输出中的缩放。 add 是用来与每个像素卷积结果相加的数值。 mul 可进行全局对比度调整，add可进行全局亮度调整。 如果你想在滤波器的输出上自适应地设置阈值，你可以传递 threshold=True 参数来启动图像的自适应阈值处理， 他根据环境像素的亮度（核函数周围的像素的亮度有关），将像素设置为1或者0。 负数 offset 值将更多像素设置为1，而正值仅将最强对比度设置为1。 设置 invert 以反转二进制图像的结果输出。 mask 是另一个用作绘图操作的像素级掩码的图像。掩码应该是一个只有黑色或白色像素的图像，并且应该与你正在绘制的 image 大小相同。 仅掩码中设置的像素被修改。 返回图像对象，以便您可以使用 . 表示法调用另一个方法。 不支持压缩图像和bayer图像。 image.gaussian(size[, unsharp=False[, mul[, add=0[, threshold=False[, offset=0[, invert=False[, mask=None]]]]]]]) 通过平滑高斯核对图像进行卷积。 size 是内核的大小。取1 (3x3 内核)、2 (5x5 内核)或更高值。 如果 unsharp 设置为True，那么这种方法不会仅进行高斯滤波操作，而是执行非锐化掩模操作，从而提高边缘的图像清晰度。 mul 是用以与卷积像素结果相乘的数字。若不设置，则默认一个值，该值将防止卷积输出中的缩放。 add 是用来与每个像素卷积结果相加的数值。 mul 可进行全局对比度调整，add可进行全局亮度调整。 如果你想在滤波器的输出上自适应地设置阈值，你可以传递 threshold=True 参数来启动图像的自适应阈值处理， 他根据环境像素的亮度（核函数周围的像素的亮度有关），将像素设置为1或者0。 负数 offset 值将更多像素设置为1，而正值仅将最强对比度设置为1。 设置 invert 以反转二进制图像的结果输出。 mask 是另一个用作绘图操作的像素级掩码的图像。掩码应该是一个只有黑色或白色像素的图像，并且应该与你正在绘制的 image 大小相同。 仅掩码中设置的像素被修改。 返回图像对象，以便您可以使用 . 表示法调用另一个方法。 不支持压缩图像和bayer图像。 此方法在OpenMV Cam M4 上不可用。 image.laplacian(size[, sharpen=False[, mul[, add=0[, threshold=False[, offset=0[, invert=False[, mask=None]]]]]]]) 通过边缘检测拉普拉斯核来对图像进行卷积。 size 是内核的大小。取1 (3x3 内核)、2 (5x5 内核)或更高值。 如果 sharpen 被设置为True，那么这种方法将改为锐化图像，而不是仅输出未经过阈值处理的边缘检测图像。 增加内核大小然后增加图像清晰度。 mul 是用以与卷积像素结果相乘的数字。若不设置，则默认一个值，该值将防止卷积输出中的缩放。 add 是用来与每个像素卷积结果相加的数值。 mul 可进行全局对比度调整，add可进行全局亮度调整。 如果你想在滤波器的输出上自适应地设置阈值，你可以传递 threshold=True 参数来启动图像的自适应阈值处理， 他根据环境像素的亮度（核函数周围的像素的亮度有关），将像素设置为1或者0。 负数 offset 值将更多像素设置为1，而正值仅将最强对比度设置为1。 设置 invert 以反转二进制图像的结果输出。 mask 是另一个用作绘图操作的像素级掩码的图像。掩码应该是一个只有黑色或白色像素的图像，并且应该与你正在绘制的 image 大小相同。 仅掩码中设置的像素被修改。 返回图像对象，以便您可以使用 . 表示法调用另一个方法。 不支持压缩图像和bayer图像。 此方法在OpenMV Cam M4 上不可用。 image.bilateral(size[, color_sigma=0.1[, space_sigma=1[, threshold=False[, offset=0[, invert=False[, mask=None]]]]]]) 通过双边滤波器对图像进行卷积。 双边滤波器使图像平滑，同时保持图像中的边缘。 size 是内核的大小。取1 (3x3 内核)、2 (5x5 内核)或更高值。 color_sigma 控制使用双边滤波器匹配颜色的接近程度。增加此值可增加颜色模糊。 space_sigma 控制像素在空间方面相互模糊的程度。增加此值可增加像素模糊。 如果你想在滤波器的输出上自适应地设置阈值，你可以传递 threshold=True 参数来启动图像的自适应阈值处理， 他根据环境像素的亮度（核函数周围的像素的亮度有关），将像素设置为1或者0。 负数 offset 值将更多像素设置为1，而正值仅将最强对比度设置为1。 设置 invert 以反转二进制图像的结果输出。 mask 是另一个用作绘图操作的像素级掩码的图像。掩码应该是一个只有黑色或白色像素的图像，并且应该与你正在绘制的 image 大小相同。 仅掩码中设置的像素被修改。 返回图像对象，以便您可以使用 . 表示法调用另一个方法。 不支持压缩图像和bayer图像。 此方法在OpenMV Cam M4 上不可用。 image.cartoon(size[, seed_threshold=0.05[, floating_threshold=0.05[, mask=None]]]) 漫游图像并使用flood-fills算法填充图像中的所有像素区域。 这通过使图像的所有区域中的颜色变平来有效地从图像中去除纹理。 为了获得最佳效果，图像应具有大量对比度，以使区域不会太容易相互渗透。 seed_threshold 控制填充区域中的像素与原始起始像素的差异。 floating_threshold 控制填充区域中的像素与任何相邻像素的差异。 mask 是另一个用作绘图操作的像素级掩码的图像。掩码应该是一个只有黑色或白色像素的图像，并且应该与你正在绘制的 image 大小相同。 仅掩码中设置的像素被修改。 返回图像对象，以便您可以使用 . 表示法调用另一个方法。 不支持压缩图像和bayer图像。 此方法在OpenMV Cam M4 上不可用。 image.remove_shadows([image]) 从该图像中移除阴影。 如果当前图像没有“无阴影”版本出现，则此方法将尝试从图像中去除阴影，但没有真实无阴影的图像依据。 这种算法适用于去除平坦均匀背景中的阴影。 请注意，此方法需要多秒才能运行，并且仅适用于实时移除阴影，动态生成无阴影版本的图像。 该算法的未来版本将适用于更多的环境，但同样缓慢。 如果当前图像有“无阴影”版本出现，则此方法将使用“真实源”背景无阴影图像去除图像中的所有阴影以滤除阴影。 非阴影像素不会被过滤掉，因此您可以向场景中添加以前不存在的新对象，并且这些对象中的任何非阴影像素都将显示出来。 返回图像对象，以便您可以使用 . 表示法调用另一个方法。 只支持RGB565图像。 此方法在OpenMV Cam M4 上不可用。 image.chrominvar() 从图像中删除照明效果，仅留下颜色渐变。比 image.illuminvar() 更快但受阴影影响。 返回图像对象，以便您可以使用 . 表示法调用另一个方法。 仅支持RGB565图像。 此方法在OpenMV Cam M4 上不可用。 image.illuminvar() 从图像中删除照明效果，仅留下颜色渐变。比 image.chrominvar() 慢但不受阴影影响。 返回图像对象，以便您可以使用 . 表示法调用另一个方法。 仅支持RGB565图像。 此方法在OpenMV Cam M4 上不可用。 image.linpolar([reverse=False]) 图像从笛卡尔坐标到线性极坐标重新投影。 设置 reverse = True 可以在相反的方向重新投影。 线性极坐标重新投影将图像旋转转换为x平移。 不支持压缩图像。 此方法在OpenMV Cam M4 上不可用。 image.logpolar([reverse=False]) 图像从笛卡尔坐标到对数极坐标重新投影。 设置 reverse = True 可以在相反的方向重新投影。 对数极坐标重新投影将图像的旋转转换为x平移和缩放到y平移。 不支持压缩图像。 此方法在OpenMV Cam M4 上不可用。 image.lens_corr([strength=1.8[, zoom=1.0]]) 进行镜头畸变校正，以去除镜头造成的图像鱼眼效果。 strength 是一个浮点数，该值确定了对图像进行去鱼眼效果的程度。在默认情况下，首先试用取值1.8，然后调整这一数值使图像显示最佳效果。 zoom 是在对图像进行缩放的数值。默认值为 1.0 。 返回图像对象，以便您可以使用 . 表示法调用另一个方法。 不支持压缩图像和bayer图像。 img.rotation_corr([x_rotation=0.0[, y_rotation=0.0[, z_rotation=0.0[, x_translation=0.0[, y_translation=0.0[, zoom=1.0]]]]]]) 通过执行帧缓冲区的3D旋转来纠正图像中的透视问题。 x_rotation 是围绕x轴在帧缓冲器中旋转图像的度数（这使图像上下旋转）。 y_rotation 是帧缓冲区中围绕y轴旋转图像的度数（即左右旋转图像）。 z_rotation 是围绕z轴在帧缓冲器中旋转图像的度数（即，使图像旋转到适当位置）。 x_translation 是旋转后将图像移动到左侧或右侧的单位数。因为这个变换是应用在三维空间的，单位不是像素… y_translation 是旋转后将图像上移或下移的单位数。因为这个变换是应用在三维空间的，单位不是像素… zoom 是通过图像缩放的量。默认情况下1.0。 返回图像对象，以便您可以使用 . 表示法调用另一个方法。 不支持压缩图像和bayer图像。 此方法在OpenMV Cam M4 上不可用。 image.get_similarity(image) 返回一个“相似度”对象，描述两幅图像使用SSIM算法来比较两幅图像之间的8x8像素色块的相似度。 image 可以是图像对象，未压缩图像文件的路径(bmp/pgm/ppm)，也可以是标量值。 如果标量值，该值可以是RGB888元组或基础像素值(例如，灰度图像的8位灰度级或RGB图像的字节反转RGB565值)。 不支持压缩图像和bayer图像。 此方法在OpenMV Cam M4 上不可用。 image.get_histogram([thresholds[, invert=False[, roi[, bins[, l_bins[, a_bins[, b_bins]]]]]]]) 在 roi 的所有颜色通道上进行标准化直方图运算，并返回 histogram 对象。 请参考 histogram 对象以获取更多信息。您也可以使用 image.get_hist 或 image.histogram 来调用这一方法。如果传递 thresholds 列表，则直方图信息将仅从阈值列表中的像素计算得出。 thresholds 必须是元组列表。 [(lo, hi), (lo, hi), ..., (lo, hi)] 定义你想追踪的颜色范围。 对于灰度图像，每个元组需要包含两个值 - 最小灰度值和最大灰度值。 仅考虑落在这些阈值之间的像素区域。 对于RGB565图像，每个元组需要有六个值(l_lo，l_hi，a_lo，a_hi，b_lo，b_hi) - 分别是LAB L，A和B通道的最小值和最大值。 为方便使用，此功能将自动修复交换的最小值和最大值。 此外，如果元组大于六个值，则忽略其余值。相反，如果元组太短，则假定其余阈值处于最大范围。 注解 获取所跟踪对象的阈值，只需在IDE帧缓冲区中选择（单击并拖动）跟踪对象。 直方图会相应地更新到所在区域。然后只需写下颜色分布在每个直方图通道中起始与下降位置。 这些将是 thresholds 的低值和高值。 由于上下四分位数据相差微小，故手动确定阈值为佳。 您还可以通过进入OpenMV IDE中的 工具 ->机器视觉 ->阈值编辑器 并从GUI窗口中拖动滑块来确定颜色阈值。 invert 反转阈值操作，像素在已知颜色范围之外进行匹配，而非在已知颜色范围内。 除非您需要使用颜色统计信息进行高级操作，否则只需使用image.get_statistics() 方法代替此方法查看图像中的像素区域。 roi 是感兴趣区域的矩形元组(x，y，w，h)。如果未指定，ROI即整个图像的图像矩形。 操作范围仅限于 roi 区域内的像素。 bins 和其他bin是用于直方图通道的箱数。对于灰度图像，使用 bins ， 对于RGB565图像，使用其他每个通道。每个通道的bin计数必须大于2。 另外，将bin计数设置为大于每个通道的唯一像素值的数量是没有意义的。 默认情况下，直方图将具有每个通道的最大bin数。 不支持压缩图像和bayer图像。 image.get_statistics([thresholds[, invert=False[, roi[, bins[, l_bins[, a_bins[, b_bins]]]]]]]) 计算 roi 中每个颜色通道的平均值、中值、众值、标准偏差、最小值、最大值、下四分值和上四分值，并返回一个数据对象。 请参见 statistics 对象以获取更多信息。您也可以使用 image.get_stats 或 image.statistics 来调用这一方法。 如果传递 thresholds 列表，则直方图信息将仅从阈值列表中的像素计算得出。 thresholds 必须是元组列表。 [(lo, hi), (lo, hi), ..., (lo, hi)] 定义你想追踪的颜色范围。 对于灰度图像，每个元组需要包含两个值 - 最小灰度值和最大灰度值。 仅考虑落在这些阈值之间的像素区域。 对于RGB565图像，每个元组需要有六个值(l_lo，l_hi，a_lo，a_hi，b_lo，b_hi) - 分别是LAB L，A和B通道的最小值和最大值。 为方便使用，此功能将自动修复交换的最小值和最大值。 此外，如果元组大于六个值，则忽略其余值。相反，如果元组太短，则假定其余阈值处于最大范围。 注解 获取所跟踪对象的阈值，只需在IDE帧缓冲区中选择（单击并拖动）跟踪对象。 直方图会相应地更新到所在区域。然后只需写下颜色分布在每个直方图通道中起始与下降位置。 这些将是 thresholds 的低值和高值。 由于上下四分位数据相差微小，故手动确定阈值为佳。 您还可以通过进入OpenMV IDE中的 工具 ->机器视觉 ->阈值编辑器 并从GUI窗口中拖动滑块来确定颜色阈值。 invert 反转阈值操作，像素在已知颜色范围之外进行匹配，而非在已知颜色范围内。 您可以在需要获取图像中一个像素区域信息时使用这一方法。例如：若您想用帧差法来检测运动时， 您需要使用这一方法来确定图像颜色通道的变化，从而触发运动检测阈值。 roi 是感兴趣区域的矩形元组(x，y，w，h)。如果未指定，ROI即整个图像的图像矩形。 操作范围仅限于 roi 区域内的像素。 bins 和其他bin是用于直方图通道的箱数。对于灰度图像，使用 bins ， 对于RGB565图像，使用其他每个通道。每个通道的bin计数必须大于2。 另外，将bin计数设置为大于每个通道的唯一像素值的数量是没有意义的。 默认情况下，直方图将具有每个通道的最大bin数。 不支持压缩图像和bayer图像。 image.get_regression(thresholds[, invert=False[, roi[, x_stride=2[, y_stride=1[, area_threshold=10[, pixels_threshold=10[, robust=False]]]]]]]) 对图像所有阈值像素进行线性回归计算。这一计算通过最小二乘法进行，通常速度较快，但不能处理任何异常值。 若 robust 为True，则将使用泰尔指数。泰尔指数计算图像中所有阈值像素间的所有斜率的中值。 若在阈值转换后设定太多像素，即使在80x60的图像上，这一N^2操作也可能将您的FPS降到5以下。 但是，只要阈值转换后的进行设置的像素数量较少，即使在超过30%的阈值像素为异常值的情况下，线性回归也依然有效。 这一方法返回的是一个 image.line 对象。如何轻松运用直线对象， 详见下博文： https://openmv.io/blogs/news/linear-regression-line-following thresholds 必须是元组列表。 [(lo, hi), (lo, hi), ..., (lo, hi)] 定义你想追踪的颜色范围。 对于灰度图像，每个元组需要包含两个值 - 最小灰度值和最大灰度值。 仅考虑落在这些阈值之间的像素区域。 对于RGB565图像，每个元组需要有六个值(l_lo，l_hi，a_lo，a_hi，b_lo，b_hi) - 分别是LAB L，A和B通道的最小值和最大值。 为方便使用，此功能将自动修复交换的最小值和最大值。 此外，如果元组大于六个值，则忽略其余值。相反，如果元组太短，则假定其余阈值处于最大范围。 获取所跟踪对象的阈值，只需在IDE帧缓冲区中选择（单击并拖动）跟踪对象。 直方图会相应地更新到所在区域。然后只需写下颜色分布在每个直方图通道中起始与下降位置。 这些将是 thresholds 的低值和高值。 由于上下四分位数据相差微小，故手动确定阈值为佳。 您还可以通过进入OpenMV IDE中的 工具 ->机器视觉 ->阈值编辑器 并从GUI窗口中拖动滑块来确定颜色阈值。 invert 反转阈值操作，像素在已知颜色范围之外进行匹配，而非在已知颜色范围内。 roi 是感兴趣区域的矩形元组(x，y，w，h)。如果未指定，ROI即整个图像的图像矩形。 操作范围仅限于 roi 区域内的像素。 x_stride 是调用函数时要跳过的x像素数。 y_stride 是调用函数时要跳过的y像素数。 如果回归后的边界框区域小于 area_threshold ，则返回None。 如果回归后的像素数小于 pixel_threshold ，则返回None。 不支持压缩图像和bayer图像。 image.find_blobs(thresholds[, invert=False[, roi[, x_stride=2[, y_stride=1[, area_threshold=10[, pixels_threshold=10[, merge=False[, margin=0[, threshold_cb=None[, merge_cb=None]]]]]]]]]]) 查找图像中所有色块，并返回一个包括每个色块的色块对象的列表。请观察 image.blob 对象以获取更多信息。 thresholds 必须是元组列表。 [(lo, hi), (lo, hi), ..., (lo, hi)] 定义你想追踪的颜色范围。 对于灰度图像，每个元组需要包含两个值 - 最小灰度值和最大灰度值。 仅考虑落在这些阈值之间的像素区域。 对于RGB565图像，每个元组需要有六个值(l_lo，l_hi，a_lo，a_hi，b_lo，b_hi) - 分别是LAB L，A和B通道的最小值和最大值。 为方便使用，此功能将自动修复交换的最小值和最大值。 此外，如果元组大于六个值，则忽略其余值。相反，如果元组太短，则假定其余阈值处于最大范围。 注解 获取所跟踪对象的阈值，只需在IDE帧缓冲区中选择（单击并拖动）跟踪对象。 直方图会相应地更新到所在区域。然后只需写下颜色分布在每个直方图通道中起始与下降位置。 这些将是 thresholds 的低值和高值。 由于上下四分位数据相差微小，故手动确定阈值为佳。 您还可以通过进入OpenMV IDE中的 工具 ->机器视觉 ->阈值编辑器 并从GUI窗口中拖动滑块来确定颜色阈值。 invert 反转阈值操作，像素在已知颜色范围之外进行匹配，而非在已知颜色范围内。 roi 是感兴趣区域的矩形元组(x，y，w，h)。如果未指定，ROI即整个图像的图像矩形。 操作范围仅限于 roi 区域内的像素。 x_stride 是查找某色块时需要跳过的x像素的数量。找到色块后，直线填充算法将精确像素。 若已知色块较大，可增加 x_stride 来提高查找色块的速度。 y_stride 是查找某色块时需要跳过的y像素的数量。找到色块后，直线填充算法将精确像素。 若已知色块较大，可增加 y_stride 来提高查找色块的速度。 若一个色块的边界框区域小于 area_threshold ，则会被过滤掉。 若一个色块的像素数小于 pixel_threshold ，则会被过滤掉。 merge 若为True，则合并所有没有被过滤掉的色块，这些色块的边界矩形互相交错重叠。 margin 可在相交测试中用来增大或减小色块边界矩形的大小。例如：边缘为1、相互间边界矩形为1的色块将被合并。 合并色块使颜色代码追踪得以实现。每个色块对象有一个代码值 code ，该值为一个位向量。 例如：若您在 image.find_blobs 中输入两个颜色阈值，则第一个阈值代码为1，第二个代码为2（第三个代码为4，第四个代码为8，以此类推）。 合并色块对所有的code使用逻辑或运算，以便您知道产生它们的颜色。这使得您可以追踪两个颜色，若您用两种颜色得到一个色块对象，则可能是一种颜色代码。 若您使用严格的颜色范围，无法完全追踪目标对象的所有像素，您可能需要合并色块。 最后，若您想要合并色块，但不想两种不同阈值颜色的色块被合并，只需分别两次调用 image.find_blobs ，不同阈值色块就不会被合并。 threshold_cb 可设置为用以调用阈值筛选后的每个色块的函数，以便将其从将要合并的色块列表中过滤出来。 回调函数将收到一个参数：要被筛选的色块对象。然后回调函数需返回True以保留色块或返回False以过滤色块。 merge_cb 可设置为用以调用两个即将合并的色块的函数，以禁止或准许合并。回调函数将收到两个参数—两个将被合并的色块对象。 回调函数须返回True以合并色块，或返回False以防止色块合并。 不支持压缩图像和bayer图像。 image.find_lines([roi[, x_stride=2[, y_stride=1[, threshold=1000[, theta_margin=25[, rho_margin=25]]]]]]) 使用霍夫变换查找图像中的所有直线。返回一个 image.line 对象的列表。 roi 是感兴趣区域的矩形元组(x，y，w，h)。如果未指定，ROI即整个图像的图像矩形。操作范围仅限于 roi 区域内的像素。 x_stride 是霍夫变换时需要跳过的x像素的数量。若已知直线较大，可增加 x_stride 。 y_stride 是霍夫变换时需要跳过的y像素的数量。若已知直线较大，可增加 y_stride 。 threshold 控制从霍夫变换中监测到的直线。只返回大于或等于 threshold 的直线。 应用程序的正确的 threshold 值取决于图像。注意：一条直线的大小(magnitude)是组成直线所有索贝尔滤波像素大小的总和。 theta_margin 控制所监测的直线的合并。 直线角度为 theta_margin 的部分和直线p值为 rho_margin 的部分合并。 rho_margin 控制所监测的直线的合并。 直线角度为 theta_margin 的部分和直线p值为 rho_margin 的部分合并。 该方法通过在图像上运行索贝尔滤波器，并利用该滤波器的幅值和梯度响应来进行霍夫变换。 无需对图像进行任何预处理。但是，清理图像过滤器可得到更为稳定的结果。 不支持压缩图像和bayer图像。 此方法在OpenMV Cam M4 上不可用。 image.find_line_segments([roi[, merge_distance=0[, max_theta_difference=15]]]) 使用霍夫转换来查找图像中的线段。返回一个 image.line 对象的列表。 roi 是一个用以复制的矩形的感兴趣区域(x, y, w, h)。如果未指定， ROI 即图像矩形。操作范围仅限于roi区域内的像素。 merge_distance 指定两条线段之间的可以相互分开而不被合并的最大像素数。 max_theta_difference 是上面 merge_distancede 要合并的的两个线段的最大角度差值。 此方法使用LSD库（也被OpenCV使用）来查找图像中的线段。这有点慢，但是非常准确，线段不会跳跃。 不支持压缩图像和bayer图像。 此方法在OpenMV Cam M4 上不可用。 image.find_circles([roi[, x_stride=2[, y_stride=1[, threshold=2000[, x_margin=10[, y_margin=10[, r_margin=10]]]]]]]) 使用霍夫变换在图像中查找圆。返回一个 image.circle 对象列表（见上）。 roi 是一个用以复制的矩形的感兴趣区域(x, y, w, h)。如果未指定， ROI 即图像矩形。操作范围仅限于roi区域内的像素。 x_stride 是霍夫变换时需要跳过的x像素的数量。若已知圆较大，可增加 x_stride 。 y_stride 是霍夫变换时需要跳过的y像素的数量。若已知圆较大，可增加 y_stride 。 threshold 控制从霍夫变换中监测到的圆。只返回大于或等于 threshold 的圆。 应用程序的正确的 threshold 值取决于图像。注意：一个圆的大小(magnitude)是组成圆所有索贝尔滤波像素大小的总和。 x_margin 控制所检测的圆的合并。 圆像素为 x_margin 、 y_margin 和 r_margin 的部分合并。 y_margin 控制所检测的圆的合并。 圆像素为 x_margin 、 y_margin 和 r_margin 的部分合并。 r_margin 控制所检测的圆的合并。 圆像素为 x_margin 、 y_margin 和 r_margin 的部分合并。 不支持压缩图像和bayer图像。 此方法在OpenMV Cam M4 上不可用。 image.find_rects([roi=Auto, threshold=10000]) 使用用于查找AprilTAg的相同的quad detection算法来查找图像中的矩形。 最适用与背景形成鲜明对比的矩形。AprilTag的quad detection可以处理任意缩放/旋转/剪切的矩形。 返回一个 image.rect 对象的列表。 roi 是一个用以复制的矩形的感兴趣区域(x, y, w, h)。如果未指定， ROI即图像矩形。操作范围仅限于 roi 区域内的像素。 边界大小（通过在矩形边缘上的所有像素上滑动索贝尔算子并相加该值）小于 threshold 的矩形会从返回列表中过滤出来。 threshold 的正确值取决于您的应用程序/场景。 不支持压缩图像和bayer图像。 此方法在OpenMV Cam M4 上不可用。 image.find_qrcodes([roi]) 查找 roi 内的所有二维码并返回一个 image.qrcode 对象的列表。 请参考 image.qrcode 对象以获取更多信息。 为使这一方法成功运行，图像上二维码需比较平展。通过使用 sensor.set_windowing 函数在镜头中心放大、 image.lens_corr 函数来消解镜头的桶形畸变或通过更换视野较为狭小的镜头， 您可得到一个不受镜头畸变影响的更为平展的二维码。有些机器视觉镜头不会造成桶形失真，但是其造价远比OpenMV提供的标准镜片高，这种镜头为无畸变镜头。 roi 是一个用以复制的矩形的感兴趣区域(x, y, w, h)。如果未指定，ROI即整幅图像的图像矩形。 操作范围仅限于 roi 区域内的像素。 不支持压缩图像和bayer图像。 此方法在OpenMV Cam M4 上不可用。 image.find_apriltags([roi[, families=image.TAG36H11[, fx[, fy[, cx[, cy]]]]]]) 查找 roi 内的所有AprilTag, 并返回一个 image.apriltag 对象的列表。请参考 image.apriltag 对象以获取更多信息。 与二维码相比，AprilTags可在更远距离、较差光线和更扭曲的图像环境下被检测到。 AprilTags可应对所有种类的图像失真问题，而二维码并不能。也就是说，AprilTags只能将数字ID编码作为其有效载荷。 AprilTags也可用于本地化。每个 image.apriltag 对象都从摄像机返回其三维位置信息和旋转角度。 位置信息由 fx 、 fy 、 cx 和 cy 决定，分别为X和Y方向上图像的焦距和中心点。 使用OpenMV IDE内置的标签生成器工具来创建AprilTags。标签生成器可创建可打印的8.5“x11”AprilTags。 roi 是一个用以复制的矩形的感兴趣区域(x, y, w, h)。如果未指定，ROI即整幅图像的图像矩形。 操作范围仅限于 roi 区域内的像素。 families 是要解码的标签家族的位掩码。是一个逻辑或： image.TAG16H5 image.TAG25H7 image.TAG25H9 image.TAG36H10 image.TAG36H11 image.ARTOOLKIT 默认设置为最好用的 image.TAG36H11 标签家族。注意：每启用一个标签家族， find_apriltags 的速度都会略有放慢。 fx 是以像素为单位的相机x方向的焦距。标准OpenMV Cam的值为(2.8 / 3.984) * 656， 该值通过毫米计的焦距值除以X方向上感光元件的长度，再乘以X方向上感光元件的像素数量得来（对OV7725感光元件而言）。 fy 是以像素为单位的相机y方向的焦距。标准OpenMV Cam的值为(2.8 / 2.952) * 488， 该值通过毫米计的焦距值除以Y方向上感光元件的长度，再乘以Y方向上感光元件的像素数量得来（对OV7725感光元件而言）。 cx 是图像的中心，即 image.width()/2 ，而非 roi.w()/2 。 cy 是图像的中心，即 image.height()/2，而非 roi.h()/2 。 不支持压缩图像和bayer图像。 此方法在OpenMV Cam M4 上不可用。 image.find_datamatrices([roi[, effort=200]]) 查找 roi 内的所有数据矩阵并返回一个 image.datamatrix 对象的列表。 请参考 image.datamatrix 对象以获取更多信息。 为使这一方法成功运行，图像上矩形码需比较平展。通过使用 sensor.set_windowing 函数在镜头中心放大、 image.lens_corr 函数来消解镜头的桶形畸变或通过更换视野较为狭小的镜头，您可得到一个不受镜头畸变影响的更为平展的矩形码。 有些机器视觉镜头不会造成桶形失真，但是其造价远比OpenMV提供的标准镜片高，这种镜头是无畸变镜头。 roi 是一个用以复制的矩形的感兴趣区域(x, y, w, h)。如果未指定，ROI即整幅图像的图像矩形。操作范围仅限于 roi 区域内的像素。 effort 控制用于查找矩形码匹配的时间。默认值为200应该适用于所有用例。 但是您也可能以帧速率为代价增加检测，或以检测为代价增加帧速率。 注意：若 effort 设置在约160以下，您就无法进行任何检测；相反，您可将其设置为您需要的任何高值，但是若设置值高于240，检测率将不会继续随之提高。 不支持压缩图像和bayer图像。 此方法在OpenMV Cam M4 上不可用。 image.find_barcodes([roi]) 查找 roi 内所有一维条形码并返回一个 image.barcode 对象列表。 请参考 image.barcode 对象以获取更多信息。 为了获得最佳效果，请使用长640、宽40/80／160窗口。垂直程度越低，运行速度越快。由于条形码是线性一维图像，所以只需在一个方向上有较高分辨率， 而在另一方向上只需较低分辨率。注意：该函数进行水平和垂直扫描，所以您可使用宽40/80／160、长480的窗口。 最后，请一定调整镜头，这样条形码会定位在焦距产生最清晰图像的地方。模糊条码无法被解码。 该函数支持所有一维条形码： image.EAN2 image.EAN5 image.EAN8 image.UPCE image.ISBN10 image.UPCA image.EAN13 image.ISBN13 image.I25 image.DATABAR (RSS-14) image.DATABAR_EXP (RSS-Expanded) image.CODABAR image.CODE39 image.PDF417 image.CODE93 image.CODE128 roi 是一个用以复制的矩形的感兴趣区域(x, y, w, h)。如果未指定，ROI即整幅图像的图像矩形。操作范围仅限于 roi 区域内的像素。 不支持压缩图像和bayer图像。 此方法在OpenMV Cam M4 上不可用。 image.find_displacement(template[, roi[, template_roi[, logpolar=False]]]) 从模板中查找此图像的变换偏移量。 这种方法可以用来做光流。 此方法返回一个 image.displacement 对象，其中包含使用相位相关的位移计算结果。 roi 是需要处理的矩形区域（x，y，w，h）。如果未指定，则等于图像矩形。 template_roi 是需要处理的矩形区域（x，y，w，h）。如果未指定，则等于图像矩形。 roi 和 template roi必须具有相同的w/h，但x/y可以为图像任意位置。您可以在较大图像上滑动较小的rois以获得光流渐变图像. image.find_displacement 通常计算两个图像之间的x/y平移。但是，如果您设置 logpolar = True ， 它将会在两个图像之间找到旋转和缩放比例的变化。相同的 image.displacement 对象结果两种可能的反馈。 不支持压缩图像和bayer图像。 注解 请在长宽一致的图像（例如sensor.B64X64）上使用此方法。 此方法在OpenMV Cam M4 上不可用。 image.find_number(roi) 运行在MINST数据集上训练的LENET-6 CNN（卷积神经网络），以检测位于图像上任何位置的28x28 ROI中的数字。 返回一个包含整数和浮点数的元组，表示检测到的数字（0-9）和检测的置信度（0-1）。 roi 是感兴趣区域的矩形元组(x，y，w，h)。如果未指定，ROI即整个图像的图像矩形。 操作范围仅限于 roi 区域内的像素。 仅支持灰度图像。 注解 这种方法是实验性的。如果未来运行使用Caffe在PC上训练的任何CNN，这种方法可能会删除。 最新3.0.0版本固件已删除此函数。 此方法在OpenMV Cam M4 上不可用。 image.classify_object(roi) 在图像的ROI上运行CIFAR-10 CNN，以检测飞机，汽车，鸟类，猫，鹿，狗，青蛙，马，船和卡车。 此方法在内部自动将图像缩放到32x32以馈送到CNN。 roi 是感兴趣区域的矩形元组(x，y，w，h)。如果未指定，ROI即整个图像的图像矩形。 操作范围仅限于 roi 区域内的像素。 仅支持RGB565图像。 注解 这种方法是实验性的。如果未来运行使用Caffe在PC上训练的任何CNN，这种方法可能会删除。 此方法在OpenMV Cam M4 上不可用。 image.find_template(template, threshold[, roi[, step=2[, search=image.SEARCH_EX]]]) 尝试使用归一化互相关(NCC)算法在图像中找到第一个模板匹配的位置。返回匹配位置的边界框元组(x, y, w, h)，否则返回None。 template 是一个与这个图像对象相匹配的小图像对象。注意：两图像须都为灰度图。 threshold 是浮点数（0.0-1.0），其中较小的值在提高检测速率同时增加误报率。相反，较高的值会降低检测速率，同时降低误报率。 roi 是感兴趣区域的矩形元组(x，y，w，h)。如果未指定，ROI即整个图像的图像矩形。 操作范围仅限于 roi 区域内的像素。 step 是查找模板时需要跳过的像素数量。跳过像素可大大提高算法运行的速度。该方法只适用于SERACH_EX模式下的算法。 search 可为 image.SEARCH_DS or image.SEARCH_EX. image.SEARCH_DS 搜索模板所用算法较 image.SEARCH_EX 更快，但若模板位于图像边缘周围，可能无法成功搜索。 image.SEARCH_EX 可对图像进行较为详尽的搜索，但其运行速度远低于 image.SEARCH_DS 。 仅支持灰度图像。 image.find_features(cascade[, threshold=0.5[, scale=1.5[, roi]]]) 这个方法搜索与Haar Cascade匹配的所有区域的图像，并返回一个关于这些特征的边界框矩形元组(x，y，w，h)的列表。若未发现任何特征，则返回一个空白列表。 cascade 是一个Haar Cascade对象。详细信息请查看 image.HaarCascade() 。 threshold 是浮点数（0.0-1.0），其中较小的值在提高检测速率同时增加误报率。相反，较高的值会降低检测速率，同时降低误报率。 scale 是一个必须大于1.0的浮点数。较高的比例因子运行更快，但其图像匹配相应较差。理想值介于1.35-1.5之间。 roi 是感兴趣区域的矩形元组(x，y，w，h)。如果未指定，ROI即整个图像的图像矩形。 操作范围仅限于 roi 区域内的像素。 仅支持灰度图像。 image.find_eye(roi) 在眼睛周围的感兴趣区域(x, y, w, h)查找瞳孔。返回一个包含图像中瞳孔(x，y)位置的元组。若未发现瞳孔，则返回(0,0)。 使用这一函数之前，需首先使用 image.find_features() 和Haar算子 frontalface 来搜索某人面部。 然后使用 image.find_features 和Haar算子 find_eye 在面部搜索眼睛。 最后，在调用 image.find_features 函数后返回的每个眼睛ROI上调用这一方法，以得到瞳孔的坐标。 roi 是感兴趣区域的矩形元组(x，y，w，h)。如果未指定，ROI即整个图像的图像矩形。 操作范围仅限于 roi 区域内的像素。 仅支持灰度图像。 image.find_lbp(roi) 从ROI元组(x, y, w, h)中提取LBP（局部二值模式）键点。您可以使用 image.match_descriptor 函数来比较两组关键点，以获取匹配距离。 roi 是感兴趣区域的矩形元组(x，y，w，h)。如果未指定，ROI即整个图像的图像矩形。 操作范围仅限于 roi 区域内的像素。 仅支持灰度图像。 image.find_keypoints([roi[, threshold=20[, normalized=False[, scale_factor=1.5[, max_keypoints=100[, corner_detector=image.CORNER_AGAST]]]]]]) 从ROI元组(x, y, w, h)中提取ORB键点。您可以使用 image.match_descriptor 函数来比较两组关键点，以获取匹配区域。若未发现关键点，则返回None。 roi 是感兴趣区域的矩形元组(x，y，w，h)。如果未指定，ROI即整个图像的图像矩形。 操作范围仅限于 roi 区域内的像素。 threshold 是控制提取的数量的数字（取值0-255）。对于默认的AGAST角点检测器，该值应在20左右。 对于FAST角点检测器，该值约为60-80。阈值越低，您提取的角点越多。 normalized 是布尔值。若为True，在多分辨率下关闭提取键点。 若您不关心处理扩展问题，且希望算法运行更快，就将之设置为True。 scale_factor 是一个必须大于1.0的浮点数。较高的比例因子运行更快，但其图像匹配相应较差。理想值介于1.35-1.5之间。 max_keypoints 是一个键点对象所能容纳的键点最大数量。若键点对象过大导致内存问题，请降低该值。 corner_detector 是从图像中提取键点所使用的角点检测器算法。 可为 image.CORNER_FAST 或 image.CORNER_AGAST 。FAST角点检测器运行速度更快，但其准确度较低。 仅支持灰度图像。 image.find_edges(edge_type[, threshold]) 将图像变为黑白，仅将边缘保留为白色像素。 image.EDGE_SIMPLE - 简单的阈值高通滤波算法 image.EDGE_CANNY - Canny边缘检测算法 threshold 是一个包含一个低阈值和一个高阈值的二值元组。您可以通过调整该值来控制边缘质量。 默认为 (100, 200)。 仅支持灰度图像。 find_hog([roi[, size=8]]) 用HOG（定向梯度直方图）线替换ROI中的像素。 roi 是感兴趣区域的矩形元组(x，y，w，h)。如果未指定，ROI即整个图像的图像矩形。 操作范围仅限于 roi 区域内的像素。 仅支持灰度图像。 此方法在OpenMV Cam M4 上不可用。 常量 image.SEARCH_EX 详尽的模板匹配搜索。 image.SEARCH_DS 更快的模板匹配搜索。 image.EDGE_CANNY 使用Canny边缘检测算法对图像进行边缘检测。 image.EDGE_SIMPLE 使用阈值高通滤波算法对图像进行边缘检测。 image.CORNER_FAST 用于ORB键点的高速低准确率角点检测算法 image.CORNER_AGAST 用于ORB键点的低速高准确率算法。 image.TAG16H5 TAG1H5标签群的位掩码枚举。用于AprilTags。 image.TAG25H7 TAG25H7标签群的位掩码枚举。用于AprilTags。 image.TAG25H9 TAG25H9标签群的位掩码枚举。用于AprilTags。 image.TAG36H10 TAG36H10标签群的位掩码枚举。用于AprilTags。 image.TAG36H11 TAG36H11标签群的位掩码枚举。用于AprilTags。 image.ARTOOLKIT ARTOOLKIT标签群的位掩码枚举。用于AprilTags。 image.EAN2 EAN2条形码类型枚举。 image.EAN5 EAN5条形码类型枚举。 image.EAN8 EAN8条形码类型枚举。 image.UPCE UPCE条形码类型枚举。 image.ISBN10 ISBN10条形码类型枚举。 image.UPCA UPCA条形码类型枚举。 image.EAN13 EAN13条形码类型枚举。 image.ISBN13 ISBN13条形码类型枚举。 image.I25 I25条形码类型枚举。 image.DATABAR DATABAR条形码类型枚举。 image.DATABAR_EXP DATABAR_EXP条形码类型枚举。 image.CODABAR CODABAR条形码类型枚举。 image.CODE39 CODE39条形码类型枚举。 image.PDF417 PDF417条形码类型枚举（目前尚不能运行）。 image.CODE93 CODE93条形码类型枚举。 image.CODE128 CODE128条形码类型枚举。 powered by GitbookFile Modify: 2020-09-11 12:05:50 "},"api_reference/peripheral_modules/":{"url":"api_reference/peripheral_modules/","title":"MaixPy 附加外设模块","keywords":"","body":"外设模块 这里的外设模块主要指片外外设（相对于片上外设，比如GPIO、I2C等），比如 LCD、 摄像头、 触摸屏等等 关于图像相关的暂时放在了 机器视觉 分类， 包括以下外设模块 lcd： 显示图像 sensor： 获取摄像头数据， 取名叫 sensor 是兼容 openmv， 当然也不完全一样，请阅读文档 其它外设模块包括： touchscreen： 触摸屏相关操作，读取触摸屏点击状态以及获取点击的坐标等 ws2812: WS2812单总线灯带 热红外温度传感器 超声波 Grove 链式 RGB LED powered by GitbookFile Modify: 2020-09-11 12:05:50 "},"api_reference/peripheral_modules/touchscreen.html":{"url":"api_reference/peripheral_modules/touchscreen.html","title":"touchscreen","keywords":"","body":"touchscreen 触摸屏幕 touchscreen 模块包含了基本的读取触摸屏幕操作 目前支持的触摸屏幕： ns2009（默认） 如果需要修改驱动型号，需要重新编译 MaixPy 源码修改预编译支持的型号 全局函数 init(i2c=None, cal=None) 初始化触摸屏 API 在后面可能会有所改动（主要是针对多种驱动对参数的改动） 参数 i2c： 目前支持的是 I2C 通信的触摸屏， 传入I2C实例对象， 后期这个参数可能会被重命名或者取消 cal： 校准数据， 是一个 7 个整型值的元组， 可以通过 touchscreen.calibrate() 函数得到 calibrate() 校准屏幕，使屏幕显示和触摸屏像素能够对应 返回值 返回一个 7 个整型值的元组， 可以保存到文件系统或者flash，在初始化的时候传入，这样就不用每次都校准了 read() 读取当前屏幕的状态以及按下的点的坐标值 返回值 一个由 3 个整型值组成的元组 (status, x, y)， 注意这个值会一直保持上一个状态 status： 状态， 取值有 touchscreen.STATUS_PRESS， touchscreen.STATUS_MOVE， touchscreen.STATUS_RELEASE x： x 轴坐标 y： y 轴坐标 常量 touchscreen.STATUS_PRESS 屏幕被按下， read() 函数返回的元组的第一个值 touchscreen.STATUS_MOVE 屏幕被按住并移动，即按住移动， read() 函数返回的元组的第一个值 touchscreen.STATUS_RELEASE 屏幕不再被按住，即没有点击， read() 函数返回的元组的第一个值 例程 例程 1 ： 图画板 黑底白画笔画图板， 使用boot 按键可以清除内容 取消 ts.calibrate() 的注释可以在开始运行触摸屏校准程序 import touchscreen as ts from machine import I2C import lcd, image from board import board_info from fpioa_manager import * board_info=board_info() fm.register(board_info.BOOT_KEY, fm.fpioa.GPIO1) btn_clear = GPIO(GPIO.GPIO1, GPIO.IN) lcd.init() i2c = I2C(I2C.I2C0, freq=400000, scl=30, sda=31) ts.init(i2c) #ts.calibrate() lcd.clear() img = image.Image() status_last = ts.STATUS_IDLE x_last = 0 y_last = 0 draw = False while True: (status,x,y) = ts.read() print(status, x, y) if draw: img.draw_line((x_last, y_last, x, y)) if status_last!=status: if (status==ts.STATUS_PRESS or status == ts.STATUS_MOVE): draw = True else: draw = False status_last = status lcd.display(img) x_last = x y_last = y if btn_clear.value() == 0: img.clear() ts.__del__() powered by GitbookFile Modify: 2020-09-11 12:05:50 "},"api_reference/peripheral_modules/ultrasonic.html":{"url":"api_reference/peripheral_modules/ultrasonic.html","title":"modules.ultrasonic","keywords":"","body":"modules.ultrasonic 超声波传感器 构造方法 ultrasonic(gpiohs) 参数 gpiohs: gpiohs 编号，需要先使用fm注册引脚,比如 ```python from fpioa_manager import * from modules import ultrasonic fm.register(board_info.D[6], fm.fpioa.GPIOHS0, force = True) device = ultrasonic(fm.fpioa.GPIOHS0) ``` 返回值 返回对象 方法 measure(unit, timeout) 参数 unit： 单位， 在下面的常数中取值 timeout: 超时时间，单位为微秒（us） 常数 ultrasonic.UNIT_CM 返回的距离的单位，厘米 ultrasonic.UNIT_INCH 返回的距离的单位，英尺 powered by GitbookFile Modify: 2020-09-11 12:05:50 "},"api_reference/peripheral_modules/ws2812.html":{"url":"api_reference/peripheral_modules/ws2812.html","title":"modules.ws2812","keywords":"","body":"WS2812灯带 (modules.ws2812) 本模块使用K210的I2S进行模块的驱动，所以在使用的过程中需要注意是否冲突 目前最多支持12路灯带 构造函数 from modules import ws2812 class ws2812(led_pin=-1,led_num=-1,i2s_num=I2S_DEVICE_2,i2s_chn=I2S_CHANNEL_3,i2s_dma_chn=DMAC_CHANNEL1) 通过指定参数新建一个 ws2812 对象 参数 led_pin: 灯带数据线连接的引脚，比如 board_info.D[4] led_num: 灯带一共有多少颗灯珠 i2s_num: 该对象使用哪个 I2S 设备进行驱动，默认为 I2S_DEVICE_2,取值范围为 0-2 i2s_chn: 该对象使用哪个 I2S 通道，默认为 I2S_CHANNEL_3，取值范围为 0-3 i2s_dma_chn: 该对象使用的DMA通道，用户一般不考虑 方法 set_led class_ws2812.set_led(num， color) 参数 num : 第 N 颗灯珠，从 0 开始 color : 该灯珠赋值的颜色，为 tuple 类型， （R,G,B） 返回值 无 display class_ws2812.display() 参数 无 返回值 无 例程0 from modules import ws2812 class_ws2812 = ws2812(board_info.D[4],30) for i in range(30): class_ws2812.set_led(i,(0xff,0,0)) class_ws2812.display() 例程1 from modules import ws2812 class_ws2812 = ws2812(board_info.D[4],30) r=0 dir = True while True: if dir: r += 1 else: r -= 1 if r>=255: r = 255 dir = False elif r 以上例程，可见MaixPy_scripts powered by GitbookFile Modify: 2020-09-11 12:05:50 "},"api_reference/peripheral_modules/htpa.html":{"url":"api_reference/peripheral_modules/htpa.html","title":"modules.htpa","keywords":"","body":"HTPA 热红外测温模组(modules.htpa) 海曼 HTPA 32x32 热红外测问模组 构造方法 htpa(i2c, scl_pin, sda_pin, i2c_freq) 创建一个实例 参数 i2c: I2C编号， 比如I2C.I2C0，取值 [0, 2] (见machine.I2C) scl_pin: I2C SCL 引脚 sda_pin: I2C SDA 引脚 i2c_freq: I2C 时钟频率 返回值 htpa 对象 实例方法 temperature() 获取传感器温度值，只能被实例调用 返回值 数组，长度为传感器的宽度x高度，比如32x32 实例方法 width() 获取传感器分辨率宽度，只能被实例调用 返回值 整数，宽度 实例方法 height() 获取传感器分辨率宽度，只能被实例调用 例子 heimann_HTPA_32x32 powered by GitbookFile Modify: 2020-09-11 12:05:50 "},"api_reference/peripheral_modules/grove_chainable_rgb_led.html":{"url":"api_reference/peripheral_modules/grove_chainable_rgb_led.html","title":"Grove RGB LED","keywords":"","body":"Grove 链式 RGB LED 使用两跟线串行连接多个 RGB LED 灯（灯条） 使用 micropython 语法编写， 例程和资料见 MaixPy_Scripts powered by GitbookFile Modify: 2020-09-11 12:05:50 "},"api_reference/application/":{"url":"api_reference/application/","title":"内置应用","keywords":"","body":"内置应用 pye: 集成在 MaixPy 中文件编辑器，直接通过串口编辑板子里的文件 nes: NES FC 红白机 模拟器 lvgl: LittlvGL 图形库 powered by GitbookFile Modify: 2020-09-11 12:05:50 "},"api_reference/application/pye.html":{"url":"api_reference/application/pye.html","title":"Micropython Editor","keywords":"","body":"pye Micropython Editor 集成在 MaixPy 固件中文件编辑器， 可以直接通过串口终端修改板子里面的文件 使用方法： from pye_mp import pye pye(\"/sd/boot.py\") powered by GitbookFile Modify: 2020-09-11 12:05:50 "},"GLOSSARY.html":{"url":"GLOSSARY.html","keywords":"","body":"Glossary Git 分散式版本控制软件 Markdown Aaron Swartz 跟 John Gruber 共同设计的排版语言 powered by GitbookFile Modify: 2020-09-11 12:05:50 "}}